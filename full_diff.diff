diff --git a/cmake/options.cmake b/cmake/options.cmake
index 311f1cefe..cafa01aa2 100644
--- a/cmake/options.cmake
+++ b/cmake/options.cmake
@@ -6,9 +6,10 @@ option(BUILD_GAME_SERVER    "Build game server"                     ON)
 option(BUILD_LOGIN_SERVER   "Build login server"                    ON)
 option(BUILD_EXTRACTORS     "Build map/dbc/vmap/mmap extractors"    OFF)
 option(BUILD_SCRIPTDEV      "Build ScriptDev. (OFF Speedup build)"  ON)
-option(BUILD_PLAYERBOT      "Build Playerbot mod"                   OFF)
-option(BUILD_RECASTDEMOMOD  "Build map/vmap/mmap viewer"            OFF)
-option(BUILD_GIT_ID         "Build git_id"                          OFF)
+option(BUILD_PLAYERBOT      "Build Player Bots"                     ON)
+option(BUILD_RECASTDEMOMOD  "Build map/vmpa/mmap viewer"            OFF)
+option(BUILD_IMMERSIVE      "Build Immersive"                       ON)
+option(BUILD_TEST           "Build Tests"                           ON)
 
 # TODO: options that should be checked/created:
 #option(CLI                  "With CLI"                              ON)
@@ -30,9 +31,10 @@ message(STATUS
     BUILD_LOGIN_SERVER      Build login server (auth server)
     BUILD_EXTRACTORS        Build map/dbc/vmap/mmap extractor
     BUILD_SCRIPTDEV         Build scriptdev. (Disable it to speedup build in dev mode by not including scripts)
-    BUILD_PLAYERBOT         Build Playerbot mod
-    BUILD_RECASTDEMOMOD     Build map/vmap/mmap viewer
-    BUILD_GIT_ID            Build git_id
+    BUILD_PLAYERBOT         Build Player Bots module
+    BUILD_RECASTDEMOMOD     Build map/vmpa/mmap viewer
+    BUILD_IMMERSIVE         Build Immersive module
+    BUILD_TEST              Build Tests
 
   To set an option simply type -D<OPTION>=<VALUE> after 'cmake <srcs>'.
   Also, you can specify the generator with -G. see 'cmake --help' for more details
diff --git a/cmake/showoptions.cmake b/cmake/showoptions.cmake
index cccd85788..e35b4839c 100644
--- a/cmake/showoptions.cmake
+++ b/cmake/showoptions.cmake
@@ -50,9 +50,21 @@ else()
 endif()
 
 if(BUILD_PLAYERBOT)
-  message(STATUS "Build Playerbot       : Yes")
+  message(STATUS "Build Playerbot       : Yes (default)")
 else()
-  message(STATUS "Build Playerbot       : No  (default)")
+  message(STATUS "Build Playerbot       : No")
+endif()
+
+if(BUILD_IMMERSIVE)
+  message(STATUS "Build Immersive       : Yes (default)")
+else()
+  message(STATUS "Build Immersive       : No")
+endif()
+
+if(BUILD_TEST)
+  message(STATUS "Build tests           : Yes (default)")
+else()
+  message(STATUS "Build tests           : No")
 endif()
 
 if(BUILD_EXTRACTORS)
@@ -67,12 +79,6 @@ else()
   message(STATUS "Build RecastDemoMod   : No  (default)")
 endif()
 
-if(BUILD_GIT_ID)
-  message(STATUS "Build git_id          : Yes")
-else()
-  message(STATUS "Build git_id          : No  (default)")
-endif()
-
 # if(SQL)
 #   message(STATUS "Install SQL-files     : Yes")
 # else()
diff --git a/contrib/extractor/System.cpp b/contrib/extractor/System.cpp
index 06f7452f3..a57fefbe7 100644
--- a/contrib/extractor/System.cpp
+++ b/contrib/extractor/System.cpp
@@ -550,7 +550,7 @@ bool ConvertADT(char* filename, char* filename2, int cell_y, int cell_x)
                     {
                         liquid_show[cy][cx] = true;
                         if (liquid->flags[y][x] & (1 << 7))
-                            liquid_flags[i][j] |= MAP_LIQUID_TYPE_DEEP_WATER;
+                            liquid_flags[i][j] |= MAP_LIQUID_TYPE_DARK_WATER;
                         ++count;
                     }
                 }
@@ -633,7 +633,7 @@ bool ConvertADT(char* filename, char* filename2, int cell_y, int cell_x)
                 {
                     uint8* lm = h2o->getLiquidLightMap(h);
                     if (!lm)
-                        liquid_flags[i][j] |= MAP_LIQUID_TYPE_DEEP_WATER;
+                        liquid_flags[i][j] |= MAP_LIQUID_TYPE_DARK_WATER;
                 }
 
                 if (!count && liquid_flags[i][j])
diff --git a/contrib/git_id/CMakeLists.txt b/contrib/git_id/CMakeLists.txt
index c8e39be5b..f0bd03d59 100644
--- a/contrib/git_id/CMakeLists.txt
+++ b/contrib/git_id/CMakeLists.txt
@@ -4,20 +4,4 @@ cmake_minimum_required(VERSION 2.8)
 include(../../cmake/common.cmake)
 include(CheckPlatform)
 
-add_executable(git_id git_id.cpp)
-
-if(WIN32 AND MSVC)
-  if(PLATFORM MATCHES X86) # 32-bit
-    set(FOLDER_ARCH x86)
-  else() # 64-bit
-    set(FOLDER_ARCH x64)
-  endif()
-
-  # Define OutDir to source/bin/(platform)_(configuaration) folder.
-  set_target_properties(git_id PROPERTIES RUNTIME_OUTPUT_DIRECTORY_DEBUG "${DEV_BIN_DIR}/git_id")
-  set_target_properties(git_id PROPERTIES RUNTIME_OUTPUT_DIRECTORY_RELEASE "${DEV_BIN_DIR}/git_id")
-  set_target_properties(git_id PROPERTIES VS_DEBUGGER_WORKING_DIRECTORY "$(OutDir)")
-
-  # Define windows application type to not see a console
-  set_target_properties(git_id PROPERTIES LINK_FLAGS "/SUBSYSTEM:WINDOWS")
-endif()
+ADD_EXECUTABLE(git_id git_id.cpp)
diff --git a/contrib/mmap/src/TerrainBuilder.cpp b/contrib/mmap/src/TerrainBuilder.cpp
index 11b33addf..8a94aad8a 100644
--- a/contrib/mmap/src/TerrainBuilder.cpp
+++ b/contrib/mmap/src/TerrainBuilder.cpp
@@ -335,7 +335,7 @@ namespace MMAP
                 else
                 {
                     liquidType = getLiquidType(i, liquid_flags);
-                    if (liquidType & MAP_LIQUID_TYPE_DEEP_WATER)
+                    if (liquidType & MAP_LIQUID_TYPE_DARK_WATER)
                     {
                         // players should not be here, so logically neither should creatures
                         useTerrain = false;
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index ba37dd1c3..0a04e9f17 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -24,8 +24,13 @@ endif()
 if(BUILD_GAME_SERVER)
   add_subdirectory(game)
   add_subdirectory(mangosd)
+  add_subdirectory(modules)
 endif()
 
 if(BUILD_LOGIN_SERVER)
   add_subdirectory(realmd)
 endif()
+
+if(BUILD_TEST)
+  add_subdirectory(test)
+endif()
diff --git a/src/game/AI/BaseAI/PetAI.cpp b/src/game/AI/BaseAI/PetAI.cpp
index 705ececf5..49e156967 100644
--- a/src/game/AI/BaseAI/PetAI.cpp
+++ b/src/game/AI/BaseAI/PetAI.cpp
@@ -40,9 +40,17 @@ PetAI::PetAI(Creature* creature) : UnitAI(creature), m_creature(creature), inCom
     m_AllySet.clear();
     UpdateAllies();
 
-    if (creature->IsPet() && dynamic_cast<Pet*>(creature)->isControlled()
-        && sWorld.getConfig(CONFIG_BOOL_PET_ATTACK_FROM_BEHIND))
-        m_attackAngle = M_PI_F;
+    switch (((Pet*)creature)->getPetType())
+    {
+        case HUNTER_PET:    //hunter pets attack from behind
+            m_attackAngle = M_PI_F;
+            break;
+        case MINI_PET:
+            SetReactState(REACT_PASSIVE);
+            break;
+        default:
+            break;
+    }
 
     switch (creature->GetUInt32Value(UNIT_CREATED_BY_SPELL))
     {
diff --git a/src/game/CMakeLists.txt b/src/game/CMakeLists.txt
index df686e4f4..134365826 100644
--- a/src/game/CMakeLists.txt
+++ b/src/game/CMakeLists.txt
@@ -21,6 +21,16 @@ set(LIBRARY_NAME game)
 add_definitions(-DDT_POLYREF64)
 add_definitions(-D__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES=0)
 
+# include additionals headers
+include_directories(
+  ${CMAKE_CURRENT_SOURCE_DIR}
+  ${CMAKE_CURRENT_SOURCE_DIR}/vmap
+  ${CMAKE_CURRENT_SOURCE_DIR}/AuctionHouseBot
+  ${CMAKE_CURRENT_SOURCE_DIR}/BattleGround
+  ${CMAKE_CURRENT_SOURCE_DIR}/OutdoorPvP
+  ${CMAKE_BINARY_DIR}
+)
+
 # Find all the input files
 FILE(GLOB_RECURSE LIBRARY_SRCS RELATIVE "${CMAKE_CURRENT_SOURCE_DIR}" "*.h" "*.cpp")
 
@@ -35,17 +45,6 @@ if(NOT BUILD_SCRIPTDEV)
   endforeach()
 endif()
 
-if(NOT BUILD_PLAYERBOT)
-  # exclude Playerbot folder
-  set (EXCLUDE_DIR "PlayerBot/")
-  foreach (TMP_PATH ${LIBRARY_SRCS})
-      string (FIND ${TMP_PATH} ${EXCLUDE_DIR} EXCLUDE_DIR_FOUND)
-      if (NOT ${EXCLUDE_DIR_FOUND} EQUAL -1)
-          list(REMOVE_ITEM LIBRARY_SRCS ${TMP_PATH})
-      endif ()
-  endforeach()
-endif()
-
 # Create visual studio groups using folder structure
 foreach(source ${LIBRARY_SRCS})
     get_filename_component(source_path "${source}" PATH)
@@ -81,6 +80,77 @@ target_include_directories(${LIBRARY_NAME}
   PRIVATE ${Boost_INCLUDE_DIRS}
 )
 
+if(BUILD_PLAYERBOT)
+    include_directories(
+        ${CMAKE_SOURCE_DIR}/src/modules/Bots/playerbot
+        ${CMAKE_SOURCE_DIR}/src/modules/Bots/ahbot
+        ${CMAKE_SOURCE_DIR}/src/game
+        ${CMAKE_SOURCE_DIR}/src/game/AI
+        ${CMAKE_SOURCE_DIR}/src/game/Accounts
+        ${CMAKE_SOURCE_DIR}/src/game/Addons
+        ${CMAKE_SOURCE_DIR}/src/game/Arena
+        ${CMAKE_SOURCE_DIR}/src/game/AuctionHouse
+        ${CMAKE_SOURCE_DIR}/src/game/BattleGround
+        ${CMAKE_SOURCE_DIR}/src/game/Chat
+        ${CMAKE_SOURCE_DIR}/src/game/ChatCommands
+        ${CMAKE_SOURCE_DIR}/src/game/Combat
+        ${CMAKE_SOURCE_DIR}/src/game/DBScripts
+        ${CMAKE_SOURCE_DIR}/src/game/Entities
+        ${CMAKE_SOURCE_DIR}/src/game/GMTickets
+        ${CMAKE_SOURCE_DIR}/src/game/GameEvents
+        ${CMAKE_SOURCE_DIR}/src/game/Globals
+        ${CMAKE_SOURCE_DIR}/src/game/Grids
+        ${CMAKE_SOURCE_DIR}/src/game/Groups
+        ${CMAKE_SOURCE_DIR}/src/game/Guilds
+        ${CMAKE_SOURCE_DIR}/src/game/LFG
+        ${CMAKE_SOURCE_DIR}/src/game/Loot
+        ${CMAKE_SOURCE_DIR}/src/game/Mails
+        ${CMAKE_SOURCE_DIR}/src/game/Maps
+        ${CMAKE_SOURCE_DIR}/src/game/MotionGenerators
+        ${CMAKE_SOURCE_DIR}/src/game/Movement
+        ${CMAKE_SOURCE_DIR}/src/game/Object
+        ${CMAKE_SOURCE_DIR}/src/game/OutdoorPvP
+        ${CMAKE_SOURCE_DIR}/src/game/Pools
+        ${CMAKE_SOURCE_DIR}/src/game/Quests
+        ${CMAKE_SOURCE_DIR}/src/game/References
+        ${CMAKE_SOURCE_DIR}/src/game/Reputation
+        ${CMAKE_SOURCE_DIR}/src/game/Server
+        ${CMAKE_SOURCE_DIR}/src/game/Server
+        ${CMAKE_SOURCE_DIR}/src/game/Skills
+        ${CMAKE_SOURCE_DIR}/src/game/Social
+        ${CMAKE_SOURCE_DIR}/src/game/Spells
+        ${CMAKE_SOURCE_DIR}/src/game/Tools
+        ${CMAKE_SOURCE_DIR}/src/game/Trade
+        ${CMAKE_SOURCE_DIR}/src/game/VoiceChat
+        ${CMAKE_SOURCE_DIR}/src/game/Warden
+        ${CMAKE_SOURCE_DIR}/src/game/Weather
+        ${CMAKE_SOURCE_DIR}/src/game/World
+        ${CMAKE_SOURCE_DIR}/src/game/WorldHandlers
+        ${CMAKE_SOURCE_DIR}/src/game/movement
+        ${CMAKE_SOURCE_DIR}/src/game/vmap
+        ${CMAKE_SOURCE_DIR}/src/shared
+        ${CMAKE_SOURCE_DIR}/src/shared/Auth
+        ${CMAKE_SOURCE_DIR}/src/shared/Config
+        ${CMAKE_SOURCE_DIR}/src/shared/Common
+        ${CMAKE_SOURCE_DIR}/src/shared/Database
+        ${CMAKE_SOURCE_DIR}/src/shared/DataStores
+        ${CMAKE_SOURCE_DIR}/src/shared/Utilities
+        ${CMAKE_SOURCE_DIR}/src/shared/Log
+        ${CMAKE_SOURCE_DIR}/src/shared/Threading
+    )
+    target_link_libraries(${LIBRARY_NAME} PUBLIC Bots)
+    add_dependencies(${LIBRARY_NAME} Bots)
+endif()
+
+if(BUILD_IMMERSIVE)
+    include_directories(
+        ${CMAKE_SOURCE_DIR}/src/modules/Immersive
+        ${CMAKE_SOURCE_DIR}/src/modules/Immersive
+    )
+    target_link_libraries(${LIBRARY_NAME} PUBLIC Immersive)
+    add_dependencies(${LIBRARY_NAME} Immersive)
+endif()
+
 if(UNIX)
   # Both systems don't have libdl and don't need them
   if (NOT (CMAKE_SYSTEM_NAME STREQUAL "FreeBSD" OR CMAKE_SYSTEM_NAME STREQUAL "NetBSD"))
@@ -93,9 +163,14 @@ if (BUILD_SCRIPTDEV)
   add_definitions(-DBUILD_SCRIPTDEV)
 endif()
 
-# Define BUILD_PLAYERBOT if need
+# Define ENABLE_PLAYERBOTS if need
 if (BUILD_PLAYERBOT)
-  add_definitions(-DBUILD_PLAYERBOT)
+  add_definitions(-DENABLE_PLAYERBOTS)
+endif()
+
+# Define ENABLE_IMMERSIVE if need
+if (BUILD_IMMERSIVE)
+  add_definitions(-DENABLE_IMMERSIVE)
 endif()
 
 # Generate precompiled header
diff --git a/src/game/Chat/Chat.cpp b/src/game/Chat/Chat.cpp
index c8bc6e589..6712d6d17 100644
--- a/src/game/Chat/Chat.cpp
+++ b/src/game/Chat/Chat.cpp
@@ -34,7 +34,11 @@
 #include "Pools/PoolManager.h"
 #include "GameEvents/GameEventMgr.h"
 #include "AuctionHouseBot/AuctionHouseBot.h"
-
+#ifdef ENABLE_PLAYERBOTS
+#include "AhBot.h"
+#include "playerbot.h"
+#include "GuildTaskMgr.h"
+#endif /* ENABLE_PLAYERBOTS */
 #include <cstdarg>
 
 // Supported shift-links (client generated and server side)
@@ -757,7 +761,15 @@ ChatCommand* ChatHandler::getCommandTable()
     {
         { "account",        SEC_PLAYER,         true,  nullptr,                                        "", accountCommandTable  },
         { "auction",        SEC_ADMINISTRATOR,  false, nullptr,                                        "", auctionCommandTable  },
-        { "ahbot",          SEC_ADMINISTRATOR,  true,  nullptr,                                        "", ahbotCommandTable    },
+#ifndef ENABLE_PLAYERBOTS
+        { "ahbot",          SEC_ADMINISTRATOR,  true,  NULL,                                           "", ahbotCommandTable    },
+#else
+        { "ahbot",            SEC_GAMEMASTER,    true,  &ChatHandler::HandleAhBotCommand,                      "" },
+        { "rndbot",           SEC_GAMEMASTER,    true,  &ChatHandler::HandleRandomPlayerbotCommand,     "" },
+        { "bot",              SEC_PLAYER,        false, &ChatHandler::HandlePlayerbotCommand,               "" },
+        { "gtask",            SEC_GAMEMASTER,    true,  &ChatHandler::HandleGuildTaskCommand,           "" },
+        { "pmon",             SEC_GAMEMASTER,    true,  &ChatHandler::HandlePerfMonCommand,           "" },
+#endif
         { "cast",           SEC_ADMINISTRATOR,  false, nullptr,                                        "", castCommandTable     },
         { "character",      SEC_GAMEMASTER,     true,  nullptr,                                        "", characterCommandTable},
         { "debug",          SEC_MODERATOR,      true,  nullptr,                                        "", debugCommandTable    },
@@ -848,9 +860,6 @@ ChatCommand* ChatHandler::getCommandTable()
         { "waterwalk",      SEC_GAMEMASTER,     false, &ChatHandler::HandleWaterwalkCommand,           "", nullptr },
         { "quit",           SEC_CONSOLE,        true,  &ChatHandler::HandleQuitCommand,                "", nullptr },
         { "mmap",           SEC_GAMEMASTER,     false, nullptr,                                        "", mmapCommandTable },
-#ifdef BUILD_PLAYERBOT
-        { "bot",            SEC_PLAYER,         false, &ChatHandler::HandlePlayerbotCommand,           "", nullptr },
-#endif
         { nullptr,          0,                  false, nullptr,                                        "", nullptr }
     };
 
diff --git a/src/game/Chat/Chat.h b/src/game/Chat/Chat.h
index cec6fc158..7170ff785 100644
--- a/src/game/Chat/Chat.h
+++ b/src/game/Chat/Chat.h
@@ -98,6 +98,9 @@ class ChatHandler
         bool isValidChatMessage(const char* message) const;
         bool HasSentErrorMessage() const { return sentErrorMessage;}
 
+#ifdef ENABLE_PLAYERBOTS
+        WorldSession* GetSession() { return m_session; }
+#endif
         /**
         * \brief Prepare SMSG_GM_MESSAGECHAT/SMSG_MESSAGECHAT
         *
@@ -618,9 +621,6 @@ class ChatHandler
         bool HandleStableCommand(char* args);
         bool HandleWaterwalkCommand(char* args);
         bool HandleQuitCommand(char* args);
-#ifdef BUILD_PLAYERBOT
-        bool HandlePlayerbotCommand(char* args);
-#endif
 
         bool HandleArenaFlushPointsCommand(char* args);
         bool HandleArenaSeasonRewardsCommand(char* args);
@@ -634,6 +634,14 @@ class ChatHandler
         bool HandleMmapTestArea(char* args);
         bool HandleMmapTestHeight(char* args);
 
+#ifdef ENABLE_PLAYERBOTS
+        bool HandlePlayerbotCommand(char* args);
+        bool HandleRandomPlayerbotCommand(char* args);
+        bool HandleAhBotCommand(char* args);
+        bool HandleGuildTaskCommand(char* args);
+        bool HandlePerfMonCommand(char* args);
+#endif
+
         bool HandleLinkAddCommand(char* args);
         bool HandleLinkRemoveCommand(char* args);
         bool HandleLinkEditCommand(char* args);
diff --git a/src/game/Chat/ChatHandler.cpp b/src/game/Chat/ChatHandler.cpp
index 09659521a..37062de7e 100644
--- a/src/game/Chat/ChatHandler.cpp
+++ b/src/game/Chat/ChatHandler.cpp
@@ -34,6 +34,10 @@
 #include "Util.h"
 #include "Grids/GridNotifiersImpl.h"
 #include "Grids/CellImpl.h"
+#ifdef ENABLE_PLAYERBOTS
+#include "playerbot.h"
+#include "RandomPlayerbotMgr.h"
+#endif
 
 bool WorldSession::processChatmessageFurtherAfterSecurityChecks(std::string& msg, uint32 lang)
 {
@@ -225,6 +229,15 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recv_data)
                 }
             }
 
+#ifdef ENABLE_PLAYERBOTS
+            if (player->GetPlayerbotAI())
+            {
+                player->GetPlayerbotAI()->HandleCommand(type, msg, *GetPlayer());
+                GetPlayer()->m_speakTime = 0;
+                GetPlayer()->m_speakCount = 0;
+            }
+            else
+#endif
             GetPlayer()->Whisper(msg, lang, player->GetObjectGuid());
         } break;
 
@@ -254,6 +267,18 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recv_data)
                     return;
             }
 
+#ifdef ENABLE_PLAYERBOTS
+            for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player* player = itr->getSource();
+                if (player && player->GetPlayerbotAI())
+                {
+                    player->GetPlayerbotAI()->HandleCommand(type, msg, *GetPlayer());
+                    GetPlayer()->m_speakTime = 0;
+                    GetPlayer()->m_speakCount = 0;
+                }
+            }
+#endif
             WorldPacket data;
             ChatHandler::BuildChatPacket(data, ChatMsg(type), msg.c_str(), Language(lang), _player->GetChatTag(), _player->GetObjectGuid(), _player->GetName());
             group->BroadcastPacket(data, false, group->GetMemberGroup(GetPlayer()->GetObjectGuid()));
@@ -281,6 +306,18 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recv_data)
                 if (Guild* guild = sGuildMgr.GetGuildById(GetPlayer()->GetGuildId()))
                     guild->BroadcastToGuild(this, msg, lang == LANG_ADDON ? LANG_ADDON : LANG_UNIVERSAL);
 
+#ifdef ENABLE_PLAYERBOTS
+                PlayerbotMgr *mgr = GetPlayer()->GetPlayerbotMgr();
+                if (mgr)
+                {
+                    for (PlayerBotMap::const_iterator it = mgr->GetPlayerBotsBegin(); it != mgr->GetPlayerBotsEnd(); ++it)
+                    {
+                        Player* const bot = it->second;
+                        if (bot->GetGuildId() == GetPlayer()->GetGuildId())
+                            bot->GetPlayerbotAI()->HandleCommand(type, msg, *GetPlayer());
+                    }
+                }
+#endif
             break;
         }
         case CHAT_MSG_OFFICER:
@@ -332,6 +369,18 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recv_data)
                     return;
             }
 
+#ifdef ENABLE_PLAYERBOTS
+            for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player* player = itr->getSource();
+                if (player && player->GetPlayerbotAI())
+                {
+                    player->GetPlayerbotAI()->HandleCommand(type, msg, *GetPlayer());
+                    GetPlayer()->m_speakTime = 0;
+                    GetPlayer()->m_speakCount = 0;
+                }
+            }
+#endif
             WorldPacket data;
             ChatHandler::BuildChatPacket(data, CHAT_MSG_RAID, msg.c_str(), Language(lang), _player->GetChatTag(), _player->GetObjectGuid(), _player->GetName());
             group->BroadcastPacket(data, false);
@@ -362,6 +411,18 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recv_data)
                     return;
             }
 
+#ifdef ENABLE_PLAYERBOTS
+            for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player* player = itr->getSource();
+                if (player && player->GetPlayerbotAI())
+                {
+                    player->GetPlayerbotAI()->HandleCommand(type, msg, *GetPlayer());
+                    GetPlayer()->m_speakTime = 0;
+                    GetPlayer()->m_speakCount = 0;
+                }
+            }
+#endif
             WorldPacket data;
             ChatHandler::BuildChatPacket(data, CHAT_MSG_RAID_LEADER, msg.c_str(), Language(lang), _player->GetChatTag(), _player->GetObjectGuid(), _player->GetName());
             group->BroadcastPacket(data, false);
@@ -383,6 +444,18 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recv_data)
                     !(group->IsLeader(GetPlayer()->GetObjectGuid()) || group->IsAssistant(GetPlayer()->GetObjectGuid())))
                 return;
 
+#ifdef ENABLE_PLAYERBOTS
+            for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player* player = itr->getSource();
+                if (player && player->GetPlayerbotAI())
+                {
+                    player->GetPlayerbotAI()->HandleCommand(type, msg, *GetPlayer());
+                    GetPlayer()->m_speakTime = 0;
+                    GetPlayer()->m_speakCount = 0;
+                }
+            }
+#endif
             WorldPacket data;
             // in battleground, raid warning is sent only to players in battleground - code is ok
             ChatHandler::BuildChatPacket(data, CHAT_MSG_RAID_WARNING, msg.c_str(), Language(lang), _player->GetChatTag(), _player->GetObjectGuid(), _player->GetName());
@@ -445,7 +518,16 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recv_data)
 
             if (ChannelMgr* cMgr = channelMgr(_player->GetTeam()))
                 if (Channel* chn = cMgr->GetChannel(channel, _player))
+                {
+#ifdef ENABLE_PLAYERBOTS
+                    if (_player->GetPlayerbotMgr() && chn->GetFlags() & 0x18)
+                    {
+                        _player->GetPlayerbotMgr()->HandleCommand(type, msg);
+                    }
+                    sRandomPlayerbotMgr.HandleCommand(type, msg, *_player);
+#endif
                     chn->Say(_player, msg.c_str(), lang);
+                }
         } break;
 
         case CHAT_MSG_AFK:
diff --git a/src/game/Chat/Level3.cpp b/src/game/Chat/Level3.cpp
index b6c311ca1..6fe258538 100644
--- a/src/game/Chat/Level3.cpp
+++ b/src/game/Chat/Level3.cpp
@@ -3620,7 +3620,7 @@ bool ChatHandler::HandleDamageCommand(char* args)
     if (damage_int <= 0)
         return true;
 
-    uint32 damage = uint32(damage_int);
+    uint32 damage = damage_int;
 
     // flat melee damage without resistance/etc reduction
     if (!*args)
@@ -3647,18 +3647,14 @@ bool ChatHandler::HandleDamageCommand(char* args)
     if (!*args)
     {
         uint32 absorb = 0;
-        int32 resist = 0;
+        uint32 resist = 0;
 
         target->CalculateDamageAbsorbAndResist(player, schoolmask, SPELL_DIRECT_DAMAGE, damage, &absorb, &resist);
 
-        const uint32 bonus = (resist < 0 ? uint32(std::abs(resist)) : 0);
-        damage += bonus;
-        const uint32 malus = (resist > 0 ? (absorb + uint32(resist)) : absorb);
-
-        if (damage <= malus)
+        if (damage <= absorb + resist)
             return true;
 
-        damage -= malus;
+        damage -= absorb + resist;
 
         player->DealDamageMods(target, damage, &absorb, DIRECT_DAMAGE);
         player->DealDamage(target, damage, nullptr, DIRECT_DAMAGE, schoolmask, nullptr, false);
diff --git a/src/game/Entities/CharacterHandler.cpp b/src/game/Entities/CharacterHandler.cpp
index 83c8d9494..40aaeb211 100644
--- a/src/game/Entities/CharacterHandler.cpp
+++ b/src/game/Entities/CharacterHandler.cpp
@@ -38,9 +38,9 @@
 #include "Util.h"
 #include "Tools/Language.h"
 #include "AI/ScriptDevAI/ScriptDevAIMgr.h"
-
-#ifdef BUILD_PLAYERBOT
-#include "PlayerBot/Base/PlayerbotMgr.h"
+#ifdef ENABLE_PLAYERBOTS
+#include "playerbot.h"
+#include "PlayerbotAIConfig.h"
 #endif
 
 // config option SkipCinematics supported values
@@ -64,6 +64,100 @@ class LoginQueryHolder : public SqlQueryHolder
         bool Initialize();
 };
 
+#ifdef ENABLE_PLAYERBOTS
+
+class PlayerbotLoginQueryHolder : public LoginQueryHolder
+{
+private:
+    uint32 masterAccountId;
+    PlayerbotHolder* playerbotHolder;
+
+public:
+    PlayerbotLoginQueryHolder(PlayerbotHolder* playerbotHolder, uint32 masterAccount, uint32 accountId, uint64 guid)
+        : LoginQueryHolder(accountId, ObjectGuid(guid)), masterAccountId(masterAccount), playerbotHolder(playerbotHolder) { }
+
+public:
+    uint32 GetMasterAccountId() const { return masterAccountId; }
+    PlayerbotHolder* GetPlayerbotHolder() { return playerbotHolder; }
+};
+
+void PlayerbotHolder::AddPlayerBot(uint64 playerGuid, uint32 masterAccount)
+{
+    // has bot already been added?
+    Player* bot = sObjectMgr.GetPlayer(ObjectGuid(playerGuid));
+
+    if (bot && bot->IsInWorld())
+        return;
+
+    uint32 accountId = sObjectMgr.GetPlayerAccountIdByGUID(ObjectGuid(playerGuid));
+    if (accountId == 0)
+        return;
+
+    PlayerbotLoginQueryHolder *holder = new PlayerbotLoginQueryHolder(this, masterAccount, accountId, playerGuid);
+    if (!holder->Initialize())
+    {
+        delete holder;                                      // delete all unprocessed queries
+        return;
+    }
+
+    CharacterDatabase.DelayQueryHolder(this, &PlayerbotHolder::HandlePlayerBotLoginCallback, holder);
+}
+
+void PlayerbotHolder::HandlePlayerBotLoginCallback(QueryResult * dummy, SqlQueryHolder * holder)
+{
+    if (!holder)
+        return;
+
+    PlayerbotLoginQueryHolder* lqh = (PlayerbotLoginQueryHolder*)holder;
+    uint32 masterAccount = lqh->GetMasterAccountId();
+
+    WorldSession* masterSession = masterAccount ? sWorld.FindSession(masterAccount) : NULL;
+    uint32 botAccountId = lqh->GetAccountId();
+    WorldSession *botSession = new WorldSession(botAccountId, NULL, SEC_PLAYER,
+#ifdef MANGOSBOT_ONE
+        1,
+#endif
+        0, LOCALE_enUS);
+
+    botSession->HandlePlayerLogin(lqh); // will delete lqh
+
+    Player* bot = botSession->GetPlayer();
+    if (!bot)
+    {
+        uint32 guid = lqh->GetGuid().GetRawValue();
+        sLog.outError("Error logging in bot %d", guid);
+        sRandomPlayerbotMgr.OnPlayerLoginError(guid);
+        return;
+    }
+    PlayerbotMgr *mgr = bot->GetPlayerbotMgr();
+    bot->SetPlayerbotMgr(NULL);
+    delete mgr;
+    sRandomPlayerbotMgr.OnPlayerLogin(bot);
+
+    bool allowed = false;
+    if (botAccountId == masterAccount)
+        allowed = true;
+    else if (masterSession && sPlayerbotAIConfig.allowGuildBots && bot->GetGuildId() == masterSession->GetPlayer()->GetGuildId())
+        allowed = true;
+    else if (sPlayerbotAIConfig.IsInRandomAccountList(botAccountId))
+        allowed = true;
+
+    if (allowed)
+    {
+        OnBotLogin(bot);
+        return;
+    }
+
+    if (masterSession)
+    {
+        ChatHandler ch(masterSession);
+        ch.PSendSysMessage("You are not allowed to control bot %s", bot->GetName());
+    }
+    LogoutPlayerBot(bot->GetObjectGuid());
+    sLog.outError("Attempt to add not allowed bot %s, please try to reset all random bots", bot->GetName());
+}
+#endif
+
 bool LoginQueryHolder::Initialize()
 {
     SetSize(MAX_PLAYER_LOGIN_QUERY);
@@ -123,33 +217,17 @@ class CharacterHandler
 
             if (WorldSession* session = sWorld.FindSession(((LoginQueryHolder*)holder)->GetAccountId()))
                 session->HandlePlayerLogin((LoginQueryHolder*)holder);
-        }
-#ifdef BUILD_PLAYERBOT
-        // This callback is different from the normal HandlePlayerLoginCallback in that it
-        // sets up the bot's world session and also stores the pointer to the bot player in the master's
-        // world session m_playerBots map
-        void HandlePlayerBotLoginCallback(QueryResult* /*dummy*/, SqlQueryHolder* holder)
-        {
-            if (!holder)
-                return;
-
-            LoginQueryHolder* lqh = (LoginQueryHolder*) holder;
-
-            WorldSession* masterSession = sWorld.FindSession(lqh->GetAccountId());
-
-            if (! masterSession || sObjectMgr.GetPlayer(lqh->GetGuid()))
+#ifdef ENABLE_PLAYERBOTS
+            ObjectGuid guid = ((LoginQueryHolder*)holder)->GetGuid();
+            Player* player = sObjectMgr.GetPlayer(guid, true);
+            if (player && !player->GetPlayerbotAI())
             {
-                delete holder;
-                return;
+                player->SetPlayerbotMgr(new PlayerbotMgr(player));
+                player->GetPlayerbotMgr()->OnPlayerLogin(player);
             }
-
-            // The bot's WorldSession is owned by the bot's Player object
-            // The bot's WorldSession is deleted by PlayerbotMgr::LogoutPlayerBot
-            WorldSession* botSession = new WorldSession(lqh->GetAccountId(), nullptr, SEC_PLAYER, masterSession->Expansion(), 0, LOCALE_enUS);
-            botSession->HandlePlayerLogin(lqh); // will delete lqh
-            masterSession->GetPlayer()->GetPlayerbotMgr()->OnBotLogin(botSession->GetPlayer());
-        }
+            if (player) sRandomPlayerbotMgr.OnPlayerLogin(player);
 #endif
+        }
 } chrHandler;
 
 void WorldSession::HandleCharEnum(QueryResult* result)
@@ -532,29 +610,6 @@ void WorldSession::HandlePlayerLoginOpcode(WorldPacket& recv_data)
     CharacterDatabase.DelayQueryHolder(&chrHandler, &CharacterHandler::HandlePlayerLoginCallback, holder);
 }
 
-#ifdef BUILD_PLAYERBOT
-// Can't easily reuse HandlePlayerLoginOpcode for logging in bots because it assumes
-// a WorldSession exists for the bot. The WorldSession for a bot is created after the character is loaded.
-void PlayerbotMgr::LoginPlayerBot(ObjectGuid playerGuid)
-{
-    // has bot already been added?
-    if (sObjectMgr.GetPlayer(playerGuid))
-        return;
-
-    uint32 accountId = sObjectMgr.GetPlayerAccountIdByGUID(playerGuid);
-    if (accountId == 0)
-        return;
-
-    LoginQueryHolder* holder = new LoginQueryHolder(accountId, playerGuid);
-    if (!holder->Initialize())
-    {
-        delete holder;                                      // delete all unprocessed queries
-        return;
-    }
-    CharacterDatabase.DelayQueryHolder(&chrHandler, &CharacterHandler::HandlePlayerBotLoginCallback, holder);
-}
-#endif
-
 void WorldSession::HandlePlayerLogin(LoginQueryHolder* holder)
 {
     ObjectGuid playerGuid = holder->GetGuid();
@@ -774,7 +829,12 @@ void WorldSession::HandlePlayerLogin(LoginQueryHolder* holder)
             pCurrChar->CastSpell(pCurrChar, invisibleAuraInfo, TRIGGERED_OLD_TRIGGERED);
     }
 
-    std::string IP_str = GetRemoteAddress();
+    std::string IP_str =
+#ifdef ENABLE_PLAYERBOTS
+        m_Socket ? m_Socket->GetRemoteAddress() : "bot";
+#else
+        GetRemoteAddress();
+#endif
     sLog.outChar("Account: %d (IP: %s) Login Character:[%s] (guid: %u)",
                  GetAccountId(), IP_str.c_str(), pCurrChar->GetName(), pCurrChar->GetGUIDLow());
 
@@ -896,9 +956,6 @@ void WorldSession::HandlePlayerReconnect()
     // initialize client pet bar if need
     _player->SendPetBar();
 
-    // send mirror timers
-    _player->SendMirrorTimers(true);
-
     m_playerLoading = false;
 }
 
diff --git a/src/game/Entities/Creature.h b/src/game/Entities/Creature.h
index 15b76c172..9dfd6d6e2 100644
--- a/src/game/Entities/Creature.h
+++ b/src/game/Entities/Creature.h
@@ -433,24 +433,6 @@ typedef std::list<VendorItemCount> VendorItemCounts;
 
 struct TrainerSpell
 {
-#ifdef BUILD_PLAYERBOT
-    TrainerSpell() : spell(0), spellCost(0), reqSkill(0), reqSkillValue(0), reqLevel(0), learnedSpell(0), isProvidedReqLevel(false), conditionId(0) {}
-
-    TrainerSpell(uint32 _spell, uint32 _spellCost, uint32 _reqSkill, uint32 _reqSkillValue, uint32 _reqLevel, uint32 _learnedspell, bool _isProvidedReqLevel, uint32 _conditionId)
-        : spell(_spell), spellCost(_spellCost), reqSkill(_reqSkill), reqSkillValue(_reqSkillValue), reqLevel(_reqLevel), learnedSpell(_learnedspell), isProvidedReqLevel(_isProvidedReqLevel), conditionId(_conditionId) {}
-
-    uint32 spell;
-    uint32 spellCost;
-    uint32 reqSkill;
-    uint32 reqSkillValue;
-    uint32 reqLevel;
-    uint32 learnedSpell;
-    uint32 conditionId;
-    bool isProvidedReqLevel;
-
-    // helpers
-    bool IsCastable() const { return learnedSpell != spell; }
-#else
     TrainerSpell() : spell(0), spellCost(0), reqSkill(0), reqSkillValue(0), reqLevel(0), learnedSpell(0), conditionId(0), isProvidedReqLevel(false) {}
 
     TrainerSpell(uint32 _spell, uint32 _spellCost, uint32 _reqSkill, uint32 _reqSkillValue, uint32 _reqLevel, uint32 _learnedspell, bool _isProvidedReqLevel, uint32 _conditionId)
@@ -467,7 +449,6 @@ struct TrainerSpell
 
     // helpers
     bool IsCastable() const { return learnedSpell != spell; }
-#endif
 };
 
 typedef std::unordered_map < uint32 /*spellid*/, TrainerSpell > TrainerSpellMap;
@@ -603,11 +584,6 @@ class Creature : public Unit
         bool IsTemporarySummon() const { return m_subtype == CREATURE_SUBTYPE_TEMPORARY_SUMMON; }
         bool IsCritter() const { return m_creatureInfo->CreatureType == CREATURE_TYPE_CRITTER; }
 
-#ifdef BUILD_PLAYERBOT
-        // Adds functionality to load/unload bots from NPC, also need to apply SQL scripts
-        void LoadBotMenu(Player* pPlayer);
-#endif
-
         bool IsCorpse() const { return getDeathState() ==  CORPSE; }
         bool IsDespawned() const { return getDeathState() ==  DEAD; }
         void SetCorpseDelay(uint32 delay) { m_corpseDelay = delay; }
diff --git a/src/game/Entities/GameObject.cpp b/src/game/Entities/GameObject.cpp
index 4b13b5eee..4319e3810 100644
--- a/src/game/Entities/GameObject.cpp
+++ b/src/game/Entities/GameObject.cpp
@@ -41,6 +41,9 @@
 #include "vmap/GameObjectModel.h"
 #include "Server/SQLStorages.h"
 #include "World/WorldState.h"
+#ifdef ENABLE_IMMERSIVE
+#include "immersive.h"
+#endif
 
 GameObject::GameObject() : WorldObject(),
     m_model(nullptr),
@@ -360,7 +363,7 @@ void GameObject::Update(const uint32 diff)
                             {
                                 if (m_respawnTime > 0)
                                     valid = false;
-                                else // battlegrounds gameobjects has data2 == 0 && data5 == 3                                
+                                else // battlegrounds gameobjects has data2 == 0 && data5 == 3
                                     radius = float(goInfo->trap.cooldown);
                             }
                         }
@@ -1494,6 +1497,9 @@ void GameObject::Use(Unit* user)
 
                     // normal chance
                     bool success = skill >= zone_skill && chance >= roll;
+#ifdef ENABLE_IMMERSIVE
+                    success = sImmersive.OnFishing(player, success);
+#endif
                     GameObject* fishingHole = nullptr;
 
                     // overwrite fail in case fishhole if allowed (after 3.3.0)
@@ -1705,7 +1711,7 @@ void GameObject::Use(Unit* user)
                 return;
 
             Player* player = (Player*)user;
-            
+
             delete loot;
             loot = new Loot(player, this, LOOT_FISHINGHOLE);
             loot->ShowContentTo(player);
diff --git a/src/game/Entities/GossipDef.h b/src/game/Entities/GossipDef.h
index b7d39364a..ecf83bd14 100644
--- a/src/game/Entities/GossipDef.h
+++ b/src/game/Entities/GossipDef.h
@@ -49,8 +49,9 @@ enum Gossip_Option
     GOSSIP_OPTION_ARMORER           = 15,                   // UNIT_NPC_FLAG_ARMORER            (4096)
     GOSSIP_OPTION_UNLEARNTALENTS    = 16,                   // UNIT_NPC_FLAG_TRAINER            (16) (bonus option for GOSSIP_OPTION_TRAINER)
     GOSSIP_OPTION_UNLEARNPETSKILLS  = 17,                   // UNIT_NPC_FLAG_TRAINER            (16) (bonus option for GOSSIP_OPTION_TRAINER)
-    GOSSIP_OPTION_BOT               = 99,                   // UNIT_NPC_FLAG_GOSSIP             (1) UNUSED (just for bot system)
-
+#ifdef ENABLE_IMMERSIVE
+    GOSSIP_OPTION_IMMERSIVE         = 18,                   // UNIT_NPC_FLAG_TRAINER             (16) (bonus option for GOSSIP_OPTION_TRAINER)
+#endif
     GOSSIP_OPTION_MAX
 };
 
diff --git a/src/game/Entities/Item.cpp b/src/game/Entities/Item.cpp
index cd593fb8a..2eece6286 100644
--- a/src/game/Entities/Item.cpp
+++ b/src/game/Entities/Item.cpp
@@ -1041,6 +1041,11 @@ void Item::SetEnchantmentModifier(SpellModifier* mod)
 // time.
 void Item::SendTimeUpdate(Player* owner) const
 {
+#ifdef ENABLE_PLAYERBOTS
+    if (!owner || !owner->IsInWorld() || owner->GetPlayerbotAI())
+        return;
+#endif
+
     uint32 duration = GetUInt32Value(ITEM_FIELD_DURATION);
     if (!duration)
         return;
diff --git a/src/game/Entities/Player.cpp b/src/game/Entities/Player.cpp
index 849920752..de6c7d172 100644
--- a/src/game/Entities/Player.cpp
+++ b/src/game/Entities/Player.cpp
@@ -64,11 +64,11 @@
 #include "Loot/LootMgr.h"
 #include "World/WorldStateDefines.h"
 #include "World/WorldState.h"
-
-#ifdef BUILD_PLAYERBOT
-#include "PlayerBot/Base/PlayerbotAI.h"
-#include "PlayerBot/Base/PlayerbotMgr.h"
-#include "Config/Config.h"
+#ifdef ENABLE_PLAYERBOTS
+#include "playerbot.h"
+#endif
+#ifdef ENABLE_IMMERSIVE
+#include "immersive.h"
 #endif
 
 #include <cmath>
@@ -87,10 +87,6 @@
 #define SKILL_PERM_BONUS(x)    int16(PAIR32_HIPART(x))
 #define MAKE_SKILL_BONUS(t, p) MAKE_PAIR32(t,p)
 
-#ifdef BUILD_PLAYERBOT
-extern Config botConfig;
-#endif
-
 enum CharacterFlags
 {
     CHARACTER_FLAG_NONE                 = 0x00000000,
@@ -134,139 +130,6 @@ enum CharacterFlags
 
 static const uint32 corpseReclaimDelay[MAX_DEATH_COUNT] = {30, 60, 120};
 
-MirrorTimer::Status MirrorTimer::FetchStatus()
-{
-    Status status = m_status;
-    m_status = UNCHANGED;
-    return status;
-}
-
-void MirrorTimer::Stop()
-{
-    if (m_active)
-    {
-        m_active = false;
-        m_pulse.SetCurrent(0);
-        m_tracker.SetCurrent(0);
-        m_status = STATUS_UPDATE;
-    }
-}
-
-void MirrorTimer::Start(uint32 interval, uint32 spellId/* = 0*/)
-{
-    if (m_scale < 0)
-    {
-        m_active = true;
-        m_pulse.SetCurrent(0);
-        m_pulse.SetInterval(2 * IN_MILLISECONDS);
-        m_tracker.SetCurrent(0);
-        m_tracker.SetInterval(interval);
-        m_spellId = spellId;
-        m_status = FULL_UPDATE;
-    }
-    else
-        Stop();
-}
-
-void MirrorTimer::Start(uint32 current, uint32 max, uint32 spellId)
-{
-    Start(max, spellId);
-
-    if (m_active)
-    {
-        m_tracker.SetCurrent(max - current);
-        SetFrozen(false);
-    }
-}
-
-void MirrorTimer::SetRemaining(uint32 duration)
-{
-    if (!duration)
-        return Stop();
-
-    if (IsActive() && duration != GetRemaining())
-        m_status = FULL_UPDATE;
-
-    m_tracker.SetCurrent(GetDuration() - duration);
-}
-
-void MirrorTimer::SetDuration(uint32 duration)
-{
-    if (!duration)
-        return Stop();
-
-    if (IsActive() && duration != GetDuration())
-        m_status = FULL_UPDATE;
-
-    m_tracker.SetInterval(duration);
-}
-
-void MirrorTimer::SetFrozen(bool state)
-{
-    if (IsActive() && state != IsFrozen())
-        m_status = STATUS_UPDATE;
-
-    m_frozen = state;
-}
-
-void MirrorTimer::SetScale(int32 scale)
-{
-    if (!scale)
-        return SetFrozen(true);
-
-    if (IsActive() && scale != m_scale)
-        m_status = FULL_UPDATE;
-
-    m_scale = scale;
-}
-
-bool MirrorTimer::Update(uint32 diff)
-{
-    if (!IsActive() || IsFrozen())
-        return true;
-
-    diff *= uint32(std::abs(m_scale));
-
-    if (m_scale < 0)    // Timer running out
-    {
-        m_tracker.Update(diff);
-
-        if (!m_tracker.Passed())
-            return true;
-
-        const uint32 interval = m_tracker.GetInterval();
-        const uint32 overflow = (m_tracker.GetCurrent() - interval);
-
-        m_tracker.SetCurrent(interval);
-
-        if (overflow == diff)   // Pulse: subsequent ticks after instant tick on expiration
-        {
-            m_pulse.Update(overflow);
-
-            if (!m_pulse.Passed())
-                return true;
-
-            m_pulse.Reset();
-        }
-
-        return false;
-    }
-    else                // Timer regenerating
-    {
-        const uint32 current = m_tracker.GetCurrent();
-
-        if (current > diff)
-        {
-            m_tracker.SetCurrent(current - diff);
-            m_pulse.SetCurrent(0);
-        }
-        else
-            Stop();
-
-        return true;
-    }
-}
-
 //== PlayerTaxi ================================================
 
 PlayerTaxi::PlayerTaxi()
@@ -475,12 +338,12 @@ UpdateMask Player::updateVisualBits;
 
 Player::Player(WorldSession* session): Unit(), m_taxiTracker(*this), m_mover(this), m_camera(this), m_reputationMgr(this)
 {
-    m_transport = nullptr;
-
-#ifdef BUILD_PLAYERBOT
+#ifdef ENABLE_PLAYERBOTS
     m_playerbotAI = 0;
     m_playerbotMgr = 0;
 #endif
+    m_transport = nullptr;
+
     m_speakTime = 0;
     m_speakCount = 0;
 
@@ -526,7 +389,7 @@ Player::Player(WorldSession* session): Unit(), m_taxiTracker(*this), m_mover(thi
 
     memset(m_items, 0, sizeof(Item*)*PLAYER_SLOTS_COUNT);
 
-    m_social = nullptr;
+    m_social = 0;
 
     // group is initialized in the reference constructor
     SetGroupInvite(nullptr);
@@ -563,6 +426,13 @@ Player::Player(WorldSession* session): Unit(), m_taxiTracker(*this), m_mover(thi
 
     m_lastLiquid = nullptr;
 
+    for (int& i : m_MirrorTimer)
+        i = DISABLED_MIRROR_TIMER;
+
+    m_MirrorTimerFlags = UNDERWATER_NONE;
+    m_MirrorTimerFlagsLast = UNDERWATER_NONE;
+
+    m_isInWater = false;
     m_drunkTimer = 0;
     m_drunk = 0;
     m_restTime = 0;
@@ -679,23 +549,23 @@ Player::~Player()
     for (auto& x : ItemSetEff)
         delete x;
 
-    // clean up player-instance binds, may unload some instance saves
-    for (auto& m_boundInstance : m_boundInstances)
-        for (BoundInstancesMap::iterator itr = m_boundInstance.begin(); itr != m_boundInstance.end(); ++itr)
-            itr->second.state->RemovePlayer(this);
-
-#ifdef BUILD_PLAYERBOT
+#ifdef ENABLE_PLAYERBOTS
     if (m_playerbotAI)
     {
         delete m_playerbotAI;
         m_playerbotAI = 0;
     }
-    if (m_playerbotMgr)
-    {
+    if (m_playerbotMgr) {
         delete m_playerbotMgr;
         m_playerbotMgr = 0;
     }
 #endif
+
+    // clean up player-instance binds, may unload some instance saves
+    for (auto& m_boundInstance : m_boundInstances)
+        for (BoundInstancesMap::iterator itr = m_boundInstance.begin(); itr != m_boundInstance.end(); ++itr)
+            itr->second.state->RemovePlayer(this);
+
     delete m_declinedname;
 }
 
@@ -977,6 +847,32 @@ Item* Player::StoreNewItemInInventorySlot(uint32 itemEntry, uint32 amount)
     return nullptr;
 }
 
+void Player::SendMirrorTimer(MirrorTimerType Type, uint32 MaxValue, uint32 CurrentValue, int32 Regen)
+{
+    if (int(MaxValue) == DISABLED_MIRROR_TIMER)
+    {
+        if (int(CurrentValue) != DISABLED_MIRROR_TIMER)
+            StopMirrorTimer(Type);
+        return;
+    }
+    WorldPacket data(SMSG_START_MIRROR_TIMER, (21));
+    data << (uint32)Type;
+    data << CurrentValue;
+    data << MaxValue;
+    data << Regen;
+    data << (uint8)0;
+    data << (uint32)0;                                      // spell id
+    GetSession()->SendPacket(data);
+}
+
+void Player::StopMirrorTimer(MirrorTimerType Type)
+{
+    m_MirrorTimer[Type] = DISABLED_MIRROR_TIMER;
+    WorldPacket data(SMSG_STOP_MIRROR_TIMER, 4);
+    data << (uint32)Type;
+    GetSession()->SendPacket(data);
+}
+
 uint32 Player::EnvironmentalDamage(EnviromentalDamage type, uint32 damage)
 {
     if (!isAlive() || isGameMaster())
@@ -984,7 +880,7 @@ uint32 Player::EnvironmentalDamage(EnviromentalDamage type, uint32 damage)
 
     // Absorb, resist some environmental damage type
     uint32 absorb = 0;
-    int32 resist = 0;
+    uint32 resist = 0;
     if (type == DAMAGE_LAVA)
     {
         // TODO: Find out if we should sent packet
@@ -996,10 +892,7 @@ uint32 Player::EnvironmentalDamage(EnviromentalDamage type, uint32 damage)
     else if (type == DAMAGE_SLIME)
         CalculateDamageAbsorbAndResist(this, SPELL_SCHOOL_MASK_NATURE, DIRECT_DAMAGE, damage, &absorb, &resist);
 
-    const uint32 bonus = (resist < 0 ? uint32(std::abs(resist)) : 0);
-    damage += bonus;
-    const uint32 malus = (resist > 0 ? (absorb + uint32(resist)) : absorb);
-    damage = (damage <= malus ? 0 : (damage - malus));
+    damage -= absorb + resist;
 
     DamageEffectType damageType = SELF_DAMAGE;
     if (type == DAMAGE_FALL && getClass() == CLASS_ROGUE)
@@ -1007,7 +900,7 @@ uint32 Player::EnvironmentalDamage(EnviromentalDamage type, uint32 damage)
 
     DealDamageMods(this, damage, &absorb, damageType);
 
-    SendEnvironmentalDamageLog(type, damage, absorb, resist);
+    SendEnvironmentalDamageLog(type, damage, absorb, int32(resist));
 
     uint32 final_damage = DealDamage(this, damage, nullptr, damageType, SPELL_SCHOOL_MASK_NORMAL, nullptr, false);
 
@@ -1023,6 +916,159 @@ uint32 Player::EnvironmentalDamage(EnviromentalDamage type, uint32 damage)
     return final_damage;
 }
 
+int32 Player::getMaxTimer(MirrorTimerType timer) const
+{
+    switch (timer)
+    {
+        case FATIGUE_TIMER:
+            if (GetSession()->GetSecurity() >= (AccountTypes)sWorld.getConfig(CONFIG_UINT32_TIMERBAR_FATIGUE_GMLEVEL))
+                return DISABLED_MIRROR_TIMER;
+            return sWorld.getConfig(CONFIG_UINT32_TIMERBAR_FATIGUE_MAX) * IN_MILLISECONDS;
+        case BREATH_TIMER:
+        {
+            if (!isAlive() || HasAuraType(SPELL_AURA_WATER_BREATHING) ||
+                    GetSession()->GetSecurity() >= (AccountTypes)sWorld.getConfig(CONFIG_UINT32_TIMERBAR_BREATH_GMLEVEL))
+                return DISABLED_MIRROR_TIMER;
+            int32 UnderWaterTime = sWorld.getConfig(CONFIG_UINT32_TIMERBAR_BREATH_MAX) * IN_MILLISECONDS;
+            AuraList const& mModWaterBreathing = GetAurasByType(SPELL_AURA_MOD_WATER_BREATHING);
+            for (auto i : mModWaterBreathing)
+                UnderWaterTime = uint32(UnderWaterTime * (100.0f + i->GetModifier()->m_amount) / 100.0f);
+            return UnderWaterTime;
+        }
+        case FIRE_TIMER:
+        {
+            if (!isAlive() || GetSession()->GetSecurity() >= (AccountTypes)sWorld.getConfig(CONFIG_UINT32_TIMERBAR_FIRE_GMLEVEL))
+                return DISABLED_MIRROR_TIMER;
+            return sWorld.getConfig(CONFIG_UINT32_TIMERBAR_FIRE_MAX) * IN_MILLISECONDS;
+        }
+        default:
+            return 0;
+    }
+}
+
+void Player::UpdateMirrorTimers()
+{
+    // Desync flags for update on next HandleDrowning
+    if (m_MirrorTimerFlags)
+        m_MirrorTimerFlagsLast = ~m_MirrorTimerFlags;
+}
+
+void Player::HandleDrowning(uint32 time_diff)
+{
+    if (!m_MirrorTimerFlags)
+        return;
+
+    // In water
+    if (m_MirrorTimerFlags & UNDERWATER_INWATER)
+    {
+        // Breath timer not activated - activate it
+        if (m_MirrorTimer[BREATH_TIMER] == DISABLED_MIRROR_TIMER)
+        {
+            m_MirrorTimer[BREATH_TIMER] = getMaxTimer(BREATH_TIMER);
+            SendMirrorTimer(BREATH_TIMER, m_MirrorTimer[BREATH_TIMER], m_MirrorTimer[BREATH_TIMER], -1);
+        }
+        else
+        {
+            m_MirrorTimer[BREATH_TIMER] -= time_diff;
+            // Timer limit - need deal damage
+            if (m_MirrorTimer[BREATH_TIMER] < 0)
+            {
+                m_MirrorTimer[BREATH_TIMER] += 2 * IN_MILLISECONDS;
+                // Calculate and deal damage
+                // TODO: Check this formula
+                uint32 damage = GetMaxHealth() / 5 + urand(0, getLevel() - 1);
+                EnvironmentalDamage(DAMAGE_DROWNING, damage);
+            }
+            else if (!(m_MirrorTimerFlagsLast & UNDERWATER_INWATER))      // Update time in client if need
+                SendMirrorTimer(BREATH_TIMER, getMaxTimer(BREATH_TIMER), m_MirrorTimer[BREATH_TIMER], -1);
+        }
+    }
+    else if (m_MirrorTimer[BREATH_TIMER] != DISABLED_MIRROR_TIMER)        // Regen timer
+    {
+        int32 UnderWaterTime = getMaxTimer(BREATH_TIMER);
+        // Need breath regen
+        m_MirrorTimer[BREATH_TIMER] += 10 * time_diff;
+        if (m_MirrorTimer[BREATH_TIMER] >= UnderWaterTime || !isAlive())
+            StopMirrorTimer(BREATH_TIMER);
+        else if (m_MirrorTimerFlagsLast & UNDERWATER_INWATER)
+            SendMirrorTimer(BREATH_TIMER, UnderWaterTime, m_MirrorTimer[BREATH_TIMER], 10);
+    }
+
+    // In dark water
+    if (m_MirrorTimerFlags & UNDERWATER_INDARKWATER)
+    {
+        // Fatigue timer not activated - activate it
+        if (m_MirrorTimer[FATIGUE_TIMER] == DISABLED_MIRROR_TIMER)
+        {
+            m_MirrorTimer[FATIGUE_TIMER] = getMaxTimer(FATIGUE_TIMER);
+            SendMirrorTimer(FATIGUE_TIMER, m_MirrorTimer[FATIGUE_TIMER], m_MirrorTimer[FATIGUE_TIMER], -1);
+        }
+        else
+        {
+            m_MirrorTimer[FATIGUE_TIMER] -= time_diff;
+            // Timer limit - need deal damage or teleport ghost to graveyard
+            if (m_MirrorTimer[FATIGUE_TIMER] < 0)
+            {
+                m_MirrorTimer[FATIGUE_TIMER] += 2 * IN_MILLISECONDS;
+                if (isAlive())                              // Calculate and deal damage
+                {
+                    uint32 damage = GetMaxHealth() / 5 + urand(0, getLevel() - 1);
+                    EnvironmentalDamage(DAMAGE_EXHAUSTED, damage);
+                }
+                else if (HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))       // Teleport ghost to graveyard
+                    RepopAtGraveyard();
+            }
+            else if (!(m_MirrorTimerFlagsLast & UNDERWATER_INDARKWATER))
+                SendMirrorTimer(FATIGUE_TIMER, getMaxTimer(FATIGUE_TIMER), m_MirrorTimer[FATIGUE_TIMER], -1);
+        }
+    }
+    else if (m_MirrorTimer[FATIGUE_TIMER] != DISABLED_MIRROR_TIMER)       // Regen timer
+    {
+        int32 DarkWaterTime = getMaxTimer(FATIGUE_TIMER);
+        m_MirrorTimer[FATIGUE_TIMER] += 10 * time_diff;
+        if (m_MirrorTimer[FATIGUE_TIMER] >= DarkWaterTime || !isAlive())
+            StopMirrorTimer(FATIGUE_TIMER);
+        else if (m_MirrorTimerFlagsLast & UNDERWATER_INDARKWATER)
+            SendMirrorTimer(FATIGUE_TIMER, DarkWaterTime, m_MirrorTimer[FATIGUE_TIMER], 10);
+    }
+
+    if (m_MirrorTimerFlags & (UNDERWATER_INLAVA /*| UNDERWATER_INSLIME*/) && !(m_lastLiquid && m_lastLiquid->SpellId))
+    {
+        // Breath timer not activated - activate it
+        if (m_MirrorTimer[FIRE_TIMER] == DISABLED_MIRROR_TIMER)
+            m_MirrorTimer[FIRE_TIMER] = getMaxTimer(FIRE_TIMER);
+        else
+        {
+            m_MirrorTimer[FIRE_TIMER] -= time_diff;
+            if (m_MirrorTimer[FIRE_TIMER] < 0)
+            {
+                m_MirrorTimer[FIRE_TIMER] += 2 * IN_MILLISECONDS;
+                // Calculate and deal damage
+                // TODO: Check this formula
+                uint32 damage = urand(600, 700);
+                if (m_MirrorTimerFlags & UNDERWATER_INLAVA)
+                    EnvironmentalDamage(DAMAGE_LAVA, damage);
+                // need to skip Slime damage in Undercity,
+                // maybe someone can find better way to handle environmental damage
+                //else if (m_zoneUpdateId != 1497)
+                //    EnvironmentalDamage(DAMAGE_SLIME, damage);
+            }
+        }
+    }
+    else
+        m_MirrorTimer[FIRE_TIMER] = DISABLED_MIRROR_TIMER;
+
+    // Recheck timers flag
+    m_MirrorTimerFlags &= ~UNDERWATER_EXIST_TIMERS;
+    for (int i : m_MirrorTimer)
+        if (i != DISABLED_MIRROR_TIMER)
+        {
+            m_MirrorTimerFlags |= UNDERWATER_EXIST_TIMERS;
+            break;
+        }
+    m_MirrorTimerFlagsLast = m_MirrorTimerFlags;
+}
+
 /// The player sobers by 256 every 10 seconds
 void Player::HandleSobering()
 {
@@ -1069,279 +1115,6 @@ void Player::SetDrunkValue(uint16 newDrunkenValue, uint32 itemId)
     SendMessageToSet(data, true);
 }
 
-uint32 Player::GetWaterBreathingInterval() const
-{
-    return uint32(sWorld.getConfig(CONFIG_UINT32_MIRRORTIMER_BREATH_MAX) * IN_MILLISECONDS * m_environmentBreathingMultiplier);
-}
-
-void Player::SetWaterBreathingIntervalMultiplier(float multiplier)
-{
-    m_environmentBreathingMultiplier = multiplier;
-
-    if (const uint32 interval = GetWaterBreathingInterval())
-    {
-        m_mirrorTimers[MirrorTimer::BREATH].SetDuration(interval);
-        m_mirrorTimers[MirrorTimer::BREATH].SetScale(IsUnderwater() ? -1 : 10);
-    }
-    else
-        m_mirrorTimers[MirrorTimer::BREATH].SetScale(10);
-}
-
-void Player::SetEnvironmentFlags(EnvironmentFlags flags, bool apply)
-{
-    if (bool(m_environmentFlags & flags) == apply)
-        return;
-
-    if (apply)
-        m_environmentFlags |= flags;
-    else
-        m_environmentFlags &= ~flags;
-
-    // On liquid in/out change
-    if (flags & ENVIRONMENT_MASK_IN_LIQUID)
-    {
-        // remove auras that need water/land
-        RemoveAurasWithInterruptFlags(apply ? AURA_INTERRUPT_FLAG_NOT_ABOVEWATER : AURA_INTERRUPT_FLAG_NOT_UNDERWATER);
-
-        // move player's guid into HateOfflineList of those mobs
-        // which can't swim and move guid back into ThreatList when
-        // on surface.
-        // TODO: exist also swimming mobs, and function must be symmetric to enter/leave water
-        getHostileRefManager().updateThreatTables();
-    }
-
-    // On moving in/out high sea area: affect fatigue timer
-    if (flags & ENVIRONMENT_FLAG_HIGH_SEA)
-        m_mirrorTimers[MirrorTimer::FATIGUE].SetScale(apply ? -1 : 10);
-
-    // On swimming down/up liquid surface level: affect breath timer
-    if (flags & ENVIRONMENT_FLAG_UNDERWATER)
-        m_mirrorTimers[MirrorTimer::BREATH].SetScale((apply && GetWaterBreathingInterval()) ? -1 : 10);
-
-    // On moving in/out hazardous liquids: affect environmental timer
-    if ((flags & ENVIRONMENT_MASK_LIQUID_HAZARD))
-        m_mirrorTimers[MirrorTimer::ENVIRONMENTAL].SetScale((m_environmentFlags & ENVIRONMENT_MASK_LIQUID_HAZARD) ? -1 : 10);
-}
-
-void Player::SendMirrorTimerStart(uint32 type, uint32 remaining, uint32 duration, int32 scale, bool paused/* = false*/, uint32 spellId/* = 0*/)
-{
-    WorldPacket data(SMSG_START_MIRROR_TIMER, (4 + 4 + 4 + 4 + 1 + 4));
-    data << uint32(type);
-    data << uint32(remaining);
-    data << uint32(duration);
-    data << int32(scale);
-    data << uint8(paused);
-    data << uint32(spellId);
-    GetSession()->SendPacket(data);
-}
-
-void Player::SendMirrorTimerStop(uint32 type)
-{
-    WorldPacket data(SMSG_STOP_MIRROR_TIMER, 4);
-    data << uint32(type);
-    GetSession()->SendPacket(data);
-}
-
-void Player::SendMirrorTimerPause(uint32 type, bool state)
-{
-    // Note: Default UI handler for this is bugged, args dont match
-    // Gotta do a full update with SMSG_START_MIRROR_TIMER to avoid lua errors
-    WorldPacket data(SMSG_PAUSE_MIRROR_TIMER, (4 + 1));
-    data << uint32(type);
-    data << uint8(state);
-    GetSession()->SendPacket(data);
-}
-
-void Player::FreezeMirrorTimers(bool state)
-{
-    for (auto& timer : m_mirrorTimers)
-    {
-        if (!timer.GetSpellId())
-            timer.SetFrozen(state);
-    }
-}
-
-void Player::SendMirrorTimers(bool forced/*= false*/)
-{
-    for (auto& timer : m_mirrorTimers)
-    {
-        if (timer.GetType() >= MirrorTimer::NUM_CLIENT_TIMERS)
-            return;
-
-        MirrorTimer::Status status = timer.FetchStatus();
-
-        if (forced && timer.IsActive())
-            status = MirrorTimer::FULL_UPDATE;
-
-        switch (status)
-        {
-            case MirrorTimer::FULL_UPDATE:
-                SendMirrorTimerStart(timer.GetType(), timer.GetRemaining(), timer.GetDuration(), timer.GetScale(), timer.IsFrozen(), timer.GetSpellId());
-                break;
-            case MirrorTimer::STATUS_UPDATE:
-                if (!timer.IsActive())
-                    SendMirrorTimerStop(timer.GetType());
-                else
-                {
-                    // NOTE: Replaced with full resend due to clientside UI bug, details inside
-                    // SendMirrorTimerPause(timer.GetType(), timer.IsFrozen());
-                    SendMirrorTimerStart(timer.GetType(), timer.GetRemaining(), timer.GetDuration(), timer.GetScale(), timer.IsFrozen(), timer.GetSpellId());
-                }
-                break;
-            default:
-                break;
-        }
-    }
-}
-
-void Player::UpdateMirrorTimers(uint32 diff, bool send/* = true*/)
-{
-    for (auto& timer : m_mirrorTimers)
-    {
-        const MirrorTimer::Type type = timer.GetType();
-        const bool active = timer.IsActive();
-
-        if (active || CheckMirrorTimerActivation(type))
-        {
-            if (CheckMirrorTimerDeactivation(type))
-                 m_mirrorTimers[type].Stop();
-            else
-            {
-                if (active)
-                {
-                    if (timer.GetSpellId())
-                    {
-                        if (auto buff = GetMirrorTimerBuff(type))
-                            m_mirrorTimers[type].SetRemaining(uint32(std::abs(buff->GetAuraDuration())));
-                        else
-                            m_mirrorTimers[type].Stop();
-                    }
-
-                    if (!timer.Update(diff))
-                        OnMirrorTimerExpirationPulse(type);
-                }
-                else
-                {
-                    if (auto buff = GetMirrorTimerBuff(type))
-                        m_mirrorTimers[type].Start(uint32(std::abs(buff->GetAuraDuration())), uint32(std::abs(buff->GetAuraMaxDuration())), buff->GetId());
-                    else
-                        m_mirrorTimers[type].Start(GetMirrorTimerMaxDuration(type));
-                }
-            }
-        }
-    }
-
-    if (send)
-        SendMirrorTimers();
-}
-
-bool Player::CheckMirrorTimerActivation(MirrorTimer::Type timer) const
-{
-    switch (timer)
-    {
-        case MirrorTimer::FATIGUE:
-            return (IsInHighSea() && !IsTaxiFlying() && !GetTransport());
-        case MirrorTimer::BREATH:
-            return (IsUnderwater() && GetWaterBreathingInterval());
-        case MirrorTimer::FEIGNDEATH:
-            return (IsFeigningDeath());
-        case MirrorTimer::ENVIRONMENTAL:
-            return ((m_environmentFlags & ENVIRONMENT_MASK_LIQUID_HAZARD) && !(m_lastLiquid && m_lastLiquid->SpellId));
-        default:
-            return false;
-    }
-}
-
-bool Player::CheckMirrorTimerDeactivation(MirrorTimer::Type timer) const
-{
-    // Spirit of redemption: just drop all mirror timers at once
-    if (GetShapeshiftForm() == FORM_SPIRITOFREDEMPTION)
-        return true;
-
-    switch (timer)
-    {
-        case MirrorTimer::FATIGUE:
-            return (!(m_environmentFlags & ENVIRONMENT_FLAG_LIQUID) || (!isAlive() && !HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST)));
-        case MirrorTimer::BREATH:
-            return (!(m_environmentFlags & ENVIRONMENT_FLAG_LIQUID) || !isAlive());
-        case MirrorTimer::FEIGNDEATH:
-            return (!IsFeigningDeath());
-        case MirrorTimer::ENVIRONMENTAL:
-            return (!(m_environmentFlags & ENVIRONMENT_FLAG_LIQUID) || !isAlive());
-        default:
-            return false;
-    }
-}
-
-void Player::OnMirrorTimerExpirationPulse(MirrorTimer::Type timer)
-{
-    switch (timer)
-    {
-        case MirrorTimer::FATIGUE:
-            if (isAlive())                                      // Deal damage to living player
-                EnvironmentalDamage(DAMAGE_EXHAUSTED, ((GetMaxHealth() / 5) + urand(0, (getLevel() - 1))));
-            else if (HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST)) // Teleport ghost to graveyard
-                RepopAtGraveyard();
-            break;
-        case MirrorTimer::BREATH:
-            // TODO: Check this formula
-            EnvironmentalDamage(DAMAGE_DROWNING, ((GetMaxHealth() / 5) + urand(0, (getLevel() - 1))));
-            break;
-        case MirrorTimer::ENVIRONMENTAL:
-            // TODO: Check these formulas
-            if (IsInMagma())
-                EnvironmentalDamage(DAMAGE_LAVA, urand(600, 700));
-            // FIXME: Need to skip slime damage in Undercity, maybe someone can find better way to handle environmental damage
-            //if (IsInSlime() && m_zoneUpdateId != 1497)
-            //    EnvironmentalDamage(DAMAGE_SLIME, urand(600, 700));
-            break;
-        default:
-            return;
-    }
-}
-
-uint32 Player::GetMirrorTimerMaxDuration(MirrorTimer::Type timer) const
-{
-    switch (timer)
-    {
-        case MirrorTimer::FATIGUE:
-            return (sWorld.getConfig(CONFIG_UINT32_MIRRORTIMER_FATIGUE_MAX) * IN_MILLISECONDS);
-        case MirrorTimer::BREATH:
-            return GetWaterBreathingInterval();
-        case MirrorTimer::FEIGNDEATH:
-            return m_mirrorTimers[MirrorTimer::FEIGNDEATH].GetDuration();
-        case MirrorTimer::ENVIRONMENTAL:
-            return (sWorld.getConfig(CONFIG_UINT32_MIRRORTIMER_ENVIRONMENTAL_MAX) * IN_MILLISECONDS);
-        default:
-            return 0;
-    }
-}
-
-SpellAuraHolder const* Player::GetMirrorTimerBuff(MirrorTimer::Type timer) const
-{
-    switch (timer)
-    {
-        case MirrorTimer::FEIGNDEATH:
-        {
-            SpellAuraHolder const* buff = nullptr;
-            if (IsFeigningDeath())
-            {
-                for (auto aura : GetAurasByType(SPELL_AURA_FEIGN_DEATH))
-                {
-                    if (auto holder = aura->GetHolder())
-                    {
-                        if (!buff || holder->GetAuraMaxDuration() > buff->GetAuraMaxDuration())
-                            buff = holder;
-                    }
-                }
-            }
-            return buff;
-        }
-        default:
-            return nullptr;
-    }
-}
-
 void Player::Update(const uint32 diff)
 {
     if (!IsInWorld())
@@ -1374,8 +1147,6 @@ void Player::Update(const uint32 diff)
         }
     }
 
-    UpdateMirrorTimers(diff);
-
     // Used to implement delayed far teleports
     SetCanDelayTeleport(true);
     Unit::Update(diff);
@@ -1522,6 +1293,9 @@ void Player::Update(const uint32 diff)
             m_nextSave -= diff;
     }
 
+    // Handle Water/drowning
+    HandleDrowning(diff);
+
     // Handle detect stealth players
     if (m_DetectInvTimer > 0)
     {
@@ -1585,10 +1359,10 @@ void Player::Update(const uint32 diff)
     if (IsHasDelayedTeleport())
         TeleportTo(m_teleport_dest, m_teleport_options);
 
-#ifdef BUILD_PLAYERBOT
+#ifdef ENABLE_PLAYERBOTS
     if (m_playerbotAI)
         m_playerbotAI->UpdateAI(diff);
-    else if (m_playerbotMgr)
+    if (m_playerbotMgr)
         m_playerbotMgr->UpdateAI(diff);
 #endif
 }
@@ -1614,9 +1388,6 @@ void Player::SetDeathState(DeathState s)
         // FIXME: is pet dismissed at dying or releasing spirit? if second, add SetDeathState(DEAD) to HandleRepopRequestOpcode and define pet unsummon here with (s == DEAD)
         RemovePet(PET_SAVE_REAGENTS);
 
-        // Remove guardians (only players are supposed to have pets/guardians removed on death)
-        RemoveGuardians();
-
         // save value before aura remove in Unit::SetDeathState
         ressSpellId = GetUInt32Value(PLAYER_SELF_RES_SPELL);
 
@@ -1835,13 +1606,6 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
 
     MapEntry const* mEntry = sMapStore.LookupEntry(mapid);  // Validity checked in IsValidMapCoord
 
-#ifdef BUILD_PLAYERBOT
-    // If this user has bots, tell them to stop following master
-    // so they don't try to follow the master after the master teleports
-    if (GetPlayerbotMgr())
-        GetPlayerbotMgr()->Stay();
-#endif
-
     // don't let enter battlegrounds without assigned battleground id (for example through areatrigger)...
     // don't let gm level > 1 either
     if (!InBattleGround() && mEntry->IsBattleGroundOrArena())
@@ -2370,6 +2134,29 @@ GameObject* Player::GetGameObjectIfCanInteractWith(ObjectGuid guid, uint32 gameo
     return nullptr;
 }
 
+bool Player::IsUnderWater() const
+{
+    return GetTerrain()->IsUnderWater(GetPositionX(), GetPositionY(), GetPositionZ() + 2);
+}
+
+void Player::SetInWater(bool apply)
+{
+    if (m_isInWater == apply)
+        return;
+
+    // define player in water by opcodes
+    // move player's guid into HateOfflineList of those mobs
+    // which can't swim and move guid back into ThreatList when
+    // on surface.
+    // TODO: exist also swimming mobs, and function must be symmetric to enter/leave water
+    m_isInWater = apply;
+
+    // remove auras that need water/land
+    RemoveAurasWithInterruptFlags(apply ? AURA_INTERRUPT_FLAG_NOT_ABOVEWATER : AURA_INTERRUPT_FLAG_NOT_UNDERWATER);
+
+    getHostileRefManager().updateThreatTables();
+}
+
 struct SetGameMasterOnHelper
 {
     explicit SetGameMasterOnHelper() {}
@@ -2404,8 +2191,6 @@ void Player::SetGameMaster(bool on)
 
         CallForAllControlledUnits(SetGameMasterOnHelper(), CONTROLLED_PET | CONTROLLED_TOTEMS | CONTROLLED_GUARDIANS | CONTROLLED_CHARM);
 
-        FreezeMirrorTimers(true);
-
         SetPvPFreeForAll(false);
         UpdatePvPContested(false, true);
 
@@ -2422,8 +2207,6 @@ void Player::SetGameMaster(bool on)
 
         CallForAllControlledUnits(SetGameMasterOffHelper(getFaction()), CONTROLLED_PET | CONTROLLED_TOTEMS | CONTROLLED_GUARDIANS | CONTROLLED_CHARM);
 
-        FreezeMirrorTimers(false);
-
         // restore FFA PvP Server state
         if (sWorld.IsFFAPvPRealm())
             SetPvPFreeForAll(true);
@@ -2540,6 +2323,10 @@ void Player::GiveXP(uint32 xp, Creature* victim, float groupRate)
 
     uint32 level = getLevel();
 
+#ifdef ENABLE_IMMERSIVE
+    sImmersive.OnGiveXP(this, xp, victim);
+#endif
+
     // XP to money conversion processed in Player::RewardQuest
     if (level >= sWorld.getConfig(CONFIG_UINT32_MAX_PLAYER_LEVEL))
         return;
@@ -2583,6 +2370,9 @@ void Player::GiveLevel(uint32 level)
 
     PlayerLevelInfo info;
     sObjectMgr.GetPlayerLevelInfo(getRace(), plClass, level, &info);
+#ifdef ENABLE_IMMERSIVE
+    sImmersive.GetPlayerLevelInfo(this, &info);
+#endif
 
     PlayerClassLevelInfo classInfo;
     sObjectMgr.GetPlayerClassLevelInfo(plClass, level, &classInfo);
@@ -2692,6 +2482,9 @@ void Player::InitStatsForLevel(bool reapplyMods)
 
     PlayerLevelInfo info;
     sObjectMgr.GetPlayerLevelInfo(getRace(), plClass, level, &info);
+#ifdef ENABLE_IMMERSIVE
+    sImmersive.GetPlayerLevelInfo(this, &info);
+#endif
 
     SetUInt32Value(PLAYER_FIELD_MAX_LEVEL, sWorld.getConfig(CONFIG_UINT32_MAX_PLAYER_LEVEL));
     SetUInt32Value(PLAYER_NEXT_LEVEL_XP, sObjectMgr.GetXPForLevel(level));
@@ -4364,6 +4157,8 @@ void Player::BuildPlayerRepop()
     // to prevent cheating
     corpse->ResetGhostTime();
 
+    StopMirrorTimers();                                     // disable timers(bars)
+
     // set and clear other
     SetByteValue(UNIT_FIELD_BYTES_1, 3, UNIT_BYTE1_FLAG_ALWAYS_STAND);
 }
@@ -4447,6 +4242,8 @@ void Player::KillPlayer()
 {
     SetRoot(true);
 
+    StopMirrorTimers();                                     // disable timers(bars)
+
     SetDeathState(CORPSE);
     // SetFlag( UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_IN_PVP );
 
@@ -4797,6 +4594,10 @@ void Player::RepopAtGraveyard()
         if (updateVisibility && IsInWorld())
             UpdateVisibilityAndView();
     }
+
+#ifdef ENABLE_IMMERSIVE
+    sImmersive.OnDeath(this);
+#endif
 }
 
 void Player::JoinedChannel(Channel* c)
@@ -6162,7 +5963,7 @@ bool Player::SetPosition(float x, float y, float z, float orientation, bool tele
     m_positionStatusUpdateTimer = 100;
 
     // code block for underwater state update
-    UpdateTerainEnvironmentFlags(m, x, y, z);
+    UpdateUnderwaterState(m, x, y, z);
 
     // code block for outdoor state and area-explore check
     CheckAreaExploreAndOutdoor();
@@ -6382,31 +6183,23 @@ int32 Player::CalculateReputationGain(ReputationSource source, int32 rep, int32
 
     percent += rep > 0 ? repMod : -repMod;
 
-    float minRate;
+    float rate;
     switch (source)
     {
         case REPUTATION_SOURCE_KILL:
-            minRate = sWorld.getConfig(CONFIG_FLOAT_RATE_REPUTATION_LOWLEVEL_KILL);
+            rate = sWorld.getConfig(CONFIG_FLOAT_RATE_REPUTATION_LOWLEVEL_KILL);
             break;
         case REPUTATION_SOURCE_QUEST:
-            minRate = sWorld.getConfig(CONFIG_FLOAT_RATE_REPUTATION_LOWLEVEL_QUEST);
+            rate = sWorld.getConfig(CONFIG_FLOAT_RATE_REPUTATION_LOWLEVEL_QUEST);
             break;
+        case REPUTATION_SOURCE_SPELL:
         default:
-            minRate = 1.0f;
+            rate = 1.0f;
             break;
     }
 
-    uint32 currentLevel = getLevel();
-    if (creatureOrQuestLevel <= MaNGOS::XP::GetGrayLevel(currentLevel))
-        percent *= minRate;
-    else
-    {
-        // Pre-3.0.8: Declines with 20% for each level if 6 levels or more below the player down to a minimum (default: 20%)
-        const uint32 treshold = (creatureOrQuestLevel + 5);
-
-        if (currentLevel > treshold)
-            percent *= std::max(minRate, (1.0f - (0.2f * (currentLevel - treshold))));
-    }
+    if (rate != 1.0f && creatureOrQuestLevel <= MaNGOS::XP::GetGrayLevel(getLevel()))
+        percent *= rate;
 
     if (percent <= 0.0f)
         return 0;
@@ -12088,28 +11881,10 @@ void Player::PrepareGossipMenu(WorldObject* pSource, uint32 menuId)
                 case GOSSIP_OPTION_PETITIONER:
                 case GOSSIP_OPTION_TABARDDESIGNER:
                 case GOSSIP_OPTION_AUCTIONEER:
-                    break;                                  // no checks
-                case GOSSIP_OPTION_BOT:
-                {
-#ifdef BUILD_PLAYERBOT
-                    if (botConfig.GetBoolDefault("PlayerbotAI.DisableBots", false) && !pCreature->isInnkeeper())
-                    {
-                        ChatHandler(this).PSendSysMessage("|cffff0000Playerbot system is currently disabled!");
-                        hasMenuItem = false;
-                        break;
-                    }
-
-                    int32 cost = botConfig.GetIntDefault("PlayerbotAI.BotguyCost", 0);
-                    if (cost >= 0)
-                    {
-                        std::string reqQuestIds = botConfig.GetStringDefault("PlayerbotAI.BotguyQuests", "");
-                        if ((reqQuestIds == "" || requiredQuests(reqQuestIds.c_str())) && !pCreature->isInnkeeper() && this->GetMoney() >= (uint32)cost)
-                            pCreature->LoadBotMenu(this);
-                    }
+#ifdef ENABLE_IMMERSIVE
+                case GOSSIP_OPTION_IMMERSIVE:
 #endif
-                    hasMenuItem = false;
-                    break;
-                }
+                    break;                                  // no checks
                 default:
                     sLog.outErrorDb("Creature entry %u have unknown gossip option %u for menu %u", pCreature->GetEntry(), gossipMenu.option_id, gossipMenu.menu_id);
                     hasMenuItem = false;
@@ -12344,61 +12119,6 @@ void Player::OnGossipSelect(WorldObject* pSource, uint32 gossipListId, uint32 me
         case GOSSIP_OPTION_AUCTIONEER:
             GetSession()->SendAuctionHello(((Creature*)pSource));
             break;
-#ifdef BUILD_PLAYERBOT
-        case GOSSIP_OPTION_BOT:
-        {
-            // DEBUG_LOG("GOSSIP_OPTION_BOT");
-            PlayerTalkClass->CloseGossip();
-            uint32 guidlo = PlayerTalkClass->GossipOptionSender(gossipListId);
-            int32 cost = botConfig.GetIntDefault("PlayerbotAI.BotguyCost", 0);
-
-            if (!GetPlayerbotMgr())
-                SetPlayerbotMgr(new PlayerbotMgr(this));
-
-            if (GetPlayerbotMgr()->GetPlayerBot(ObjectGuid(HIGHGUID_PLAYER, guidlo)) != nullptr)
-            {
-                GetPlayerbotMgr()->LogoutPlayerBot(ObjectGuid(HIGHGUID_PLAYER, guidlo));
-            }
-            else if (GetPlayerbotMgr()->GetPlayerBot(ObjectGuid(HIGHGUID_PLAYER, guidlo)) == nullptr)
-            {
-                QueryResult* resultchar = CharacterDatabase.PQuery("SELECT COUNT(*) FROM characters WHERE online = '1' AND account = '%u'", m_session->GetAccountId());
-                if (resultchar)
-                {
-                    Field* fields = resultchar->Fetch();
-                    int maxnum = botConfig.GetIntDefault("PlayerbotAI.MaxNumBots", 9);
-                    int acctcharcount = fields[0].GetUInt32();
-                    if (!(m_session->GetSecurity() > SEC_PLAYER))
-                        if (acctcharcount > maxnum)
-                        {
-                            ChatHandler(this).PSendSysMessage("|cffff0000You cannot summon anymore bots.(Current Max: |cffffffff%u)", maxnum);
-                            delete resultchar;
-                            break;
-                        }
-                }
-                delete resultchar;
-
-                QueryResult* resultlvl = CharacterDatabase.PQuery("SELECT level,name FROM characters WHERE guid = '%u'", guidlo);
-                if (resultlvl)
-                {
-                    Field* fields = resultlvl->Fetch();
-                    int maxlvl = botConfig.GetIntDefault("PlayerbotAI.RestrictBotLevel", 80);
-                    int charlvl = fields[0].GetUInt32();
-                    if (!(m_session->GetSecurity() > SEC_PLAYER))
-                        if (charlvl > maxlvl)
-                        {
-                            ChatHandler(this).PSendSysMessage("|cffff0000You cannot summon |cffffffff[%s]|cffff0000, it's level is too high.(Current Max:lvl |cffffffff%u)", fields[1].GetString(), maxlvl);
-                            delete resultlvl;
-                            break;
-                        }
-                }
-                delete resultlvl;
-
-                GetPlayerbotMgr()->LoginPlayerBot(ObjectGuid(HIGHGUID_PLAYER, guidlo));
-                this->ModifyMoney(-(int32)cost);
-            }
-            return;
-        }
-#endif
         case GOSSIP_OPTION_SPIRITGUIDE:
             PrepareGossipMenu(pSource);
             SendPreparedGossip(pSource);
@@ -12416,6 +12136,12 @@ void Player::OnGossipSelect(WorldObject* pSource, uint32 gossipListId, uint32 me
             GetSession()->SendBattlegGroundList(guid, bgTypeId);
             break;
         }
+#ifdef ENABLE_IMMERSIVE
+        case GOSSIP_OPTION_IMMERSIVE:
+            sImmersive.OnGossipSelect(this, gossipListId, &menuData);
+            PlayerTalkClass->CloseGossip();
+            break;
+#endif
     }
 
     if (pMenuData && menuData.m_gAction_script)
@@ -13238,6 +12964,10 @@ void Player::RewardQuest(Quest const* pQuest, uint32 reward, Object* questGiver,
 
     // resend quests status directly
     SendQuestGiverStatusMultiple();
+
+#ifdef ENABLE_IMMERSIVE
+    sImmersive.OnRewardQuest(this, pQuest);
+#endif
 }
 
 void Player::FailQuestForGroup(uint32 questId)
@@ -17037,7 +16767,7 @@ void Player::_SaveStats()
         stmt.addFloat(GetStat(Stats(i)));
     // armor + school resistances
     for (int i = 0; i < MAX_SPELL_SCHOOL; ++i)
-        stmt.addInt32(GetResistance(SpellSchools(i)));
+        stmt.addUInt32(GetResistance(SpellSchools(i)));
     stmt.addFloat(GetFloatValue(PLAYER_BLOCK_PERCENTAGE));
     stmt.addFloat(GetFloatValue(PLAYER_DODGE_PERCENTAGE));
     stmt.addFloat(GetFloatValue(PLAYER_PARRY_PERCENTAGE));
@@ -17061,10 +16791,10 @@ void Player::outDebugStatsValues() const
     sLog.outDebug("AGILITY is: \t\t%f\t\tSTRENGTH is: \t\t%f", GetStat(STAT_AGILITY), GetStat(STAT_STRENGTH));
     sLog.outDebug("INTELLECT is: \t\t%f\t\tSPIRIT is: \t\t%f", GetStat(STAT_INTELLECT), GetStat(STAT_SPIRIT));
     sLog.outDebug("STAMINA is: \t\t%f", GetStat(STAT_STAMINA));
-    sLog.outDebug("Armor is: \t\t%i\t\tBlock is: \t\t%f", GetArmor(), GetFloatValue(PLAYER_BLOCK_PERCENTAGE));
-    sLog.outDebug("HolyRes is: \t\t%i\t\tFireRes is: \t\t%i", GetResistance(SPELL_SCHOOL_HOLY), GetResistance(SPELL_SCHOOL_FIRE));
-    sLog.outDebug("NatureRes is: \t\t%i\t\tFrostRes is: \t\t%i", GetResistance(SPELL_SCHOOL_NATURE), GetResistance(SPELL_SCHOOL_FROST));
-    sLog.outDebug("ShadowRes is: \t\t%i\t\tArcaneRes is: \t\t%i", GetResistance(SPELL_SCHOOL_SHADOW), GetResistance(SPELL_SCHOOL_ARCANE));
+    sLog.outDebug("Armor is: \t\t%u\t\tBlock is: \t\t%f", GetArmor(), GetFloatValue(PLAYER_BLOCK_PERCENTAGE));
+    sLog.outDebug("HolyRes is: \t\t%u\t\tFireRes is: \t\t%u", GetResistance(SPELL_SCHOOL_HOLY), GetResistance(SPELL_SCHOOL_FIRE));
+    sLog.outDebug("NatureRes is: \t\t%u\t\tFrostRes is: \t\t%u", GetResistance(SPELL_SCHOOL_NATURE), GetResistance(SPELL_SCHOOL_FROST));
+    sLog.outDebug("ShadowRes is: \t\t%u\t\tArcaneRes is: \t\t%u", GetResistance(SPELL_SCHOOL_SHADOW), GetResistance(SPELL_SCHOOL_ARCANE));
     sLog.outDebug("MIN_DAMAGE is: \t\t%f\tMAX_DAMAGE is: \t\t%f", GetFloatValue(UNIT_FIELD_MINDAMAGE), GetFloatValue(UNIT_FIELD_MAXDAMAGE));
     sLog.outDebug("MIN_OFFHAND_DAMAGE is: \t%f\tMAX_OFFHAND_DAMAGE is: \t%f", GetFloatValue(UNIT_FIELD_MINOFFHANDDAMAGE), GetFloatValue(UNIT_FIELD_MAXOFFHANDDAMAGE));
     sLog.outDebug("MIN_RANGED_DAMAGE is: \t%f\tMAX_RANGED_DAMAGE is: \t%f", GetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE), GetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE));
@@ -20394,22 +20124,19 @@ void Player::SetOriginalGroup(Group* group, int8 subgroup)
     }
 }
 
-void Player::UpdateTerainEnvironmentFlags(Map* m, float x, float y, float z)
+void Player::UpdateUnderwaterState(Map* m, float x, float y, float z)
 {
     GridMapLiquidData liquid_status;
     GridMapLiquidStatus res = m->GetTerrain()->getLiquidStatus(x, y, z, MAP_ALL_LIQUIDS, &liquid_status);
     if (!res)
     {
-        SetEnvironmentFlags(ENVIRONMENT_MASK_LIQUID_FLAGS, false);
+        m_MirrorTimerFlags &= ~(UNDERWATER_INWATER | UNDERWATER_INLAVA | UNDERWATER_INSLIME | UNDERWATER_INDARKWATER);
         if (m_lastLiquid && m_lastLiquid->SpellId)
             RemoveAurasDueToSpell(m_lastLiquid->SpellId == 37025 ? 37284 : m_lastLiquid->SpellId);
         m_lastLiquid = nullptr;
         return;
     }
 
-    // Environment has liquid information
-    SetEnvironmentFlags(ENVIRONMENT_FLAG_LIQUID, true);
-
     if (uint32 liqEntry = liquid_status.entry)
     {
         LiquidTypeEntry const* liquid = sLiquidTypeStore.LookupEntry(liqEntry);
@@ -20459,24 +20186,37 @@ void Player::UpdateTerainEnvironmentFlags(Map* m, float x, float y, float z)
         m_lastLiquid = nullptr;
     }
 
-    // All liquid types: check under surface level
+    // All liquids type - check under water position
     if (liquid_status.type_flags & (MAP_LIQUID_TYPE_WATER | MAP_LIQUID_TYPE_OCEAN | MAP_LIQUID_TYPE_MAGMA | MAP_LIQUID_TYPE_SLIME))
-        SetEnvironmentFlags(ENVIRONMENT_FLAG_UNDERWATER, (res & LIQUID_MAP_UNDER_WATER));
+    {
+        if (res & LIQUID_MAP_UNDER_WATER)
+            m_MirrorTimerFlags |= UNDERWATER_INWATER;
+        else
+            m_MirrorTimerFlags &= ~UNDERWATER_INWATER;
+    }
 
-    // In water: on or under surface level
-    if (liquid_status.type_flags & MAP_LIQUID_TYPE_WATER)
-        SetEnvironmentFlags(ENVIRONMENT_FLAG_IN_WATER, (res & (LIQUID_MAP_UNDER_WATER | LIQUID_MAP_IN_WATER)));
+    // Allow travel in dark water on taxi or transport
+    if ((liquid_status.type_flags & MAP_LIQUID_TYPE_DARK_WATER) && !IsTaxiFlying() && !GetTransport())
+        m_MirrorTimerFlags |= UNDERWATER_INDARKWATER;
+    else
+        m_MirrorTimerFlags &= ~UNDERWATER_INDARKWATER;
 
-    // In magma: on, under, or slightly above surface level
+    // in lava check, anywhere in lava level
     if (liquid_status.type_flags & MAP_LIQUID_TYPE_MAGMA)
-        SetEnvironmentFlags(ENVIRONMENT_FLAG_IN_MAGMA, (res & (LIQUID_MAP_UNDER_WATER | LIQUID_MAP_IN_WATER | LIQUID_MAP_WATER_WALK)));
-
-    // In slime: on, under, or slightly above surface level
+    {
+        if (res & (LIQUID_MAP_UNDER_WATER | LIQUID_MAP_IN_WATER | LIQUID_MAP_WATER_WALK))
+            m_MirrorTimerFlags |= UNDERWATER_INLAVA;
+        else
+            m_MirrorTimerFlags &= ~UNDERWATER_INLAVA;
+    }
+    // in slime check, anywhere in slime level
     if (liquid_status.type_flags & MAP_LIQUID_TYPE_SLIME)
-        SetEnvironmentFlags(ENVIRONMENT_FLAG_IN_SLIME, (res & (LIQUID_MAP_UNDER_WATER | LIQUID_MAP_IN_WATER | LIQUID_MAP_WATER_WALK)));
-
-    // In deep water: on, under, above surface level
-    SetEnvironmentFlags(ENVIRONMENT_FLAG_HIGH_SEA, (liquid_status.type_flags & MAP_LIQUID_TYPE_DEEP_WATER));
+    {
+        if (res & (LIQUID_MAP_UNDER_WATER | LIQUID_MAP_IN_WATER | LIQUID_MAP_WATER_WALK))
+            m_MirrorTimerFlags |= UNDERWATER_INSLIME;
+        else
+            m_MirrorTimerFlags &= ~UNDERWATER_INSLIME;
+    }
 }
 
 bool ItemPosCount::isContainedIn(ItemPosCountVec const& vec) const
@@ -20800,7 +20540,13 @@ void Player::HandleFall(MovementInfo const& movementInfo)
 
     // Players with low fall distance, Feather Fall or physical immunity (charges used) are ignored
     // 14.57 can be calculated by resolving damageperc formula below to 0
-    if (z_diff >= 14.57f && !isDead() && !isGameMaster() && !HasMovementFlag(MOVEFLAG_ONTRANSPORT) &&
+    if (
+#ifdef ENABLE_IMMERSIVE
+            z_diff >= 4.57f &&
+#else
+            z_diff >= 14.57f &&
+#endif
+            !isDead() && !isGameMaster() && !HasMovementFlag(MOVEFLAG_ONTRANSPORT) &&
             !HasAuraType(SPELL_AURA_HOVER) && !HasAuraType(SPELL_AURA_FEATHER_FALL) &&
             !IsFreeFlying() && !IsImmuneToDamage(SPELL_SCHOOL_MASK_NORMAL))
     {
@@ -20808,7 +20554,9 @@ void Player::HandleFall(MovementInfo const& movementInfo)
         int32 safe_fall = GetTotalAuraModifier(SPELL_AURA_SAFE_FALL);
 
         float damageperc = 0.018f * (z_diff - safe_fall) - 0.2426f;
-
+#ifdef ENABLE_IMMERSIVE
+        damageperc = sImmersive.GetFallDamage(z_diff - safe_fall);
+#endif
         if (damageperc > 0)
         {
             uint32 damage = (uint32)(damageperc * GetMaxHealth() * sWorld.getConfig(CONFIG_FLOAT_RATE_DAMAGE_FALL));
diff --git a/src/game/Entities/Player.h b/src/game/Entities/Player.h
index ecee3189a..69a9aa18c 100644
--- a/src/game/Entities/Player.h
+++ b/src/game/Entities/Player.h
@@ -58,13 +58,13 @@ class Spell;
 class Item;
 struct FactionTemplateEntry;
 
-#ifdef BUILD_PLAYERBOT
-#include "PlayerBot/Base/PlayerbotMgr.h"
-#include "PlayerBot/Base/PlayerbotAI.h"
-#endif
-
 struct AreaTrigger;
 
+#ifdef ENABLE_PLAYERBOTS
+class PlayerbotAI;
+class PlayerbotMgr;
+#endif
+
 typedef std::deque<Mail*> PlayerMails;
 
 #define PLAYER_MAX_SKILLS           127
@@ -81,19 +81,16 @@ enum SpellModType
     SPELLMOD_PCT                = 108                       // SPELL_AURA_ADD_PCT_MODIFIER
 };
 
-enum EnvironmentFlags
+// 2^n internal values, they are never sent to the client
+enum PlayerUnderwaterState
 {
-    ENVIRONMENT_FLAG_NONE           = 0x00,
-    ENVIRONMENT_FLAG_UNDERWATER     = 0x01,                     // Swimming submerged in any liquid
-    ENVIRONMENT_FLAG_IN_WATER       = 0x02,                     // Swimming in water
-    ENVIRONMENT_FLAG_IN_MAGMA       = 0x04,                     // Swimming in magma
-    ENVIRONMENT_FLAG_IN_SLIME       = 0x08,                     // Swimming in slime
-    ENVIRONMENT_FLAG_HIGH_SEA       = 0x10,                     // Anywhere inside deep water area
-    ENVIRONMENT_FLAG_LIQUID         = 0x20,                     // Anywhere near any liquid
+    UNDERWATER_NONE             = 0x00,
+    UNDERWATER_INWATER          = 0x01,                     // terrain type is water and player is afflicted by it
+    UNDERWATER_INLAVA           = 0x02,                     // terrain type is lava and player is afflicted by it
+    UNDERWATER_INSLIME          = 0x04,                     // terrain type is lava and player is afflicted by it
+    UNDERWATER_INDARKWATER      = 0x08,                     // terrain type is dark water and player is afflicted by it
 
-    ENVIRONMENT_MASK_LIQUID_HAZARD  = (ENVIRONMENT_FLAG_IN_MAGMA | ENVIRONMENT_FLAG_IN_SLIME),
-    ENVIRONMENT_MASK_IN_LIQUID      = (ENVIRONMENT_FLAG_IN_WATER | ENVIRONMENT_MASK_LIQUID_HAZARD),
-    ENVIRONMENT_MASK_LIQUID_FLAGS   = (ENVIRONMENT_FLAG_UNDERWATER | ENVIRONMENT_MASK_IN_LIQUID | ENVIRONMENT_FLAG_HIGH_SEA | ENVIRONMENT_FLAG_LIQUID),
+    UNDERWATER_EXIST_TIMERS     = 0x10
 };
 
 enum BuyBankSlotResult
@@ -451,70 +448,14 @@ enum PlayerFieldByte2Flags
     PLAYER_FIELD_BYTE2_INVISIBILITY_GLOW = 0x40
 };
 
-class MirrorTimer
+enum MirrorTimerType
 {
-    public:
-        enum Type
-        {
-            FATIGUE         = 0,
-            BREATH          = 1,
-            FEIGNDEATH      = 2,
-
-            NUM_CLIENT_TIMERS,
-
-            ENVIRONMENTAL   = NUM_CLIENT_TIMERS,
-
-            NUM_TIMERS
-        };
-
-        enum Status
-        {
-            UNCHANGED       = 0,
-            FULL_UPDATE     = 1,
-            STATUS_UPDATE   = 2,
-        };
-
-        MirrorTimer(Type type) : m_type(type), m_scale(-1), m_spellId(0), m_status(UNCHANGED), m_active(false), m_frozen(false) {}
-
-        inline bool     IsActive() const { return m_active; }
-        inline bool     IsRegenerating() const { return (m_scale > 0); }
-        inline bool     IsFrozen() const { return (m_frozen && !IsRegenerating()); }
-
-        inline Type     GetType() const { return m_type; }
-        inline uint32   GetRemaining() const { return (m_tracker.GetInterval() - m_tracker.GetCurrent()); }
-        inline uint32   GetDuration() const { return m_tracker.GetInterval(); }
-        inline int32    GetScale() const { return m_scale; }
-        inline uint32   GetSpellId() const { return m_spellId; }
-
-        inline Status   FetchStatus();
-
-        inline void Stop();
-
-        inline void Start(uint32 interval, uint32 spellId = 0);
-        inline void Start(uint32 current, uint32 max, uint32 spellId);
-
-        inline void SetRemaining(uint32 duration);
-        inline void SetDuration(uint32 duration);
-
-        inline void SetFrozen(bool state);
-
-        inline void SetScale(int32 scale);
-
-        bool Update(uint32 diff);
-
-    private:
-        Type m_type;
-        int32 m_scale;
-        uint32 m_spellId;
-
-        ShortIntervalTimer m_tracker;
-        ShortIntervalTimer m_pulse;
-
-        Status m_status;
-
-        bool m_active;
-        bool m_frozen;
+    FATIGUE_TIMER               = 0,
+    BREATH_TIMER                = 1,
+    FIRE_TIMER                  = 2
 };
+#define MAX_TIMERS              3
+#define DISABLED_MIRROR_TIMER   -1
 
 // 2^n values
 enum PlayerExtraFlags
@@ -976,6 +917,11 @@ class Player : public Unit
 
         static bool BuildEnumData(QueryResult* result,  WorldPacket& p_data);
 
+        void SetInWater(bool apply);
+
+        bool IsInWater() const override { return m_isInWater; }
+        bool IsUnderWater() const override;
+
         void SendInitialPacketsBeforeAddToMap();
         void SendInitialPacketsAfterAddToMap();
         void SendInstanceResetWarning(uint32 mapid, uint32 time);
@@ -1389,23 +1335,14 @@ class Player : public Unit
         void AddTimedQuest(uint32 quest_id) { m_timedquests.insert(quest_id); }
         void RemoveTimedQuest(uint32 quest_id) { m_timedquests.erase(quest_id); }
 
-#ifdef BUILD_PLAYERBOT
-        void chompAndTrim(std::string& str);
-        bool getNextQuestId(const std::string& pString, unsigned int& pStartPos, unsigned int& pId);
-        void skill(std::list<uint32>& m_spellsToLearn);
-        bool requiredQuests(const char* pQuestIdString);
-        PlayerMails::reverse_iterator GetMailRBegin() { return m_mail.rbegin();}
-        PlayerMails::reverse_iterator GetMailREnd() { return m_mail.rend();}
-        void UpdateMail();
-        uint32 GetSpec();
-#endif
-
         /*********************************************************/
         /***                   LOAD SYSTEM                     ***/
         /*********************************************************/
 
         bool LoadFromDB(ObjectGuid guid, SqlQueryHolder* holder);
-
+#ifdef ENABLE_PLAYERBOTS
+        bool MinimalLoadFromDB(QueryResult *result, uint32 guid);
+#endif
         static uint32 GetZoneIdFromDB(ObjectGuid guid);
         static uint32 GetLevelFromDB(ObjectGuid guid);
         static bool   LoadPositionFromDB(ObjectGuid guid, uint32& mapid, float& x, float& y, float& z, float& o, bool& in_flight);
@@ -1743,7 +1680,7 @@ class Player : public Unit
         void SendResetFailedNotify(uint32 mapid) const;
 
         bool SetPosition(float x, float y, float z, float orientation, bool teleport = false);
-        void UpdateTerainEnvironmentFlags(Map* m, float x, float y, float z);
+        void UpdateUnderwaterState(Map* m, float x, float y, float z);
 
         void SendMessageToSet(WorldPacket const& data, bool self) const override;// overwrite Object::SendMessageToSet
         void SendMessageToSetInRange(WorldPacket const& data, float dist, bool self) const override;
@@ -1767,6 +1704,14 @@ class Player : public Unit
         uint32 DurabilityRepairAll(bool cost, float discountMod, bool guildBank);
         uint32 DurabilityRepair(uint16 pos, bool cost, float discountMod, bool guildBank);
 
+        void UpdateMirrorTimers();
+        void StopMirrorTimers()
+        {
+            StopMirrorTimer(FATIGUE_TIMER);
+            StopMirrorTimer(BREATH_TIMER);
+            StopMirrorTimer(FIRE_TIMER);
+        }
+
         void SetLevitate(bool enable) override;
         void SetCanFly(bool enable) override;
         void SetFeatherFall(bool enable) override;
@@ -2040,17 +1985,6 @@ class Player : public Unit
         /***              ENVIROMENTAL SYSTEM                  ***/
         /*********************************************************/
 
-        bool IsUnderwater() const override { return (m_environmentFlags & ENVIRONMENT_FLAG_UNDERWATER); }
-        bool IsInWater() const override { return (m_environmentFlags & ENVIRONMENT_FLAG_IN_WATER); }
-        inline bool IsInMagma() const { return (m_environmentFlags & ENVIRONMENT_FLAG_IN_MAGMA); }
-        inline bool IsInSlime() const { return (m_environmentFlags & ENVIRONMENT_FLAG_IN_SLIME); }
-        inline bool IsInHighSea() const { return (m_environmentFlags & ENVIRONMENT_FLAG_HIGH_SEA); }
-
-        inline uint32 GetWaterBreathingInterval() const;
-        void SetWaterBreathingIntervalMultiplier(float multiplier);
-
-        void SendMirrorTimers(bool forced = false);
-
         uint32 EnvironmentalDamage(EnviromentalDamage type, uint32 damage);
 
         /*********************************************************/
@@ -2212,17 +2146,6 @@ class Player : public Unit
         void SetTitle(CharTitlesEntry const* title, bool lost = false);
         void SaveTitles(); // optimization for arena rewards
 
-#ifdef BUILD_PLAYERBOT
-        // A Player can either have a playerbotMgr (to manage its bots), or have playerbotAI (if it is a bot), or
-        // neither. Code that enables bots must create the playerbotMgr and set it using SetPlayerbotMgr.
-        void SetPlayerbotAI(PlayerbotAI* ai) { assert(!m_playerbotAI && !m_playerbotMgr); m_playerbotAI = ai; }
-        PlayerbotAI* GetPlayerbotAI() { return m_playerbotAI; }
-        void SetPlayerbotMgr(PlayerbotMgr* mgr) { assert(!m_playerbotAI && !m_playerbotMgr); m_playerbotMgr = mgr; }
-        PlayerbotMgr* GetPlayerbotMgr() { return m_playerbotMgr; }
-        void SetBotDeathTimer() { m_deathTimer = 0; }
-        bool IsInDuel() const { return duel && duel->startTime != 0; }
-#endif
-
         virtual UnitAI* AI() override { if (m_charmInfo) return m_charmInfo->GetAI(); return nullptr; }
         virtual CombatData* GetCombatData() override { if (m_charmInfo && m_charmInfo->GetCombatData()) return m_charmInfo->GetCombatData(); return m_combatData; }
 
@@ -2259,6 +2182,16 @@ class Player : public Unit
         }
 
         void UpdateEverything();
+#ifdef ENABLE_PLAYERBOTS
+        //EquipmentSets& GetEquipmentSets() { return m_EquipmentSets; }
+        void SetPlayerbotAI(PlayerbotAI* ai) { assert(!m_playerbotAI && !m_playerbotMgr); m_playerbotAI = ai; }
+        PlayerbotAI* GetPlayerbotAI() { return m_playerbotAI; }
+        void SetPlayerbotMgr(PlayerbotMgr* mgr) { assert(!m_playerbotAI && !m_playerbotMgr); m_playerbotMgr = mgr; }
+        PlayerbotMgr* GetPlayerbotMgr() { return m_playerbotMgr; }
+        void SetBotDeathTimer() { m_deathTimer = 0; }
+        //PlayerTalentMap& GetTalentMap(uint8 spec) { return m_talents[spec]; }
+#endif
+
     protected:
         /*********************************************************/
         /***               BATTLEGROUND SYSTEM                 ***/
@@ -2339,23 +2272,10 @@ class Player : public Unit
         /***              ENVIRONMENTAL SYSTEM                 ***/
         /*********************************************************/
         void HandleSobering();
-
-        void SetEnvironmentFlags(EnvironmentFlags flags, bool apply);
-
-        void SendMirrorTimerStart(uint32 type, uint32 remaining, uint32 duration, int32 scale, bool paused = false, uint32 spellId = 0);
-        void SendMirrorTimerStop(uint32 type);
-        void SendMirrorTimerPause(uint32 type, bool state);
-
-        void FreezeMirrorTimers(bool state);
-        void UpdateMirrorTimers(uint32 diff, bool send = true);
-
-        inline bool CheckMirrorTimerActivation(MirrorTimer::Type timer) const;
-        inline bool CheckMirrorTimerDeactivation(MirrorTimer::Type timer) const;
-
-        inline void OnMirrorTimerExpirationPulse(MirrorTimer::Type timer);
-
-        inline uint32 GetMirrorTimerMaxDuration(MirrorTimer::Type timer) const;
-        inline SpellAuraHolder const* GetMirrorTimerBuff(MirrorTimer::Type timer) const;
+        void SendMirrorTimer(MirrorTimerType Type, uint32 MaxValue, uint32 CurrentValue, int32 Regen);
+        void StopMirrorTimer(MirrorTimerType Type);
+        void HandleDrowning(uint32 time_diff);
+        int32 getMaxTimer(MirrorTimerType timer) const;
 
         /*********************************************************/
         /***                  HONOR SYSTEM                     ***/
@@ -2516,7 +2436,7 @@ class Player : public Unit
         GridReference<Player> m_gridRef;
         MapReference m_mapRef;
 
-#ifdef BUILD_PLAYERBOT
+#ifdef ENABLE_PLAYERBOTS
         PlayerbotAI* m_playerbotAI;
         PlayerbotMgr* m_playerbotMgr;
 #endif
@@ -2533,10 +2453,10 @@ class Player : public Unit
 
         LiquidTypeEntry const* m_lastLiquid;
 
-        uint8 m_environmentFlags = ENVIRONMENT_FLAG_NONE;
-        float m_environmentBreathingMultiplier = 1.0f;
-
-        MirrorTimer m_mirrorTimers[MirrorTimer::NUM_TIMERS] = { MirrorTimer::FATIGUE, MirrorTimer::BREATH, MirrorTimer::FEIGNDEATH, MirrorTimer::ENVIRONMENTAL };
+        int32 m_MirrorTimer[MAX_TIMERS];
+        uint8 m_MirrorTimerFlags;
+        uint8 m_MirrorTimerFlagsLast;
+        bool m_isInWater;
 
         // Current teleport data
         WorldLocation m_teleport_dest;
diff --git a/src/game/Entities/Unit.cpp b/src/game/Entities/Unit.cpp
index ab0b29b17..f4386e636 100644
--- a/src/game/Entities/Unit.cpp
+++ b/src/game/Entities/Unit.cpp
@@ -47,6 +47,10 @@
 #include "Movement/MoveSpline.h"
 #include "Entities/CreatureLinkingMgr.h"
 #include "Tools/Formulas.h"
+#ifdef ENABLE_PLAYERBOTS
+#include "playerbot.h"
+#include "GuildTaskMgr.h"
+#endif
 
 #include <math.h>
 #include <array>
@@ -1268,6 +1272,10 @@ void Unit::JustKilledCreature(Creature* victim, Player* responsiblePlayer)
         if (BattleGround* bg = responsiblePlayer->GetBattleGround())
             bg->HandleKillUnit(victim, responsiblePlayer);
 
+#ifdef ENABLE_PLAYERBOTS
+        sGuildTaskMgr.CheckKillTask(responsiblePlayer, victim);
+#endif
+
     // Notify the outdoor pvp script
     if (OutdoorPvP* outdoorPvP = sOutdoorPvPMgr.GetScript(responsiblePlayer ? responsiblePlayer->GetCachedZoneId() : GetZoneId()))
         outdoorPvP->HandleCreatureDeath(victim);
@@ -1917,23 +1925,8 @@ void Unit::CalculateMeleeDamage(Unit* pVictim, CalcDamageInfo* calcDamageInfo, W
             SubDamageInfo* subDamage = &calcDamageInfo->subDamage[i];
 
             calcDamageInfo->target->CalculateDamageAbsorbAndResist(this, subDamage->damageSchoolMask, DIRECT_DAMAGE, subDamage->damage, &subDamage->absorb, &subDamage->resist, true);
-
-            const uint32 bonus = (subDamage->resist < 0 ? uint32(std::abs(subDamage->resist)) : 0);
-            subDamage->damage += bonus;
-            calcDamageInfo->totalDamage += bonus;
-
-            const uint32 malus = (subDamage->resist > 0 ? (subDamage->absorb + uint32(subDamage->resist)) : subDamage->absorb);
-
-            if (subDamage->damage <= malus)
-            {
-                calcDamageInfo->totalDamage -= subDamage->damage;
-                subDamage->damage = 0;
-            }
-            else
-            {
-                calcDamageInfo->totalDamage -= malus;
-                subDamage->damage -= malus;
-            }
+            calcDamageInfo->totalDamage -= subDamage->absorb + subDamage->resist;
+            subDamage->damage -= subDamage->absorb + subDamage->resist;
 
             if (subDamage->absorb)
             {
@@ -2151,23 +2144,20 @@ uint32 Unit::CalcArmorReducedDamage(Unit* pVictim, const uint32 damage)
     return (newdamage > 1) ? newdamage : 1;
 }
 
-void Unit::CalculateDamageAbsorbAndResist(Unit* pCaster, SpellSchoolMask schoolMask, DamageEffectType damagetype, const uint32 damage, uint32* absorb, int32* resist, bool canReflect, bool canResist, bool binary)
+void Unit::CalculateDamageAbsorbAndResist(Unit* pCaster, SpellSchoolMask schoolMask, DamageEffectType damagetype, const uint32 damage, uint32* absorb, uint32* resist, bool canReflect, bool canResist, bool binary)
 {
     if (!pCaster || !isAlive() || !damage)
         return;
 
-    int32 RemainingDamage = int32(damage);
-
     // Magic damage, check for resists
     if (canResist && (schoolMask & SPELL_SCHOOL_MASK_MAGIC) && (!binary || damagetype == DOT))
-    {
-        const float multiplier = pCaster->RollMagicResistanceMultiplierOutcomeAgainst(this, schoolMask, damagetype, binary);
-        *resist = int32(int64(damage) * multiplier);
-        RemainingDamage -= *resist;
-    }
+        // We already rolled for possible full resist on hit, so we need to deal at least *some* amount of damage...
+        *resist = std::min((damage - 1), uint32(damage * pCaster->RollMagicPartialResistRatioAgainst(this, schoolMask, damagetype, binary)));
     else
         *resist = 0;
 
+    int32 RemainingDamage = damage - *resist;
+
     // Reflect damage spells (not cast any damage spell in aura lookup)
     uint32 reflectSpell = 0;
     int32  reflectDamage = 0;
@@ -2497,11 +2487,7 @@ void Unit::CalculateAbsorbResistBlock(Unit* pCaster, SpellNonMeleeDamage* damage
     }
 
     CalculateDamageAbsorbAndResist(pCaster, GetSpellSchoolMask(spellProto), SPELL_DIRECT_DAMAGE, damageInfo->damage, &damageInfo->absorb, &damageInfo->resist, IsReflectableSpell(spellProto), IsResistableSpell(spellProto), IsBinarySpell(*spellProto));
-
-    const uint32 bonus = (damageInfo->resist < 0 ? uint32(std::abs(damageInfo->resist)) : 0);
-    damageInfo->damage += bonus;
-    const uint32 malus = (damageInfo->resist > 0 ? (damageInfo->absorb + uint32(damageInfo->resist)) : damageInfo->absorb);
-    damageInfo->damage = (damageInfo->damage <= malus ? 0 : (damageInfo->damage - malus));
+    damageInfo->damage -= damageInfo->absorb + damageInfo->resist;
 }
 
 void Unit::AttackerStateUpdate(Unit* pVictim, WeaponAttackType attType, bool extra)
@@ -3765,14 +3751,11 @@ float Unit::CalculateEffectiveMissChance(const Unit* victim, WeaponAttackType at
     // For elemental melee auto-attacks: full resist outcome converted into miss chance (original research on combat logs)
     if (!ranged && !ability)
     {
-        const float percent = victim->CalculateEffectiveMagicResistancePercent(this, GetMeleeDamageSchoolMask((attType == BASE_ATTACK), true));
-        if (percent > 0)
+        const float resistance = victim->CalculateEffectiveMagicResistancePercent(this, GetMeleeDamageSchoolMask((attType == BASE_ATTACK), true));
+        if (const uint32 uindex = uint32(resistance * 100))
         {
-            if (const uint32 uindex = uint32(percent * 100))
-            {
-                const SpellPartialResistChanceEntry &chances = SPELL_PARTIAL_RESIST_DISTRIBUTION.at(uindex);
-                chance += float(chances.at(SPELL_PARTIAL_RESIST_PCT_100) / 100);
-            }
+            const SpellPartialResistChanceEntry &chances = SPELL_PARTIAL_RESIST_DISTRIBUTION.at(uindex);
+            chance += float(chances.at(SPELL_PARTIAL_RESIST_PCT_100) / 100);
         }
     }
     // Finally, take hit chance
@@ -3917,79 +3900,54 @@ float Unit::CalculateEffectiveMagicResistancePercent(const Unit* attacker, Spell
     uint32 schools = uint32(schoolMask & ~uint32(SPELL_SCHOOL_MASK_HOLY));
     // Select a resistance value matching given school mask, prefer mininal for multischool spells
     int32 resistance = 0;
-    for (uint32 school = 0; schools; (schools >>= 1), ++school)
+    for (uint32 school = 0; schools; ++school)
     {
         if (schools & 1)
         {
-            // Victim resistance
-            int32 amount = GetResistance(SpellSchools(school));
-
-            // Modify by penetration, but can't go negative with it since early stages of development
-            int32 penetration = attacker->GetResistancePenetration(SpellSchools(school));
-            amount = std::max((amount + penetration), ((amount > 0) ? 0 : amount));
-
+            // Base victim resistance
+            int32 amount = int32(GetResistance(SpellSchools(school)));
+            // Modify by penetration
+            amount -= attacker->GetResistancePenetration(SpellSchools(school));
+            // If unit has no resistance for this school: use it!
+            if (amount < 1)
+            {
+                resistance = 0; // Resistance can't be negative since early stages of development
+                break;
+            }
+            // Else if first school encountered or more vulnerable: memorize and continue
             if (!resistance || amount < resistance)
                 resistance = amount;
         }
+        schools >>= 1;
     }
-
-    float percent = 0;
-
-    if (resistance >= 0)    // Magic resistance calculation
-    {
-        // Attacker's level based skill, penalize when calculating for low levels (< 20):
-        const float skill = std::max(attacker->GetSkillMaxForLevel(this), uint16(100));
-        // Convert resistance value to resistance percentage through comparision with skill
-        percent += (float(resistance) / skill) * 100;
-        // Pre-3.0: multiplied by 0.75
-        percent *= 0.75f;
-        // Bonus resistance percent by positive level difference when calculating damage hit for NPCs only
-        if (!binary && GetTypeId() == TYPEID_UNIT && !HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED))
-            percent += (0.4f * std::max(int32(GetSkillMaxForLevel(attacker) - skill), 0));
-        // Magic resistance percentage cap (same as armor cap)
-        percent = std::min(percent, 75.0f);
-    }
-    else                    // Magic vulnerability calculation
-    {
-        // Victim's level based skill, penalize when calculating for low levels (< 20):
-        const float skill = std::max(GetSkillMaxForLevel(attacker), uint16(100));
-        // Convert resistance value to vulnerability percentage through comparision with skill
-        percent += (float(resistance) / skill) * 100;
-    }
-    return percent;
+    // Attacker's level based skill, penalize when calculating for low levels (< 20):
+    const uint32 skill = std::max(attacker->GetSkillMaxForLevel(this), uint16(100));
+    float percent = float(float(resistance) / float(skill)) * 100 * 0.75f;
+    // Bonus resistance by level difference when calculating damage hit for NPCs only
+    if (!binary && GetTypeId() == TYPEID_UNIT && !HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED))
+        percent += (0.4f * std::max(int32(GetSkillMaxForLevel(attacker) - skill), 0));
+    // Magic resistance percentage cap (same as armor cap)
+    return std::max(0.0f, std::min(percent, 75.0f));
 }
 
-float Unit::RollMagicResistanceMultiplierOutcomeAgainst(const Unit *victim, SpellSchoolMask schoolMask, DamageEffectType dmgType, bool binary) const
+float Unit::RollMagicPartialResistRatioAgainst(const Unit *victim, SpellSchoolMask schoolMask, DamageEffectType dmgType, bool binary) const
 {
-    float percentage = victim->CalculateEffectiveMagicResistancePercent(this, schoolMask);
-
-    // Magic vulnerability instead of magic resistance:
-    if (percentage < 0)
-        return (percentage * 0.01f);
-
-    const uint32 index = uint32(percentage * 100);
-
+    // Returns a ratio portion of resisted damage, range of returned values: 0.0f-1.0f
+    const float k = 1.0f; // TBC+: all damage sources have full distribution chance
+    const float percent = (victim->CalculateEffectiveMagicResistancePercent(this, schoolMask) * k);
+    const uint32 index = uint32(percent * 100);
     if (!index)
         return 0.0f;
-
     const SpellPartialResistChanceEntry &chances = SPELL_PARTIAL_RESIST_DISTRIBUTION.at(index);
     Die<SpellPartialResist, SPELL_PARTIAL_RESIST_NONE, NUM_SPELL_PARTIAL_RESISTS> die;
-
     for (uint8 outcome = SPELL_PARTIAL_RESIST_NONE; outcome < NUM_SPELL_PARTIAL_RESISTS; ++outcome)
         die.chance[outcome] = chances.at(outcome);
-
     const uint32 random = urand(1, 10000);
     // We must exclude full resist chance from it, we already rolled for it as miss type in attack table (so n-1)
     uint8 portion = std::min(uint8(die.roll(random)), uint8(NUM_SPELL_PARTIAL_RESISTS - 1));
-
-    // Pre-3.0: simulate old retail rouding error (full damage hit cut-off) for:
-    if (portion == SPELL_PARTIAL_RESIST_NONE && percentage > 54.0f)
-    {
-        // NPC non-binary spells, Environmental damage (e.g. lava), Elemental attacks
-        if (!binary && (dmgType == DIRECT_DAMAGE || !HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED)))
-            ++portion;
-    }
-
+    // Simulate old retail rouding error (full hit cut-off) for: NPC non-binary spells; environmental damage (e.g. lava); elemental attacks
+    if (portion == SPELL_PARTIAL_RESIST_NONE && !binary && percent > 54.0f && (dmgType == DIRECT_DAMAGE || !HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED)))
+        ++portion;
     // To get resisted part ratio, we exclude zero outcome (it is n-1 anyway, so we reuse local var)
     return (float(portion) / float(NUM_SPELL_PARTIAL_RESISTS));
 }
@@ -4007,14 +3965,11 @@ float Unit::CalculateSpellResistChance(const Unit* victim, SpellSchoolMask schoo
     {
         const bool binary = IsBinarySpell(*spell);
         const float percent = victim->CalculateEffectiveMagicResistancePercent(this, schoolMask, binary);
-        if (percent > 0)
-        {
-            if (binary)
-                chance += percent;
-            // Only non-binary spells used by players and pets can be fully resisted by magic resistance, NPC spells can be cut-off
-            else if (HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED))
-                chance += float(SPELL_PARTIAL_RESIST_DISTRIBUTION.at(uint32(percent * 100)).at(SPELL_PARTIAL_RESIST_PCT_100)) * 0.01f;
-        }
+        if (binary)
+            chance += percent;
+        // Only non-binary spells used by players and pets can be fully resisted by magic resistance, NPC spells can be cut-off
+        else if (HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED))
+            chance += float(SPELL_PARTIAL_RESIST_DISTRIBUTION.at(uint32(percent * 100)).at(SPELL_PARTIAL_RESIST_PCT_100)) * 0.01f;
     }
     // Chance to fully resist entire spell by it's dispel type
     if (const int32 type = int32(spell->Dispel))
@@ -4397,7 +4352,7 @@ bool Unit::IsInWater() const
     return GetTerrain()->IsInWater(GetPositionX(), GetPositionY(), GetPositionZ());
 }
 
-bool Unit::IsUnderwater() const
+bool Unit::IsUnderWater() const
 {
     return GetTerrain()->IsUnderWater(GetPositionX(), GetPositionY(), GetPositionZ());
 }
@@ -5759,12 +5714,10 @@ void Unit::SendSpellNonMeleeDamageLog(SpellNonMeleeDamage* log) const
     SendMessageToSet(data, true);
 }
 
-void Unit::SendSpellNonMeleeDamageLog(Unit* target, uint32 spellID, uint32 damage, SpellSchoolMask damageSchoolMask, uint32 absorbedDamage, int32 resist, bool isPeriodic, uint32 blocked, bool criticalHit, bool split)
+void Unit::SendSpellNonMeleeDamageLog(Unit* target, uint32 spellID, uint32 damage, SpellSchoolMask damageSchoolMask, uint32 absorbedDamage, uint32 resist, bool isPeriodic, uint32 blocked, bool criticalHit, bool split)
 {
     SpellNonMeleeDamage log(this, target, spellID, damageSchoolMask);
-    log.damage = damage;
-    log.damage += (resist < 0 ? uint32(std::abs(resist)) : 0);
-    log.damage -= (absorbedDamage + (resist > 0 ? uint32(resist) : 0) + blocked);
+    log.damage = damage - absorbedDamage - resist - blocked;
     log.absorb = absorbedDamage;
     log.resist = resist;
     log.periodicLog = isPeriodic;
@@ -5988,16 +5941,14 @@ void Unit::SendAttackStateUpdate(CalcDamageInfo* calcDamageInfo) const
     SendMessageToSet(data, true);
 }
 
-void Unit::SendAttackStateUpdate(uint32 HitInfo, Unit* target, SpellSchoolMask damageSchoolMask, uint32 Damage, uint32 AbsorbDamage, int32 Resist, VictimState TargetState, uint32 BlockedAmount)
+void Unit::SendAttackStateUpdate(uint32 HitInfo, Unit* target, SpellSchoolMask damageSchoolMask, uint32 Damage, uint32 AbsorbDamage, uint32 Resist, VictimState TargetState, uint32 BlockedAmount)
 {
     CalcDamageInfo dmgInfo;
     dmgInfo.HitInfo = HitInfo;
     dmgInfo.attacker = this;
     dmgInfo.target = target;
     dmgInfo.attackType = BASE_ATTACK;
-    dmgInfo.totalDamage = Damage;
-    dmgInfo.totalDamage += (Resist < 0 ? uint32(std::abs(Resist)) : 0);
-    dmgInfo.totalDamage -= (AbsorbDamage + (Resist > 0 ? uint32(Resist) : 0) + BlockedAmount);
+    dmgInfo.totalDamage = Damage - AbsorbDamage - Resist - BlockedAmount;
     dmgInfo.subDamage[0].damage = dmgInfo.totalDamage;
     dmgInfo.subDamage[0].damageSchoolMask = damageSchoolMask;
     dmgInfo.subDamage[0].absorb = AbsorbDamage;
@@ -8679,6 +8630,7 @@ void Unit::SetDeathState(DeathState s)
         RemoveAllAurasOnDeath();
         BreakCharmOutgoing();
         BreakCharmIncoming();
+        RemoveGuardians();
         RemoveMiniPet();
         UnsummonAllTotems();
 
diff --git a/src/game/Entities/Unit.h b/src/game/Entities/Unit.h
index ea9d575d1..44e54693b 100644
--- a/src/game/Entities/Unit.h
+++ b/src/game/Entities/Unit.h
@@ -867,7 +867,7 @@ struct SubDamageInfo
     SpellSchoolMask damageSchoolMask = SPELL_SCHOOL_MASK_NORMAL;
     uint32 damage = 0;
     uint32 absorb = 0;
-    int32 resist = 0;
+    uint32 resist = 0;
 };
 
 // Struct for use in Unit::CalculateMeleeDamage
@@ -904,7 +904,7 @@ struct SpellNonMeleeDamage
     uint32 damage;
     SpellSchoolMask schoolMask;
     uint32 absorb;
-    int32  resist;
+    uint32 resist;
     bool   periodicLog;
     bool   unused;
     uint32 blocked;
@@ -1460,12 +1460,11 @@ class Unit : public WorldObject
 
         float GetStat(Stats stat) const { return float(GetUInt32Value(UNIT_FIELD_STAT0 + stat)); }
         void SetStat(Stats stat, int32 val) { SetStatInt32Value(UNIT_FIELD_STAT0 + stat, val); }
+        uint32 GetArmor() const { return GetResistance(SPELL_SCHOOL_NORMAL) ; }
+        void SetArmor(int32 val) { SetResistance(SPELL_SCHOOL_NORMAL, val); }
 
-        inline int32 GetArmor() const { return GetResistance(SPELL_SCHOOL_NORMAL) ; }
-        inline void SetArmor(int32 val) { SetStatInt32Value(UNIT_FIELD_RESISTANCES, val); }
-
-        inline int32 GetResistance(SpellSchools school) const { return GetInt32Value(UNIT_FIELD_RESISTANCES + school); }
-        inline void SetResistance(SpellSchools school, int32 val) { SetInt32Value(UNIT_FIELD_RESISTANCES + school, val); }
+        uint32 GetResistance(SpellSchools school) const { return GetUInt32Value(UNIT_FIELD_RESISTANCES + school); }
+        void SetResistance(SpellSchools school, int32 val) { SetStatInt32Value(UNIT_FIELD_RESISTANCES + school, val); }
 
         uint32 GetHealth()    const { return GetUInt32Value(UNIT_FIELD_HEALTH); }
         uint32 GetMaxHealth() const { return GetUInt32Value(UNIT_FIELD_MAXHEALTH); }
@@ -1701,7 +1700,7 @@ class Unit : public WorldObject
         virtual int32 GetResistancePenetration(SpellSchools school) const;
 
         float CalculateEffectiveMagicResistancePercent(const Unit* attacker, SpellSchoolMask schoolMask, bool binary = false) const;
-        float RollMagicResistanceMultiplierOutcomeAgainst(const Unit* victim, SpellSchoolMask schoolMask, DamageEffectType dmgType, bool binary = false) const;
+        float RollMagicPartialResistRatioAgainst(const Unit* victim, SpellSchoolMask schoolMask, DamageEffectType dmgType, bool binary = false) const;
 
         float CalculateSpellResistChance(const Unit* victim, SpellSchoolMask schoolMask, const SpellEntry* spell) const;
 
@@ -1783,7 +1782,7 @@ class Unit : public WorldObject
         bool isFrozen() const;
 
         virtual bool IsInWater() const;
-        virtual bool IsUnderwater() const;
+        virtual bool IsUnderWater() const;
         bool isInAccessablePlaceFor(Unit const* unit) const;
 
         void EnergizeBySpell(Unit* pVictim, uint32 SpellID, uint32 Damage, Powers powertype);
@@ -1830,12 +1829,12 @@ class Unit : public WorldObject
         void SendAIReaction(AiReaction reactionType);
 
         void SendAttackStateUpdate(CalcDamageInfo* calcDamageInfo) const;
-        void SendAttackStateUpdate(uint32 HitInfo, Unit* target, SpellSchoolMask damageSchoolMask, uint32 Damage, uint32 AbsorbDamage, int32 Resist, VictimState TargetState, uint32 BlockedAmount);
+        void SendAttackStateUpdate(uint32 HitInfo, Unit* target, SpellSchoolMask damageSchoolMask, uint32 Damage, uint32 AbsorbDamage, uint32 Resist, VictimState TargetState, uint32 BlockedAmount);
         void SendEnergizeSpellLog(Unit* pVictim, uint32 SpellID, uint32 Damage, Powers powertype) const;
         void SendEnvironmentalDamageLog(uint8 type, uint32 damage, uint32 absorb, int32 resist) const;
         void SendHealSpellLog(Unit* pVictim, uint32 SpellID, uint32 Damage, bool critical = false);
         void SendSpellNonMeleeDamageLog(SpellNonMeleeDamage* log) const;
-        void SendSpellNonMeleeDamageLog(Unit* target, uint32 spellID, uint32 damage, SpellSchoolMask damageSchoolMask, uint32 absorbedDamage, int32 resist, bool isPeriodic, uint32 blocked, bool criticalHit = false, bool split = false);
+        void SendSpellNonMeleeDamageLog(Unit* target, uint32 spellID, uint32 damage, SpellSchoolMask damageSchoolMask, uint32 absorbedDamage, uint32 resist, bool isPeriodic, uint32 blocked, bool criticalHit = false, bool split = false);
         void SendPeriodicAuraLog(SpellPeriodicAuraLogInfo* pInfo) const;
         void SendSpellMiss(Unit* target, uint32 spellID, SpellMissInfo missInfo) const;
         void SendSpellOrDamageImmune(Unit* target, uint32 spellID) const;
@@ -2282,7 +2281,7 @@ class Unit : public WorldObject
         bool IsImmuneToSchool(SpellEntry const* spellInfo) const;
 
         uint32 CalcArmorReducedDamage(Unit* pVictim, const uint32 damage);
-        void CalculateDamageAbsorbAndResist(Unit* pCaster, SpellSchoolMask schoolMask, DamageEffectType damagetype, const uint32 damage, uint32* absorb, int32* resist, bool canReflect = false, bool canResist = true, bool binary = false);
+        void CalculateDamageAbsorbAndResist(Unit* pCaster, SpellSchoolMask schoolMask, DamageEffectType damagetype, const uint32 damage, uint32* absorb, uint32* resist, bool canReflect = false, bool canResist = true, bool binary = false);
         void CalculateAbsorbResistBlock(Unit* pCaster, SpellNonMeleeDamage* damageInfo, SpellEntry const* spellProto, WeaponAttackType attType = BASE_ATTACK);
 
         void  UpdateSpeed(UnitMoveType mtype, bool forced, float ratio = 1.0f);
diff --git a/src/game/Globals/SharedDefines.h b/src/game/Globals/SharedDefines.h
index 5bc130567..fdb71079e 100644
--- a/src/game/Globals/SharedDefines.h
+++ b/src/game/Globals/SharedDefines.h
@@ -2717,4 +2717,9 @@ enum LootType
     LOOT_DEBUG          = 100
 };
 
+#ifdef ENABLE_PLAYERBOTS || ENABLE_IMMERSIVE
+#define MANGOSBOT_ONE
+#define CMANGOS
+#endif
+
 #endif
diff --git a/src/game/Groups/Group.cpp b/src/game/Groups/Group.cpp
index dbfc87a8c..872e94882 100644
--- a/src/game/Groups/Group.cpp
+++ b/src/game/Groups/Group.cpp
@@ -30,9 +30,6 @@
 #include "Maps/MapManager.h"
 #include "Maps/MapPersistentStateMgr.h"
 #include "Spells/SpellAuras.h"
-#ifdef BUILD_PLAYERBOT
-#include "PlayerBot/Base/PlayerbotMgr.h"
-#endif
 
 GroupMemberStatus GetGroupMemberStatus(const Player* member = nullptr)
 {
@@ -328,11 +325,6 @@ bool Group::AddMember(ObjectGuid guid, const char* name)
 uint32 Group::RemoveMember(ObjectGuid guid, uint8 method)
 {
     Player* player = sObjectMgr.GetPlayer(guid);
-#ifdef BUILD_PLAYERBOT
-    // if master leaves group, all bots leave group
-    if (player && player->GetPlayerbotMgr())
-        player->GetPlayerbotMgr()->RemoveAllBotsFromGroup();
-#endif
 
     for (GroupReference* itr = GetFirstMember(); itr != nullptr; itr = itr->next())
     {
diff --git a/src/game/Groups/Group.h b/src/game/Groups/Group.h
index e5b5ec892..638af832d 100644
--- a/src/game/Groups/Group.h
+++ b/src/game/Groups/Group.h
@@ -273,6 +273,10 @@ class Group
         InstanceGroupBind* GetBoundInstance(Map* aMap, Difficulty difficulty);
         BoundInstancesMap& GetBoundInstances(Difficulty difficulty) { return m_boundInstances[difficulty]; }
 
+#ifdef ENABLE_PLAYERBOTS
+        ObjectGuid GetTargetIcon(int index) { return m_targetIcons[index]; }
+#endif
+
     protected:
         bool _addMember(ObjectGuid guid, const char* name, bool isAssistant = false);
         bool _addMember(ObjectGuid guid, const char* name, bool isAssistant, uint8 group);
diff --git a/src/game/Maps/GridMap.cpp b/src/game/Maps/GridMap.cpp
index 5db04620b..5b5366217 100644
--- a/src/game/Maps/GridMap.cpp
+++ b/src/game/Maps/GridMap.cpp
@@ -560,7 +560,7 @@ GridMapLiquidStatus GridMap::getLiquidStatus(float x, float y, float z, uint8 Re
     if (LiquidTypeEntry const* liquidEntry = sLiquidTypeStore.LookupEntry(entry))
     {
         entry = liquidEntry->Id;
-        type &= MAP_LIQUID_TYPE_DEEP_WATER;
+        type &= MAP_LIQUID_TYPE_DARK_WATER;
         uint32 liqTypeIdx = liquidEntry->Type;
         if (entry < 21)
         {
@@ -582,7 +582,7 @@ GridMapLiquidStatus GridMap::getLiquidStatus(float x, float y, float z, uint8 Re
             }
         }
 
-        type |= (1 << liqTypeIdx) | (type & MAP_LIQUID_TYPE_DEEP_WATER);
+        type |= (1 << liqTypeIdx) | (type & MAP_LIQUID_TYPE_DARK_WATER);
     }
 
     if (type == 0)
diff --git a/src/game/Maps/GridMapDefines.h b/src/game/Maps/GridMapDefines.h
index b680a4d33..61721e339 100644
--- a/src/game/Maps/GridMapDefines.h
+++ b/src/game/Maps/GridMapDefines.h
@@ -71,7 +71,7 @@ enum GridMapLiquidStatus
 
 #define MAP_ALL_LIQUIDS   (MAP_LIQUID_TYPE_WATER | MAP_LIQUID_TYPE_MAGMA | MAP_LIQUID_TYPE_OCEAN | MAP_LIQUID_TYPE_SLIME)
 
-#define MAP_LIQUID_TYPE_DEEP_WATER  0x10
+#define MAP_LIQUID_TYPE_DARK_WATER  0x10
 #define MAP_LIQUID_TYPE_WMO_WATER   0x20
 
 struct GridMapLiquidData
@@ -81,4 +81,4 @@ struct GridMapLiquidData
     float level;
     float depth_level;
 };
-#endif
+#endif
\ No newline at end of file
diff --git a/src/game/Maps/Map.cpp b/src/game/Maps/Map.cpp
index 3079e3b08..a03f7fd0e 100644
--- a/src/game/Maps/Map.cpp
+++ b/src/game/Maps/Map.cpp
@@ -745,7 +745,10 @@ void Map::Remove(Player* player, bool remove)
     SendRemoveTransports(player);
     UpdateObjectVisibility(player, cell, p);
 
-    player->ResetMap();
+#ifdef ENABLE_PLAYERBOTS
+    if (!player->GetPlayerbotAI())
+#endif
+        player->ResetMap();
     if (remove)
         DeleteFromWorld(player);
 }
diff --git a/src/game/MotionGenerators/MovementHandler.cpp b/src/game/MotionGenerators/MovementHandler.cpp
index 70e7d8423..8f5b6663c 100644
--- a/src/game/MotionGenerators/MovementHandler.cpp
+++ b/src/game/MotionGenerators/MovementHandler.cpp
@@ -553,6 +553,12 @@ void WorldSession::HandleMoverRelocation(MovementInfo& movementInfo)
             movementInfo.ClearTransportData();
         }
 
+        if (movementInfo.HasMovementFlag(MOVEFLAG_SWIMMING) != plMover->IsInWater())
+        {
+            // now client not include swimming flag in case jumping under water
+            plMover->SetInWater(!plMover->IsInWater() || plMover->GetTerrain()->IsUnderWater(movementInfo.GetPos()->x, movementInfo.GetPos()->y, movementInfo.GetPos()->z));
+        }
+
         plMover->SetPosition(movementInfo.GetPos()->x, movementInfo.GetPos()->y, movementInfo.GetPos()->z, movementInfo.GetPos()->o);
         plMover->m_movementInfo = movementInfo;
 
diff --git a/src/game/MotionGenerators/PathFinder.cpp b/src/game/MotionGenerators/PathFinder.cpp
index 7b7cb41c5..3055cbc17 100644
--- a/src/game/MotionGenerators/PathFinder.cpp
+++ b/src/game/MotionGenerators/PathFinder.cpp
@@ -599,7 +599,7 @@ void PathFinder::updateFilter()
 {
     // allow creatures to cheat and use different movement types if they are moved
     // forcefully into terrain they can't normally move in
-    if (m_sourceUnit->IsInWater() || m_sourceUnit->IsUnderwater())
+    if (m_sourceUnit->IsInWater() || m_sourceUnit->IsUnderWater())
     {
         uint16 includedFlags = m_filter.getIncludeFlags();
         includedFlags |= getNavTerrain(m_sourceUnit->GetPositionX(),
diff --git a/src/game/PlayerBot/AI/PlayerbotDruidAI.cpp b/src/game/PlayerBot/AI/PlayerbotDruidAI.cpp
deleted file mode 100644
index 364fa1d1c..000000000
--- a/src/game/PlayerBot/AI/PlayerbotDruidAI.cpp
+++ /dev/null
@@ -1,799 +0,0 @@
-/*
- * This file is part of the CMaNGOS Project. See AUTHORS file for Copyright information
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "PlayerbotDruidAI.h"
-
-class PlayerbotAI;
-
-PlayerbotDruidAI::PlayerbotDruidAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
-{
-    MOONFIRE                      = m_ai->initSpell(MOONFIRE_1); // attacks
-    STARFIRE                      = m_ai->initSpell(STARFIRE_1);
-    WRATH                         = m_ai->initSpell(WRATH_1);
-    ROOTS                         = m_ai->initSpell(ENTANGLING_ROOTS_1);
-    INSECT_SWARM                  = m_ai->initSpell(INSECT_SWARM_1);
-    FORCE_OF_NATURE               = m_ai->initSpell(FORCE_OF_NATURE_1);
-    HURRICANE                     = m_ai->initSpell(HURRICANE_1);
-    MARK_OF_THE_WILD              = m_ai->initSpell(MARK_OF_THE_WILD_1); // buffs
-    GIFT_OF_THE_WILD              = m_ai->initSpell(GIFT_OF_THE_WILD_1);
-    THORNS                        = m_ai->initSpell(THORNS_1);
-    BARKSKIN                      = m_ai->initSpell(BARKSKIN_1);
-    HIBERNATE                     = m_ai->initSpell(HIBERNATE_1);
-    INNERVATE                     = m_ai->initSpell(INNERVATE_1);
-    FAERIE_FIRE                   = m_ai->initSpell(FAERIE_FIRE_1); // debuffs
-    FAERIE_FIRE_FERAL             = m_ai->initSpell(FAERIE_FIRE_FERAL_1);
-    REJUVENATION                  = m_ai->initSpell(REJUVENATION_1); // heals
-    REGROWTH                      = m_ai->initSpell(REGROWTH_1);
-    LIFEBLOOM                     = m_ai->initSpell(LIFEBLOOM_1);
-    OMEN_OF_CLARITY               = m_ai->initSpell(OMEN_OF_CLARITY_1);
-    NATURES_SWIFTNESS             = m_ai->initSpell(NATURES_SWIFTNESS_DRUID_1);
-    HEALING_TOUCH                 = m_ai->initSpell(HEALING_TOUCH_1);
-    SWIFTMEND                     = m_ai->initSpell(SWIFTMEND_1);
-    TRANQUILITY                   = m_ai->initSpell(TRANQUILITY_1);
-    REBIRTH                       = m_ai->initSpell(REBIRTH_1);
-    REMOVE_CURSE                  = m_ai->initSpell(REMOVE_CURSE_DRUID_1);
-    CURE_POISON                   = m_ai->initSpell(CURE_POISON_1);
-    ABOLISH_POISON                = m_ai->initSpell(ABOLISH_POISON_1);
-    // Druid Forms
-    MOONKIN_FORM                  = m_ai->initSpell(MOONKIN_FORM_1);
-    DIRE_BEAR_FORM                = m_ai->initSpell(DIRE_BEAR_FORM_1);
-    BEAR_FORM                     = m_ai->initSpell(BEAR_FORM_1);
-    CAT_FORM                      = m_ai->initSpell(CAT_FORM_1);
-    TREE_OF_LIFE                  = m_ai->initSpell(TREE_OF_LIFE_1);
-    TRAVEL_FORM                   = m_ai->initSpell(TRAVEL_FORM_1);
-    // Cat Attack type's
-    RAKE                          = m_ai->initSpell(RAKE_1);
-    CLAW                          = m_ai->initSpell(CLAW_1); // 45
-    COWER                         = m_ai->initSpell(COWER_1); // 20
-    SHRED                         = m_ai->initSpell(SHRED_1);
-    MANGLE                        = m_ai->initSpell(MANGLE_1); // 45
-    TIGERS_FURY                   = m_ai->initSpell(TIGERS_FURY_1);
-    MANGLE_CAT                    = m_ai->initSpell(MANGLE_CAT_1); //40
-    // Cat Finishing Move's
-    RIP                           = m_ai->initSpell(RIP_1); // 30
-    FEROCIOUS_BITE                = m_ai->initSpell(FEROCIOUS_BITE_1); // 35
-    MAIM                          = m_ai->initSpell(MAIM_1); // 35
-    // Bear/Dire Bear Attacks & Buffs
-    BASH                          = m_ai->initSpell(BASH_1);
-    MAUL                          = m_ai->initSpell(MAUL_1); // 15
-    SWIPE                         = m_ai->initSpell(SWIPE_BEAR_1); // 20
-    DEMORALIZING_ROAR             = m_ai->initSpell(DEMORALIZING_ROAR_1); // 10
-    CHALLENGING_ROAR              = m_ai->initSpell(CHALLENGING_ROAR_1);
-    ENRAGE                        = m_ai->initSpell(ENRAGE_1);
-    GROWL                         = m_ai->initSpell(GROWL_1);
-    MANGLE_BEAR                   = m_ai->initSpell(MANGLE_BEAR_1);
-    LACERATE                      = m_ai->initSpell(LACERATE_1);
-
-    RECENTLY_BANDAGED             = 11196; // first aid check
-
-    // racial
-    SHADOWMELD                    = m_ai->initSpell(SHADOWMELD_ALL);
-    WAR_STOMP                     = m_ai->initSpell(WAR_STOMP_ALL); // tauren
-}
-
-PlayerbotDruidAI::~PlayerbotDruidAI() {}
-
-CombatManeuverReturns PlayerbotDruidAI::DoFirstCombatManeuver(Unit* pTarget)
-{
-    bool meleeReach = m_bot->CanReachWithMeleeAttack(pTarget);
-    // There are NPCs in BGs and Open World PvP, so don't filter this on PvP scenarios (of course if PvP targets anyone but tank, all bets are off anyway)
-    // Wait until the tank says so, until any non-tank gains aggro or X seconds - whichever is shortest
-    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO)
-    {
-        if (m_WaitUntil > m_ai->CurrentTime() && m_ai->GroupTankHoldsAggro())
-        {
-            if (PlayerbotAI::ORDERS_TANK & m_ai->GetCombatOrder())
-            {
-                if (meleeReach)
-                {
-                    // Set everyone's UpdateAI() waiting to 2 seconds
-                    m_ai->SetGroupIgnoreUpdateTime(2);
-                    // Clear their TEMP_WAIT_TANKAGGRO flag
-                    m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO);
-                    // Start attacking, force target on current target
-                    m_ai->Attack(m_ai->GetCurrentTarget());
-
-                    // While everyone else is waiting 2 second, we need to build up aggro, so don't return
-                }
-                else
-                {
-                    // TODO: add check if target is ranged
-                    return RETURN_NO_ACTION_OK; // wait for target to get nearer
-                }
-            }
-            else if (PlayerbotAI::ORDERS_HEAL & m_ai->GetCombatOrder())
-                return _DoNextPVECombatManeuverHeal();
-            else
-                return RETURN_NO_ACTION_OK; // wait it out
-        }
-        else
-        {
-            m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO);
-        }
-    }
-
-    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TEMP_WAIT_OOC)
-    {
-        if (m_WaitUntil > m_ai->CurrentTime() && m_ai->IsGroupReady())
-            return RETURN_NO_ACTION_OK; // wait it out
-        else
-            m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_OOC);
-    }
-
-    switch (m_ai->GetScenarioType())
-    {
-        case PlayerbotAI::SCENARIO_PVP_DUEL:
-        case PlayerbotAI::SCENARIO_PVP_BG:
-        case PlayerbotAI::SCENARIO_PVP_ARENA:
-        case PlayerbotAI::SCENARIO_PVP_OPENWORLD:
-            return DoFirstCombatManeuverPVP(pTarget);
-
-        case PlayerbotAI::SCENARIO_PVE:
-        case PlayerbotAI::SCENARIO_PVE_ELITE:
-        case PlayerbotAI::SCENARIO_PVE_RAID:
-        default:
-            return DoFirstCombatManeuverPVE(pTarget);
-    }
-
-    return RETURN_NO_ACTION_ERROR;
-}
-
-CombatManeuverReturns PlayerbotDruidAI::DoFirstCombatManeuverPVE(Unit* /*pTarget*/)
-{
-    return RETURN_NO_ACTION_OK;
-}
-
-CombatManeuverReturns PlayerbotDruidAI::DoFirstCombatManeuverPVP(Unit* /*pTarget*/)
-{
-    return RETURN_NO_ACTION_OK;
-}
-
-CombatManeuverReturns PlayerbotDruidAI::DoNextCombatManeuver(Unit* pTarget)
-{
-    switch (m_ai->GetScenarioType())
-    {
-        case PlayerbotAI::SCENARIO_PVP_DUEL:
-        case PlayerbotAI::SCENARIO_PVP_BG:
-        case PlayerbotAI::SCENARIO_PVP_ARENA:
-        case PlayerbotAI::SCENARIO_PVP_OPENWORLD:
-            return DoNextCombatManeuverPVP(pTarget);
-
-        case PlayerbotAI::SCENARIO_PVE:
-        case PlayerbotAI::SCENARIO_PVE_ELITE:
-        case PlayerbotAI::SCENARIO_PVE_RAID:
-        default:
-            return DoNextCombatManeuverPVE(pTarget);
-    }
-
-    return RETURN_NO_ACTION_ERROR;
-}
-
-CombatManeuverReturns PlayerbotDruidAI::DoNextCombatManeuverPVE(Unit* pTarget)
-{
-    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
-    if (!m_bot) return RETURN_NO_ACTION_ERROR;
-
-    bool meleeReach = m_bot->CanReachWithMeleeAttack(pTarget);
-
-    //uint32 masterHP = GetMaster()->GetHealth() * 100 / GetMaster()->GetMaxHealth();
-
-    uint32 spec = m_bot->GetSpec();
-    if (spec == 0) // default to spellcasting or healing for healer
-        spec = (PlayerbotAI::ORDERS_HEAL & m_ai->GetCombatOrder() ? DRUID_SPEC_RESTORATION : DRUID_SPEC_BALANCE);
-
-    // Make sure healer stays put, don't even melee (aggro) if in range: only melee if feral spec AND not healer
-    if (!m_ai->IsHealer() && spec == DRUID_SPEC_FERAL && m_ai->GetCombatStyle() != PlayerbotAI::COMBAT_MELEE)
-        m_ai->SetCombatStyle(PlayerbotAI::COMBAT_MELEE);
-    else    // ranged combat in all other cases
-        m_ai->SetCombatStyle(PlayerbotAI::COMBAT_RANGED);
-
-    //Unit* pVictim = pTarget->getVictim();
-    uint32 BEAR = (DIRE_BEAR_FORM > 0 ? DIRE_BEAR_FORM : BEAR_FORM);
-
-    // TODO: do something to allow emergency heals for non-healers?
-    switch (CheckForms())
-    {
-        case RETURN_OK_SHIFTING:
-            return RETURN_CONTINUE;
-
-        case RETURN_FAIL:
-        case RETURN_OK_CANNOTSHIFT:
-            if (spec == DRUID_SPEC_FERAL)
-                spec = DRUID_SPEC_BALANCE; // Can't shift, force spellcasting
-            break; // rest functions without form
-
-        //case RETURN_OK_NOCHANGE: // great!
-        //case RETURN_FAIL_WAITINGONSELFBUFF: // This is war dammit! No time for silly buffs during combat...
-        default:
-            break;
-    }
-
-    // Low mana and bot is a caster/healer: cast Innervate on self
-    // TODO add group check to also cast on low mana healers or master
-    if (m_ai->GetManaPercent() < 15 && ((m_ai->IsHealer() || spec == DRUID_SPEC_RESTORATION)))
-        if (INNERVATE > 0 && !m_bot->HasAura(INNERVATE, EFFECT_INDEX_0) && CastSpell(INNERVATE, m_bot))
-            return RETURN_CONTINUE;
-
-    //Used to determine if this bot is highest on threat
-    Unit* newTarget = m_ai->FindAttacker((PlayerbotAI::ATTACKERINFOTYPE)(PlayerbotAI::AIT_VICTIMSELF | PlayerbotAI::AIT_HIGHESTTHREAT), m_bot);
-    if (newTarget && !(m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TANK) && !m_ai->IsNeutralized(newTarget)) // TODO: && party has a tank
-    {
-        if (HealPlayer(m_bot) == RETURN_CONTINUE)
-            return RETURN_CONTINUE;
-
-        // Aggroed by an elite that came in melee range
-        if (m_ai->IsElite(newTarget) && meleeReach)
-        {
-            // protect the bot with barkskin: the increased casting time is meaningless
-            // because bot will then avoid to cast to not angry mob further
-            if (m_ai->IsHealer() || spec == DRUID_SPEC_RESTORATION || spec == DRUID_SPEC_BALANCE)
-            {
-                if (BARKSKIN > 0 && !m_bot->HasAura(BARKSKIN, EFFECT_INDEX_0) && CastSpell(BARKSKIN, m_bot))
-                    return RETURN_CONTINUE;
-
-                return RETURN_NO_ACTION_OK;
-            }
-            //no other cases: cats have cower in the damage rotation and bears can tank
-        }
-    }
-
-    if (m_ai->IsHealer())
-        if (_DoNextPVECombatManeuverHeal() & RETURN_CONTINUE)
-            return RETURN_CONTINUE;
-
-    switch (spec)
-    {
-        case DRUID_SPEC_FERAL:
-            if (BEAR > 0 && m_bot->HasAura(BEAR))
-                return _DoNextPVECombatManeuverBear(pTarget);
-            if (CAT_FORM > 0 && m_bot->HasAura(CAT_FORM))
-                return _DoNextPVECombatManeuverCat(pTarget);
-        // NO break - failover to DRUID_SPEC_BALANCE
-
-        case DRUID_SPEC_RESTORATION: // There is no Resto DAMAGE rotation. If you insist, go Balance...
-        case DRUID_SPEC_BALANCE:
-            if (m_bot->HasAura(BEAR) || m_bot->HasAura(CAT_FORM) || m_bot->HasAura(TREE_OF_LIFE))
-                return RETURN_NO_ACTION_UNKNOWN; // Didn't shift out of inappropriate form
-
-            return _DoNextPVECombatManeuverSpellDPS(pTarget);
-
-            /*if (BASH > 0 && !pTarget->HasAura(BASH, EFFECT_INDEX_0) && DruidSpellCombat < 5 && CastSpell(BASH, pTarget))
-                return RETURN_CONTINUE;
-            if (CHALLENGING_ROAR > 0 && pVictim != m_bot && !pTarget->HasAura(CHALLENGING_ROAR, EFFECT_INDEX_0) && !pTarget->HasAura(GROWL, EFFECT_INDEX_0) && CastSpell(CHALLENGING_ROAR, pTarget))
-                return RETURN_CONTINUE;
-            if (ROOTS > 0 && !pTarget->HasAura(ROOTS, EFFECT_INDEX_0) && CastSpell(ROOTS, pTarget))
-                return RETURN_CONTINUE;
-            if (HURRICANE > 0 && ai->In_Reach(target,HURRICANE) && m_ai->GetAttackerCount() >= 5 && CastSpell(HURRICANE, pTarget))
-            {
-                m_ai->SetIgnoreUpdateTime(10);
-                return RETURN_CONTINUE;
-            }
-            */
-    }
-
-    return RETURN_NO_ACTION_UNKNOWN;
-} // end DoNextCombatManeuver
-
-CombatManeuverReturns PlayerbotDruidAI::DoNextCombatManeuverPVP(Unit* pTarget)
-{
-    if (m_ai->CastSpell(MOONFIRE))
-        return RETURN_CONTINUE;
-
-    return DoNextCombatManeuverPVE(pTarget); // TODO: bad idea perhaps, but better than the alternative
-}
-
-CombatManeuverReturns PlayerbotDruidAI::_DoNextPVECombatManeuverBear(Unit* pTarget)
-{
-    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
-    if (!m_bot) return RETURN_NO_ACTION_ERROR;
-
-    if (!m_bot->HasAura((DIRE_BEAR_FORM > 0 ? DIRE_BEAR_FORM : BEAR_FORM))) return RETURN_NO_ACTION_ERROR;
-
-    // Used to determine if this bot is highest on threat
-    Unit* newTarget = m_ai->FindAttacker((PlayerbotAI::ATTACKERINFOTYPE)(PlayerbotAI::AIT_VICTIMSELF | PlayerbotAI::AIT_HIGHESTTHREAT), m_bot);
-
-    // Face enemy, make sure you're attacking
-    m_ai->FaceTarget(pTarget);
-
-    if (PlayerbotAI::ORDERS_TANK & m_ai->GetCombatOrder() && !newTarget && GROWL > 0 && m_bot->IsSpellReady(GROWL))
-        if (CastSpell(GROWL, pTarget))
-            return RETURN_CONTINUE;
-
-    if (FAERIE_FIRE_FERAL > 0 && m_ai->In_Reach(pTarget, FAERIE_FIRE_FERAL) && !pTarget->HasAura(FAERIE_FIRE_FERAL, EFFECT_INDEX_0))
-        if (CastSpell(FAERIE_FIRE_FERAL, pTarget))
-            return RETURN_CONTINUE;
-
-    if (SWIPE > 0 && m_ai->In_Reach(pTarget, SWIPE) && m_ai->GetAttackerCount() >= 2 && CastSpell(SWIPE, pTarget))
-        return RETURN_CONTINUE;
-
-    if (ENRAGE > 0 && m_bot->IsSpellReady(ENRAGE) && CastSpell(ENRAGE, m_bot))
-        return RETURN_CONTINUE;
-
-    if (DEMORALIZING_ROAR > 0 && !pTarget->HasAura(DEMORALIZING_ROAR, EFFECT_INDEX_0) && CastSpell(DEMORALIZING_ROAR, pTarget))
-        return RETURN_CONTINUE;
-
-    if (MANGLE_BEAR > 0 && !pTarget->HasAura(MANGLE_BEAR) && CastSpell(MANGLE_BEAR, pTarget))
-        return RETURN_CONTINUE;
-
-    if (LACERATE > 0 && !pTarget->HasAura(LACERATE, EFFECT_INDEX_0) && CastSpell(LACERATE, pTarget))
-        return RETURN_CONTINUE;
-
-    if (MAUL > 0 && CastSpell(MAUL, pTarget))
-        return RETURN_CONTINUE;
-
-    return RETURN_NO_ACTION_UNKNOWN;
-}
-
-CombatManeuverReturns PlayerbotDruidAI::_DoNextPVECombatManeuverCat(Unit* pTarget)
-{
-    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
-    if (!m_bot) return RETURN_NO_ACTION_ERROR;
-
-    if (!m_bot->HasAura(CAT_FORM)) return RETURN_NO_ACTION_UNKNOWN;
-
-    //Used to determine if this bot is highest on threat
-    Unit* newTarget = m_ai->FindAttacker((PlayerbotAI::ATTACKERINFOTYPE)(PlayerbotAI::AIT_VICTIMSELF | PlayerbotAI::AIT_HIGHESTTHREAT), m_bot);
-
-    // Face enemy, make sure you're attacking
-    m_ai->FaceTarget(pTarget);
-
-    // Attempt to do a finishing move
-    if (m_bot->GetComboPoints() >= 5)
-    {
-        // 30 Energy
-        if (RIP > 0 && !pTarget->HasAura(RIP, EFFECT_INDEX_0))
-        {
-            if (CastSpell(RIP, pTarget))
-                return RETURN_CONTINUE;
-        }
-        // 35 Energy
-        else if (FEROCIOUS_BITE > 0)
-        {
-            if (CastSpell(FEROCIOUS_BITE, pTarget))
-                return RETURN_CONTINUE;
-        }
-    } // End 5 ComboPoints
-
-    if (newTarget && COWER > 0 && m_bot->IsSpellReady(COWER) && CastSpell(COWER, pTarget))
-        return RETURN_CONTINUE;
-
-    if (SHRED > 0 && pTarget->isInBackInMap(m_bot, 5.0f) && m_ai->CastSpell(SHRED, *pTarget))
-        return RETURN_CONTINUE;
-
-    if (FAERIE_FIRE_FERAL > 0 && m_ai->In_Reach(pTarget, FAERIE_FIRE_FERAL) && !pTarget->HasAura(FAERIE_FIRE_FERAL, EFFECT_INDEX_0) && CastSpell(FAERIE_FIRE_FERAL, pTarget))
-        return RETURN_CONTINUE;
-
-    if (TIGERS_FURY > 0 && m_bot->IsSpellReady(TIGERS_FURY) && !m_bot->HasAura(TIGERS_FURY, EFFECT_INDEX_0) && CastSpell(TIGERS_FURY))
-        return RETURN_CONTINUE;
-
-    if (MANGLE_CAT > 0 && !pTarget->HasAura(MANGLE_CAT) && CastSpell(MANGLE_CAT))
-        return RETURN_CONTINUE;
-
-    if (RAKE > 0 && !pTarget->HasAura(RAKE) && CastSpell(RAKE, pTarget))
-        return RETURN_CONTINUE;
-
-    if (CLAW > 0 && CastSpell(CLAW, pTarget))
-        return RETURN_CONTINUE;
-
-    return RETURN_NO_ACTION_UNKNOWN;
-}
-
-CombatManeuverReturns PlayerbotDruidAI::_DoNextPVECombatManeuverSpellDPS(Unit* pTarget)
-{
-    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
-    if (!m_bot) return RETURN_NO_ACTION_ERROR;
-
-    uint32 NATURE = (STARFIRE > 0 ? STARFIRE : WRATH);
-
-    // Face enemy, make sure you're attacking
-    m_ai->FaceTarget(pTarget);
-
-    if (FAERIE_FIRE > 0 && m_ai->In_Reach(pTarget, FAERIE_FIRE) && !pTarget->HasAura(FAERIE_FIRE, EFFECT_INDEX_0) && CastSpell(FAERIE_FIRE, pTarget))
-        return RETURN_CONTINUE;
-
-    if (INSECT_SWARM > 0 && m_ai->In_Reach(pTarget, INSECT_SWARM) && !pTarget->HasAura(INSECT_SWARM, EFFECT_INDEX_0) && CastSpell(INSECT_SWARM, pTarget))
-        return RETURN_CONTINUE;
-
-    // Healer? Don't waste more mana on DPS
-    if (m_ai->IsHealer())
-        return RETURN_NO_ACTION_OK;
-
-    if (MOONFIRE > 0 && m_ai->In_Reach(pTarget, MOONFIRE) && !pTarget->HasAura(MOONFIRE, EFFECT_INDEX_0) && CastSpell(MOONFIRE, pTarget))
-        return RETURN_CONTINUE;
-
-    if (FORCE_OF_NATURE > 0 && m_ai->In_Reach(pTarget, FORCE_OF_NATURE) && CastSpell(FORCE_OF_NATURE))
-        return RETURN_CONTINUE;
-
-    if (NATURE > 0 && CastSpell(NATURE, pTarget))
-        return RETURN_CONTINUE;
-
-    if (m_ai->GetCombatStyle() == PlayerbotAI::COMBAT_MELEE)
-        m_bot->Attack(pTarget, true);
-    else
-        m_bot->AttackStop();
-
-    return RETURN_NO_ACTION_UNKNOWN;
-}
-
-CombatManeuverReturns PlayerbotDruidAI::_DoNextPVECombatManeuverHeal()
-{
-    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
-    if (!m_bot) return RETURN_NO_ACTION_ERROR;
-
-    if (HealPlayer(GetHealTarget()) & (RETURN_NO_ACTION_OK | RETURN_CONTINUE))
-        return RETURN_CONTINUE;
-
-    return RETURN_NO_ACTION_UNKNOWN;
-}
-
-CombatManeuverReturns PlayerbotDruidAI::HealPlayer(Player* target)
-{
-    CombatManeuverReturns r = PlayerbotClassAI::HealPlayer(target);
-    if (r != RETURN_NO_ACTION_OK)
-        return r;
-
-    if (!target->isAlive())
-    {
-        if (m_bot->isInCombat())
-        {
-            if (REBIRTH && m_ai->In_Reach(target, REBIRTH) && m_bot->IsSpellReady(REBIRTH) && m_ai->CastSpell(REBIRTH, *target))
-            {
-                std::string msg = "Resurrecting ";
-                msg += target->GetName();
-                m_bot->Say(msg, LANG_UNIVERSAL);
-                return RETURN_CONTINUE;
-            }
-        }
-        return RETURN_NO_ACTION_ERROR; // not error per se - possibly just OOM
-    }
-
-    // Remove curse on group members if orders allow bot to do so
-    if (Player* pCursedTarget = GetDispelTarget(DISPEL_CURSE))
-    {
-        if (REMOVE_CURSE > 0 && (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_NODISPEL) == 0 && CastSpell(REMOVE_CURSE, pCursedTarget))
-            return RETURN_CONTINUE;
-    }
-
-    // Remove poison on group members if orders allow bot to do so
-    if (Player* pPoisonedTarget = GetDispelTarget(DISPEL_POISON))
-    {
-        uint32 cure = ABOLISH_POISON > 0 ? ABOLISH_POISON : CURE_POISON;
-        if (cure > 0 && (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_NODISPEL) == 0 && CastSpell(cure, pPoisonedTarget))
-            return RETURN_CONTINUE;
-    }
-
-    uint8 hp = target->GetHealthPercent();
-
-    // Define a tank bot will look at
-    Unit* pMainTank = GetHealTarget(JOB_TANK);
-
-    // If target is out of range (40 yards) and is a tank: move towards it
-    // Other classes have to adjust their position to the healers
-    // TODO: This code should be common to all healers and will probably
-    // move to a more suitable place
-    if (pMainTank && !m_ai->In_Reach(pMainTank, HEALING_TOUCH))
-    {
-        m_bot->GetMotionMaster()->MoveFollow(target, 39.0f, m_bot->GetOrientation());
-        return RETURN_CONTINUE;
-    }
-
-    // Everyone is healthy enough, return OK. MUST correlate to highest value below (should be last HP check)
-    if (hp >= 80)
-        return RETURN_NO_ACTION_OK;
-
-    // Reset form if needed
-    if (!m_bot->HasAura(TREE_OF_LIFE) || TREE_OF_LIFE == 0)
-        GoBuffForm(GetPlayerBot());
-
-    // Start heals. Do lowest HP checks at the top
-
-    // Emergency heal: target needs to be healed NOW!
-    if ((target == pMainTank && hp < 10) || (target != pMainTank && hp < 15))
-    {
-        // first try Nature's Swiftness + Healing Touch: instant heal
-        if (NATURES_SWIFTNESS > 0 && m_bot->IsSpellReady(NATURES_SWIFTNESS) && CastSpell(NATURES_SWIFTNESS, m_bot))
-            return RETURN_CONTINUE;
-
-        if (HEALING_TOUCH > 0 && m_bot->HasAura(NATURES_SWIFTNESS, EFFECT_INDEX_0) && m_ai->In_Reach(target, HEALING_TOUCH) && CastSpell(HEALING_TOUCH, target))
-            return RETURN_CONTINUE;
-
-        // Else try to Swiftmend the target if druid HoT is active on it
-        if (SWIFTMEND > 0 && m_bot->IsSpellReady(SWIFTMEND) && m_ai->In_Reach(target, SWIFTMEND) && (target->HasAura(REJUVENATION) || target->HasAura(REGROWTH)) && CastSpell(SWIFTMEND, target))
-            return RETURN_CONTINUE;
-    }
-
-    // Urgent heal: target won't die next second, but first bot needs to gain some time to cast Healing Touch safely
-    if ((target == pMainTank && hp < 15) || (target != pMainTank && hp < 25))
-    {
-        if (REGROWTH > 0 && m_ai->In_Reach(target, REGROWTH) && !target->HasAura(REGROWTH) && CastSpell(REGROWTH, target))
-            return RETURN_CONTINUE;
-        if (REJUVENATION > 0 && m_ai->In_Reach(target, REJUVENATION) && target->HasAura(REGROWTH) && !target->HasAura(REJUVENATION) && CastSpell(REJUVENATION, target))
-            return RETURN_CONTINUE;
-        if (SWIFTMEND > 0 && m_bot->IsSpellReady(SWIFTMEND) && m_ai->In_Reach(target, SWIFTMEND) && (target->HasAura(REJUVENATION) || target->HasAura(REGROWTH)) && CastSpell(SWIFTMEND, target))
-            return RETURN_CONTINUE;
-    }
-
-    if (hp < 60 && HEALING_TOUCH > 0 && m_ai->In_Reach(target, HEALING_TOUCH) && CastSpell(HEALING_TOUCH, target))
-        return RETURN_CONTINUE;
-
-    if (hp < 65 && LIFEBLOOM > 0 && m_ai->In_Reach(target, LIFEBLOOM) && !target->HasAura(LIFEBLOOM) && CastSpell(LIFEBLOOM, target))
-        return RETURN_CONTINUE;
-
-    if (hp < 80 && REJUVENATION > 0 && m_ai->In_Reach(target, REJUVENATION) && !target->HasAura(REJUVENATION) && CastSpell(REJUVENATION, target))
-        return RETURN_CONTINUE;
-
-    return RETURN_NO_ACTION_UNKNOWN;
-} // end HealTarget
-
-/**
-* CheckForms()
-*
-* Returns bool - Value indicates success - shape was shifted, already shifted, no need to shift.
-*/
-uint8 PlayerbotDruidAI::CheckForms()
-{
-    if (!m_ai)  return RETURN_FAIL;
-    if (!m_bot) return RETURN_FAIL;
-
-    uint32 spec = m_bot->GetSpec();
-    uint32 BEAR = (DIRE_BEAR_FORM > 0 ? DIRE_BEAR_FORM : BEAR_FORM);
-
-    // if bot has healing orders always shift to humanoid form
-    // regardless of spec
-    if ((PlayerbotAI::ORDERS_HEAL & m_ai->GetCombatOrder()) || spec == DRUID_SPEC_RESTORATION)
-    {
-        if (m_bot->HasAura(TREE_OF_LIFE))
-            return RETURN_OK_NOCHANGE;
-
-        if (!TREE_OF_LIFE)
-            return RETURN_OK_CANNOTSHIFT;
-
-        if (m_bot->HasAura(CAT_FORM, EFFECT_INDEX_0))
-        {
-            m_bot->RemoveAurasDueToSpell(CAT_FORM_1);
-            //m_ai->TellMaster("FormClearCat");
-            return RETURN_OK_SHIFTING;
-        }
-        if (m_bot->HasAura(BEAR_FORM, EFFECT_INDEX_0))
-        {
-            m_bot->RemoveAurasDueToSpell(BEAR_FORM_1);
-            //m_ai->TellMaster("FormClearBear");
-            return RETURN_OK_SHIFTING;
-        }
-        if (m_bot->HasAura(DIRE_BEAR_FORM, EFFECT_INDEX_0))
-        {
-            m_bot->RemoveAurasDueToSpell(DIRE_BEAR_FORM_1);
-            //m_ai->TellMaster("FormClearDireBear");
-            return RETURN_OK_SHIFTING;
-        }
-        // spellcasting form, but disables healing spells so it's got to go
-        if (m_bot->HasAura(MOONKIN_FORM, EFFECT_INDEX_0))
-        {
-            m_bot->RemoveAurasDueToSpell(MOONKIN_FORM_1);
-            //m_ai->TellMaster("FormClearMoonkin");
-            return RETURN_OK_SHIFTING;
-        }
-
-        if (CastSpell(TREE_OF_LIFE))
-            return RETURN_OK_SHIFTING;
-        else
-            return RETURN_FAIL;
-    }
-
-    if (spec == DRUID_SPEC_BALANCE)
-    {
-        if (m_bot->HasAura(MOONKIN_FORM))
-            return RETURN_OK_NOCHANGE;
-
-        if (!MOONKIN_FORM)
-            return RETURN_OK_CANNOTSHIFT;
-
-        if (CastSpell(MOONKIN_FORM))
-            return RETURN_OK_SHIFTING;
-        else
-            return RETURN_FAIL;
-    }
-
-    if (spec == DRUID_SPEC_FERAL)
-    {
-        // Use Bear form only if we are told we're a tank and have thorns up
-        if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TANK)
-        {
-            if (m_bot->HasAura(BEAR))
-                return RETURN_OK_NOCHANGE;
-
-            if (!BEAR)
-                return RETURN_OK_CANNOTSHIFT;
-
-            if (!m_bot->HasAura(THORNS))
-                return RETURN_FAIL_WAITINGONSELFBUFF;
-
-            if (CastSpell(BEAR))
-                return RETURN_OK_SHIFTING;
-            else
-                return RETURN_FAIL;
-        }
-        else // No tank orders - try to go kitty or at least bear
-        {
-            if (CAT_FORM > 0)
-            {
-                if (m_bot->HasAura(CAT_FORM))
-                    return RETURN_OK_NOCHANGE;
-
-                if (CastSpell(CAT_FORM))
-                    return RETURN_OK_SHIFTING;
-                else
-                    return RETURN_FAIL;
-            }
-
-            if (BEAR > 0)
-            {
-                if (m_bot->HasAura(BEAR))
-                    return RETURN_OK_NOCHANGE;
-
-                if (CastSpell(BEAR))
-                    return RETURN_OK_SHIFTING;
-                else
-                    return RETURN_FAIL;
-            }
-
-            return RETURN_OK_CANNOTSHIFT;
-        }
-    }
-
-    // Unknown Spec
-    return RETURN_FAIL;
-}
-
-void PlayerbotDruidAI::DoNonCombatActions()
-{
-    if (!m_ai)   return;
-    if (!m_bot)  return;
-
-    if (!m_bot->isAlive() || m_bot->IsInDuel()) return;
-
-    // Heal
-    if (m_ai->IsHealer())
-    {
-        if (HealPlayer(GetHealTarget()) & RETURN_CONTINUE)
-            return;// RETURN_CONTINUE;
-    }
-    else
-    {
-        // Is this desirable? Debatable.
-        // TODO: In a group/raid with a healer you'd want this bot to focus on DPS (it's not specced/geared for healing either)
-        if (HealPlayer(m_bot) & RETURN_CONTINUE)
-            return;// RETURN_CONTINUE;
-    }
-
-    // Buff group
-    // the check for group targets is performed by NeedGroupBuff (if group is found for bots by the function)
-    if (NeedGroupBuff(GIFT_OF_THE_WILD, MARK_OF_THE_WILD) && m_ai->HasSpellReagents(GIFT_OF_THE_WILD))
-    {
-        if (Buff(&PlayerbotDruidAI::BuffHelper, GIFT_OF_THE_WILD) & RETURN_CONTINUE)
-            return;
-    }
-    else if (Buff(&PlayerbotDruidAI::BuffHelper, MARK_OF_THE_WILD) & RETURN_CONTINUE)
-        return;
-    if (Buff(&PlayerbotDruidAI::BuffHelper, THORNS, (m_bot->GetGroup() ? JOB_TANK : JOB_ALL)) & RETURN_CONTINUE)
-        return;
-    if (OMEN_OF_CLARITY && !m_bot->HasAura(OMEN_OF_CLARITY) && CastSpell(OMEN_OF_CLARITY, m_bot))
-        return;
-
-    // hp/mana check
-    if (EatDrinkBandage())
-        return;
-
-    if (INNERVATE && m_ai->In_Reach(m_bot, INNERVATE) && !m_bot->HasAura(INNERVATE) && m_ai->GetManaPercent() <= 20 && CastSpell(INNERVATE, m_bot))
-        return;
-
-    // Return to fighting form AFTER reviving, healing, buffing
-    CheckForms();
-
-    // Nothing else to do, Night Elves will cast Shadowmeld to reduce their aggro versus patrols or nearby mobs
-    if (SHADOWMELD && !m_bot->isMovingOrTurning()
-        && !m_bot->IsMounted()
-        && !m_bot->HasAura(SHADOWMELD, EFFECT_INDEX_0))
-    {
-        m_ai->CastSpell(SHADOWMELD, *m_bot);
-    }
-} // end DoNonCombatActions
-
-bool PlayerbotDruidAI::BuffHelper(PlayerbotAI* ai, uint32 spellId, Unit* target)
-{
-    if (!ai)          return false;
-    if (spellId == 0) return false;
-    if (!target)      return false;
-
-    Pet* pet = target->GetPet();
-    if (pet && !pet->HasAuraType(SPELL_AURA_MOD_UNATTACKABLE) && ai->Buff(spellId, pet, &(PlayerbotDruidAI::GoBuffForm)))
-        return true;
-
-    if (ai->Buff(spellId, target, &(PlayerbotDruidAI::GoBuffForm)))
-        return true;
-
-    return false;
-}
-
-void PlayerbotDruidAI::GoBuffForm(Player* self)
-{
-    // RANK_1 spell ids used because this is a static method which does not have access to instance.
-    // There is only one rank for these spells anyway.
-    if (self->HasAura(CAT_FORM_1))
-        self->RemoveAurasDueToSpell(CAT_FORM_1);
-    if (self->HasAura(BEAR_FORM_1))
-        self->RemoveAurasDueToSpell(BEAR_FORM_1);
-    if (self->HasAura(DIRE_BEAR_FORM_1))
-        self->RemoveAurasDueToSpell(DIRE_BEAR_FORM_1);
-    if (self->HasAura(MOONKIN_FORM_1))
-        self->RemoveAurasDueToSpell(MOONKIN_FORM_1);
-    if (self->HasAura(TRAVEL_FORM_1))
-        self->RemoveAurasDueToSpell(TRAVEL_FORM_1);
-}
-
-// Match up with "Pull()" below
-bool PlayerbotDruidAI::CanPull()
-{
-    if (BEAR_FORM && FAERIE_FIRE_FERAL)
-        return true;
-
-    return false;
-}
-
-// Match up with "CanPull()" above
-bool PlayerbotDruidAI::Pull()
-{
-    if (BEAR_FORM && (CastSpell(FAERIE_FIRE_FERAL) & RETURN_CONTINUE))
-        return true;
-
-    return false;
-}
-
-bool PlayerbotDruidAI::CastHoTOnTank()
-{
-    if (!m_ai) return false;
-
-    if ((PlayerbotAI::ORDERS_HEAL & m_ai->GetCombatOrder()) == 0) return false;
-
-    // Druid HoTs: Rejuvenation, Regrowth, Tranquility (channeled, AoE), Lifebloom, and Wild Growth
-    if (REJUVENATION)
-        return (RETURN_CONTINUE & CastSpell(REJUVENATION, m_ai->GetGroupTank()));
-
-    return false;
-}
-
-// Return to UpdateAI the spellId usable to neutralize a target with creaturetype
-uint32 PlayerbotDruidAI::Neutralize(uint8 creatureType)
-{
-    if (!m_bot)         return 0;
-    if (!m_ai)          return 0;
-    if (!creatureType)  return 0;
-
-    if (creatureType != CREATURE_TYPE_DRAGONKIN && creatureType != CREATURE_TYPE_BEAST)
-    {
-        m_ai->TellMaster("I can't make that target hibernate.");
-        return 0;
-    }
-
-    if (HIBERNATE)
-        return HIBERNATE;
-    else
-        return 0;
-
-    return 0;
-}
diff --git a/src/game/PlayerBot/AI/PlayerbotDruidAI.h b/src/game/PlayerBot/AI/PlayerbotDruidAI.h
deleted file mode 100644
index 8ee17e8e4..000000000
--- a/src/game/PlayerBot/AI/PlayerbotDruidAI.h
+++ /dev/null
@@ -1,224 +0,0 @@
-/*
- * This file is part of the CMaNGOS Project. See AUTHORS file for Copyright information
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _PLAYERBOTDRUIDAI_H
-#define _PLAYERBOTDRUIDAI_H
-
-#include "../Base/PlayerbotClassAI.h"
-
-enum DruidSpells
-{
-    ABOLISH_POISON_1                = 2893,
-    AQUATIC_FORM_1                  = 1066,
-    BARKSKIN_1                      = 22812,
-    BASH_1                          = 5211,
-    BEAR_FORM_1                     = 5487,
-    CAT_FORM_1                      = 768,
-    CHALLENGING_ROAR_1              = 5209,
-    CLAW_1                          = 1082,
-    COWER_1                         = 8998,
-    CURE_POISON_1                   = 8946,
-    CYCLONE_1                       = 33786,
-    DASH_1                          = 1850,
-    DEMORALIZING_ROAR_1             = 99,
-    DIRE_BEAR_FORM_1                = 9634,
-    ENRAGE_1                        = 5229,
-    ENTANGLING_ROOTS_1              = 339,
-    FAERIE_FIRE_1                   = 770,
-    FAERIE_FIRE_FERAL_1             = 16857,
-    FERAL_CHARGE_BEAR_1             = 16979,
-    FEROCIOUS_BITE_1                = 22568,
-    FLIGHT_FORM_1                   = 33943,
-    FORCE_OF_NATURE_1               = 33831,
-    FRENZIED_REGENERATION_1         = 22842,
-    GIFT_OF_THE_WILD_1              = 21849,
-    GROWL_1                         = 6795,
-    HEALING_TOUCH_1                 = 5185,
-    HIBERNATE_1                     = 2637,
-    HURRICANE_1                     = 16914,
-    INNERVATE_1                     = 29166,
-    INSECT_SWARM_1                  = 5570,
-    LACERATE_1                      = 33745,
-    LIFEBLOOM_1                     = 33763,
-    MAIM_1                          = 22570,
-    MANGLE_1                        = 33917,
-    MANGLE_BEAR_1                   = 33878,
-    MANGLE_CAT_1                    = 33876,
-    MARK_OF_THE_WILD_1              = 1126,
-    MAUL_1                          = 6807,
-    MOONFIRE_1                      = 8921,
-    MOONKIN_FORM_1                  = 24858,
-    NATURES_GRASP_1                 = 16689,
-    NATURES_SWIFTNESS_DRUID_1       = 17116,
-    OMEN_OF_CLARITY_1               = 16864,
-    POUNCE_1                        = 9005,
-    PROWL_1                         = 5215,
-    RAKE_1                          = 1822,
-    RAVAGE_1                        = 6785,
-    REBIRTH_1                       = 20484,
-    REGROWTH_1                      = 8936,
-    REJUVENATION_1                  = 774,
-    REMOVE_CURSE_DRUID_1            = 2782,
-    RIP_1                           = 1079,
-    SHRED_1                         = 5221,
-    SOOTHE_ANIMAL_1                 = 2908,
-    STARFIRE_1                      = 2912,
-    SWIFTMEND_1                     = 18562,
-    SWIFT_FLIGHT_FORM_1             = 40120,
-    SWIPE_BEAR_1                    = 779,
-    THORNS_1                        = 467,
-    TIGERS_FURY_1                   = 5217,
-    TRANQUILITY_1                   = 740,
-    TRAVEL_FORM_1                   = 783,
-    TREE_OF_LIFE_1                  = 33891,
-    WRATH_1                         = 5176,
-};
-
-//class Player;
-
-class PlayerbotDruidAI : PlayerbotClassAI
-{
-    public:
-        PlayerbotDruidAI(Player* const master, Player* const bot, PlayerbotAI* const ai);
-        virtual ~PlayerbotDruidAI();
-
-        // all combat actions go here
-        CombatManeuverReturns DoFirstCombatManeuver(Unit* pTarget);
-        CombatManeuverReturns DoNextCombatManeuver(Unit* pTarget);
-        bool Pull();
-        uint32 Neutralize(uint8 creatureType);
-
-        // all non combat actions go here, ex buffs, heals, rezzes
-        void DoNonCombatActions();
-
-        // Utility Functions
-        bool CanPull();
-        bool CastHoTOnTank();
-
-    private:
-        CombatManeuverReturns DoFirstCombatManeuverPVE(Unit* pTarget);
-        CombatManeuverReturns DoNextCombatManeuverPVE(Unit* pTarget);
-        CombatManeuverReturns DoFirstCombatManeuverPVP(Unit* pTarget);
-        CombatManeuverReturns DoNextCombatManeuverPVP(Unit* pTarget);
-
-        CombatManeuverReturns CastSpell(uint32 nextAction, Unit* pTarget = nullptr) { return CastSpellNoRanged(nextAction, pTarget); }
-
-        // Combat Maneuver helper functions
-        CombatManeuverReturns _DoNextPVECombatManeuverBear(Unit* pTarget);
-        CombatManeuverReturns _DoNextPVECombatManeuverCat(Unit* pTarget);
-        CombatManeuverReturns _DoNextPVECombatManeuverSpellDPS(Unit* pTarget);
-        CombatManeuverReturns _DoNextPVECombatManeuverHeal();
-
-        // Heals the target based off its hps
-        CombatManeuverReturns HealPlayer(Player* target);
-
-        static bool BuffHelper(PlayerbotAI* ai, uint32 spellId, Unit* target);
-        // Callback method to reset shapeshift forms blocking buffs and heals
-        static void GoBuffForm(Player* self);
-
-        //Assumes form based on spec
-        uint8 CheckForms();
-        enum CheckForms_ReturnValues
-        {
-            RETURN_FAIL = 0,
-            RETURN_FAIL_WAITINGONSELFBUFF,
-            RETURN_OK_NOCHANGE,
-            RETURN_OK_SHIFTING,
-            RETURN_OK_CANNOTSHIFT
-        };
-
-        // druid cat/bear/dire bear/moonkin/tree of life forms
-        uint32 CAT_FORM,
-               BEAR_FORM,
-               DIRE_BEAR_FORM,
-               MOONKIN_FORM,
-               TREE_OF_LIFE,
-               TRAVEL_FORM;
-
-        // druid cat attacks
-        uint32 CLAW,
-               COWER,
-               TIGERS_FURY,
-               RAKE,
-               RIP,
-               SHRED,
-               FEROCIOUS_BITE,
-               MAIM,
-               MANGLE,
-               MANGLE_CAT;
-
-        // druid bear/dire bear attacks & buffs
-        uint32 BASH,
-               MAUL,
-               SWIPE,
-               DEMORALIZING_ROAR,
-               CHALLENGING_ROAR,
-               GROWL,
-               ENRAGE,
-               FAERIE_FIRE_FERAL,
-               MANGLE_BEAR,
-               LACERATE;
-
-        // druid caster DPS attacks & debuffs
-        uint32 MOONFIRE,
-               ROOTS,
-               WRATH,
-               OMEN_OF_CLARITY,
-               STARFIRE,
-               INSECT_SWARM,
-               FAERIE_FIRE,
-               FORCE_OF_NATURE,
-               HURRICANE,
-               HIBERNATE;
-
-        // druid buffs
-        uint32 MARK_OF_THE_WILD,
-               GIFT_OF_THE_WILD,
-               THORNS,
-               INNERVATE,
-               NATURES_SWIFTNESS,
-               BARKSKIN;
-
-        // druid heals
-        uint32 LIFEBLOOM,
-               REJUVENATION,
-               REGROWTH,
-               HEALING_TOUCH,
-               SWIFTMEND,
-               TRANQUILITY,
-               REBIRTH,
-               REMOVE_CURSE,
-               CURE_POISON,
-               ABOLISH_POISON;
-
-        // racial
-        uint32 ARCANE_TORRENT,
-               GIFT_OF_THE_NAARU,
-               STONEFORM,
-               ESCAPE_ARTIST,
-               PERCEPTION,
-               SHADOWMELD,
-               BLOOD_FURY,
-               WAR_STOMP,
-               BERSERKING,
-               WILL_OF_THE_FORSAKEN;
-
-        uint32 SpellSequence, DruidSpellCombat;
-};
-
-#endif
diff --git a/src/game/PlayerBot/AI/PlayerbotHunterAI.cpp b/src/game/PlayerBot/AI/PlayerbotHunterAI.cpp
deleted file mode 100644
index 0afb8caa9..000000000
--- a/src/game/PlayerBot/AI/PlayerbotHunterAI.cpp
+++ /dev/null
@@ -1,522 +0,0 @@
-/*
- * This file is part of the CMaNGOS Project. See AUTHORS file for Copyright information
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "PlayerbotHunterAI.h"
-#include "../Base/PlayerbotMgr.h"
-
-class PlayerbotAI;
-
-PlayerbotHunterAI::PlayerbotHunterAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
-{
-    // PET CTRL
-    PET_SUMMON                    = m_ai->initSpell(CALL_PET_1);
-    PET_DISMISS                   = m_ai->initSpell(DISMISS_PET_1);
-    PET_REVIVE                    = m_ai->initSpell(REVIVE_PET_1);
-    PET_MEND                      = m_ai->initSpell(MEND_PET_1);
-    PET_FEED                      = 1539;
-
-    BESTIAL_WRATH                 = m_ai->initSpell(BESTIAL_WRATH_1);
-
-    INTIMIDATION                  = m_ai->initSpell(INTIMIDATION_1); // (generic)
-
-    // PET SKILLS must be initialized by pets
-    SONIC_BLAST                   = 0; // bat
-    DEMORALIZING_SCREECH          = 0;
-    BAD_ATTITUDE                  = 0; // crocolisk
-
-    // RANGED COMBAT
-    AUTO_SHOT                     = m_ai->initSpell(AUTO_SHOT_1);
-    HUNTERS_MARK                  = m_ai->initSpell(HUNTERS_MARK_1);
-    ARCANE_SHOT                   = m_ai->initSpell(ARCANE_SHOT_1);
-    CONCUSSIVE_SHOT               = m_ai->initSpell(CONCUSSIVE_SHOT_1);
-    DISTRACTING_SHOT              = m_ai->initSpell(DISTRACTING_SHOT_1);
-    MULTI_SHOT                    = m_ai->initSpell(MULTISHOT_1);
-    SERPENT_STING                 = m_ai->initSpell(SERPENT_STING_1);
-    SCORPID_STING                 = m_ai->initSpell(SCORPID_STING_1);
-    WYVERN_STING                  = m_ai->initSpell(WYVERN_STING_1);
-    VIPER_STING                   = m_ai->initSpell(VIPER_STING_1);
-    AIMED_SHOT                    = m_ai->initSpell(AIMED_SHOT_1);
-    VOLLEY                        = m_ai->initSpell(VOLLEY_1);
-    BLACK_ARROW                   = m_ai->initSpell(BLACK_ARROW_1);
-    TRANQUILIZING_SHOT            = m_ai->initSpell(TRANQUILIZING_SHOT_1);
-
-    // MELEE
-    RAPTOR_STRIKE                 = m_ai->initSpell(RAPTOR_STRIKE_1);
-    WING_CLIP                     = m_ai->initSpell(WING_CLIP_1);
-    MONGOOSE_BITE                 = m_ai->initSpell(MONGOOSE_BITE_1);
-    DISENGAGE                     = m_ai->initSpell(DISENGAGE_1);
-    MISDIRECTION                  = m_ai->initSpell(MISDIRECTION_1);
-    DETERRENCE                    = m_ai->initSpell(DETERRENCE_1);
-    FEIGN_DEATH                   = m_ai->initSpell(FEIGN_DEATH_1);
-
-    // TRAPS
-    FREEZING_TRAP                 = m_ai->initSpell(FREEZING_TRAP_1);
-    IMMOLATION_TRAP               = m_ai->initSpell(IMMOLATION_TRAP_1);
-    FROST_TRAP                    = m_ai->initSpell(FROST_TRAP_1);
-    EXPLOSIVE_TRAP                = m_ai->initSpell(EXPLOSIVE_TRAP_1);
-    SNAKE_TRAP                    = m_ai->initSpell(SNAKE_TRAP_1);
-
-    // BUFFS
-    ASPECT_OF_THE_HAWK            = m_ai->initSpell(ASPECT_OF_THE_HAWK_1);
-    ASPECT_OF_THE_MONKEY          = m_ai->initSpell(ASPECT_OF_THE_MONKEY_1);
-    RAPID_FIRE                    = m_ai->initSpell(RAPID_FIRE_1);
-    TRUESHOT_AURA                 = m_ai->initSpell(TRUESHOT_AURA_1);
-
-    RECENTLY_BANDAGED             = 11196; // first aid check
-
-    // racial
-    ARCANE_TORRENT                = m_ai->initSpell(ARCANE_TORRENT_MANA_CLASSES);
-    GIFT_OF_THE_NAARU             = m_ai->initSpell(GIFT_OF_THE_NAARU_ALL); // draenei
-    STONEFORM                     = m_ai->initSpell(STONEFORM_ALL); // dwarf
-    SHADOWMELD                    = m_ai->initSpell(SHADOWMELD_ALL);
-    BLOOD_FURY                    = m_ai->initSpell(BLOOD_FURY_MELEE_CLASSES); // orc
-    WAR_STOMP                     = m_ai->initSpell(WAR_STOMP_ALL); // tauren
-    BERSERKING                    = m_ai->initSpell(BERSERKING_ALL); // troll
-
-    m_petSummonFailed = false;
-    m_rangedCombat = true;
-}
-
-PlayerbotHunterAI::~PlayerbotHunterAI() {}
-
-CombatManeuverReturns PlayerbotHunterAI::DoFirstCombatManeuver(Unit* pTarget)
-{
-    Player* m_bot = GetPlayerBot();
-    m_has_ammo = m_bot->HasItemCount(m_bot->GetUInt32Value(PLAYER_AMMO_ID), 1);
-    DEBUG_LOG("current ammo (%u)", m_bot->GetUInt32Value(PLAYER_AMMO_ID));
-    m_bot->setAttackTimer(RANGED_ATTACK, 0);
-    if (!m_has_ammo)
-    {
-        m_ai->FindAmmo();
-        //DEBUG_LOG("new ammo (%u)",m_bot->GetUInt32Value(PLAYER_AMMO_ID));
-        m_has_ammo = m_bot->HasItemCount(m_bot->GetUInt32Value(PLAYER_AMMO_ID), 1);
-    }
-    // There are NPCs in BGs and Open World PvP, so don't filter this on PvP scenarios (of course if PvP targets anyone but tank, all bets are off anyway)
-    // Wait until the tank says so, until any non-tank gains aggro or X seconds - whichever is shortest
-    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO)
-    {
-        if (m_WaitUntil > m_ai->CurrentTime() && m_ai->GroupTankHoldsAggro())
-        {
-            return RETURN_NO_ACTION_OK; // wait it out
-        }
-        else
-        {
-            m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO);
-        }
-    }
-
-    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TEMP_WAIT_OOC)
-    {
-        if (m_WaitUntil > m_ai->CurrentTime() && m_ai->IsGroupReady())
-            return RETURN_NO_ACTION_OK; // wait it out
-        else
-            m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_OOC);
-    }
-
-    switch (m_ai->GetScenarioType())
-    {
-        case PlayerbotAI::SCENARIO_PVP_DUEL:
-        case PlayerbotAI::SCENARIO_PVP_BG:
-        case PlayerbotAI::SCENARIO_PVP_ARENA:
-        case PlayerbotAI::SCENARIO_PVP_OPENWORLD:
-            return DoFirstCombatManeuverPVP(pTarget);
-        case PlayerbotAI::SCENARIO_PVE:
-        case PlayerbotAI::SCENARIO_PVE_ELITE:
-        case PlayerbotAI::SCENARIO_PVE_RAID:
-        default:
-            return DoFirstCombatManeuverPVE(pTarget);
-            break;
-    }
-
-    return RETURN_NO_ACTION_ERROR;
-}
-
-CombatManeuverReturns PlayerbotHunterAI::DoFirstCombatManeuverPVE(Unit* /*pTarget*/)
-{
-    return RETURN_NO_ACTION_OK;
-}
-
-bool PlayerbotHunterAI::HasPet(Player* bot)
-{
-    QueryResult* result = CharacterDatabase.PQuery("SELECT * FROM character_pet WHERE owner = '%u' AND (slot = '%u' OR slot = '%u')", bot->GetGUIDLow(), PET_SAVE_AS_CURRENT, PET_SAVE_NOT_IN_SLOT);
-
-    if (result)
-        return true;  //hunter has current pet
-    else
-        return false;  //hunter either has no pet or stabled
-} // end HasPet
-
-CombatManeuverReturns PlayerbotHunterAI::DoFirstCombatManeuverPVP(Unit* /*pTarget*/)
-{
-    return RETURN_NO_ACTION_OK;
-}
-
-CombatManeuverReturns PlayerbotHunterAI::DoNextCombatManeuver(Unit* pTarget)
-{
-    // Face enemy, make sure bot is attacking
-    m_ai->FaceTarget(pTarget);
-
-    switch (m_ai->GetScenarioType())
-    {
-        case PlayerbotAI::SCENARIO_PVP_DUEL:
-        case PlayerbotAI::SCENARIO_PVP_BG:
-        case PlayerbotAI::SCENARIO_PVP_ARENA:
-        case PlayerbotAI::SCENARIO_PVP_OPENWORLD:
-            return DoNextCombatManeuverPVP(pTarget);
-        case PlayerbotAI::SCENARIO_PVE:
-        case PlayerbotAI::SCENARIO_PVE_ELITE:
-        case PlayerbotAI::SCENARIO_PVE_RAID:
-        default:
-            return DoNextCombatManeuverPVE(pTarget);
-            break;
-    }
-
-    return RETURN_NO_ACTION_ERROR;
-}
-
-CombatManeuverReturns PlayerbotHunterAI::DoNextCombatManeuverPVE(Unit* pTarget)
-{
-    if (!m_ai)    return RETURN_NO_ACTION_ERROR;
-    if (!m_bot)   return RETURN_NO_ACTION_ERROR;
-    if (!pTarget) return RETURN_NO_ACTION_ERROR;
-
-    Unit* pVictim = pTarget->getVictim();
-
-    // check for pet and heal if neccessary
-    Pet* pet = m_bot->GetPet();
-    // TODO: clarify/simplify: !pet->getDeathState() != ALIVE
-    if (pet && PET_MEND > 0 && pet->isAlive() && pet->GetHealthPercent() < 50 && pVictim != m_bot && !pet->HasAura(PET_MEND, EFFECT_INDEX_0) && m_ai->CastSpell(PET_MEND, *m_bot))
-    {
-        m_ai->TellMaster("healing pet.");
-        return RETURN_CONTINUE;
-    }
-    else if (pet && INTIMIDATION > 0 && pVictim == pet && !pet->HasAura(INTIMIDATION, EFFECT_INDEX_0) && m_ai->CastSpell(INTIMIDATION, *m_bot))
-        return RETURN_CONTINUE;
-
-    /*    // racial traits
-        if (m_bot->getRace() == RACE_ORC && !m_bot->HasAura(BLOOD_FURY, EFFECT_INDEX_0))
-            m_ai->CastSpell(BLOOD_FURY, *m_bot);
-        else if (m_bot->getRace() == RACE_TROLL && !m_bot->HasAura(BERSERKING, EFFECT_INDEX_0))
-            m_ai->CastSpell(BERSERKING, *m_bot);
-    */
-    // check if ranged combat is possible: by default chose ranged combat
-    bool meleeReach = m_bot->CanReachWithMeleeAttack(pTarget);
-
-    if (!meleeReach && m_has_ammo)
-    {
-        // switch to ranged combat
-        m_rangedCombat = true;
-        m_ai->SetCombatStyle(PlayerbotAI::COMBAT_RANGED);
-
-        // increase ranged attack power...
-        if (ASPECT_OF_THE_HAWK > 0 && !m_bot->HasAura(ASPECT_OF_THE_HAWK, EFFECT_INDEX_0))
-            m_ai->CastSpell(ASPECT_OF_THE_HAWK, *m_bot);
-    }
-    else
-    {
-        // switch to melee combat (target in melee range, out of ammo)
-        m_rangedCombat = false;
-        m_ai->SetCombatStyle(PlayerbotAI::COMBAT_MELEE);
-        if (!m_bot->GetUInt32Value(PLAYER_AMMO_ID))
-            m_ai->TellMaster("Out of ammo!");
-
-        // become monkey (increases dodge chance)...
-        if (ASPECT_OF_THE_MONKEY > 0 && !m_bot->HasAura(ASPECT_OF_THE_MONKEY, EFFECT_INDEX_0))
-            m_ai->CastSpell(ASPECT_OF_THE_MONKEY, *m_bot);
-    }
-
-    if (TRANQUILIZING_SHOT > 0 && IsTargetEnraged(pTarget) && m_bot->IsSpellReady(TRANQUILIZING_SHOT) && m_ai->CastSpell(TRANQUILIZING_SHOT, *pTarget))
-    {
-        m_ai->TellMaster("Casting TRANQUILIZING SHOT onto %s", pTarget->GetName());
-        return RETURN_CONTINUE;
-    }
-
-    //Used to determine if this bot has highest threat
-    Unit* newTarget = m_ai->FindAttacker((PlayerbotAI::ATTACKERINFOTYPE)(PlayerbotAI::AIT_VICTIMSELF | PlayerbotAI::AIT_HIGHESTTHREAT), m_bot);
-    // Aggro management
-    if (newTarget && !m_ai->IsNeutralized(newTarget)) // TODO: && party has a tank
-    {
-        // Aggroed by an elite
-        if (m_ai->IsElite(newTarget))
-        {
-            // Try to disengage
-            if (DISENGAGE > 0 && m_bot->IsSpellReady(DISENGAGE) && m_ai->In_Reach(newTarget, DISENGAGE) && m_ai->CastSpell(DISENGAGE, *newTarget))
-                return RETURN_CONTINUE;
-            // Increase dodge and parry chance
-            if (DETERRENCE > 0 && m_bot->IsSpellReady(DETERRENCE) && !m_bot->HasAura(DETERRENCE, EFFECT_INDEX_0) && m_ai->CastSpell(DETERRENCE, *m_bot))
-                return RETURN_CONTINUE;
-            // Else feign death if low on health or attacked by a worldboss
-            if (FEIGN_DEATH > 0 && (m_ai->GetHealthPercent() <= 20 || m_ai->IsElite(pTarget, true)) && m_bot->IsSpellReady(FEIGN_DEATH) && !m_bot->HasAura(FEIGN_DEATH, EFFECT_INDEX_0) && m_ai->CastSpell(FEIGN_DEATH, *m_bot))
-                return RETURN_CONTINUE;
-        }
-    }
-
-    // Distance management: avoid to be in the dead zone where neither melee nor range can be used: keep distance whenever possible
-    // If not in range: come closer
-    // Do not do it if passive or stay orders.
-    if (pTarget && !m_ai->In_Reach(pTarget, AUTO_SHOT) &&
-            !(m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_PASSIVE) &&
-            (m_bot->GetPlayerbotAI()->GetMovementOrder() != PlayerbotAI::MOVEMENT_STAY))
-    {
-        m_ai->InterruptCurrentCastingSpell();
-        m_bot->GetMotionMaster()->MoveFollow(pTarget, 39.0f, m_bot->GetOrientation());
-        return RETURN_CONTINUE;
-    }
-    // If below ranged combat distance and bot is not attacked by target
-    // make it flee from target for a few seconds to get in ranged distance again
-    // Do not do it if passive or stay orders.
-    if (pVictim != m_bot && m_bot->GetDistance(pTarget, true, DIST_CALC_COMBAT_REACH_WITH_MELEE) <= 8.0f &&
-            !(m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_PASSIVE) &&
-            (m_bot->GetPlayerbotAI()->GetMovementOrder() != PlayerbotAI::MOVEMENT_STAY))
-    {
-        m_ai->InterruptCurrentCastingSpell();
-        m_ai->SetIgnoreUpdateTime(2);
-        m_bot->GetMotionMaster()->Clear(false);
-        m_bot->GetMotionMaster()->MoveFleeing(pTarget, 2);
-        return RETURN_CONTINUE;
-    }
-
-    // damage spells
-    if (m_ai->GetCombatStyle() == PlayerbotAI::COMBAT_RANGED)
-    {
-        // Debuff target
-        if (HUNTERS_MARK > 0 && m_ai->In_Reach(pTarget, HUNTERS_MARK) && !pTarget->HasAura(HUNTERS_MARK, EFFECT_INDEX_0) && m_ai->CastSpell(HUNTERS_MARK, *pTarget))
-            return RETURN_CONTINUE;
-        // Buff self
-        if (RAPID_FIRE > 0 && !m_bot->HasAura(RAPID_FIRE, EFFECT_INDEX_0) && m_bot->IsSpellReady(RAPID_FIRE) && m_ai->CastSpell(RAPID_FIRE, *m_bot))
-            return RETURN_CONTINUE;
-        if (ARCANE_SHOT > 0 && m_bot->IsSpellReady(ARCANE_SHOT) && m_ai->In_Range(pTarget, ARCANE_SHOT) && m_ai->CastSpell(ARCANE_SHOT, *pTarget))
-            return RETURN_CONTINUE;
-        // Stings: only use Viper and Serpent sting. Stats decrease (Scorpid Sting) is useless in PvE
-        // and as the bot is obviously not alone and assisting someone, no need to put the target to sleep (Wyvern Sting)
-        // Viper sting for non-worldboss mana users
-        if (pTarget->GetPower(POWER_MANA) > 0 && !m_ai->IsElite(pTarget, true))
-        {
-            if (VIPER_STING > 0 && m_ai->In_Range(pTarget, VIPER_STING) && !pTarget->HasAura(VIPER_STING, EFFECT_INDEX_0) && m_ai->CastSpell(VIPER_STING, *pTarget))
-                return RETURN_CONTINUE;
-        }
-        // Serpent sting for everyone else
-        else
-        {
-            if (SERPENT_STING > 0 && m_ai->In_Range(pTarget, SERPENT_STING) && !pTarget->HasAura(SERPENT_STING, EFFECT_INDEX_0) && m_ai->CastSpell(SERPENT_STING, *pTarget))
-                return RETURN_CONTINUE;
-        }
-        if (CONCUSSIVE_SHOT > 0 && m_ai->In_Range(pTarget, CONCUSSIVE_SHOT) && !pTarget->HasAura(CONCUSSIVE_SHOT, EFFECT_INDEX_0) && m_ai->CastSpell(CONCUSSIVE_SHOT, *pTarget))
-            return RETURN_CONTINUE;
-        if (BLACK_ARROW > 0 && m_ai->In_Range(pTarget, BLACK_ARROW) && !pTarget->HasAura(BLACK_ARROW, EFFECT_INDEX_0) && m_ai->CastSpell(BLACK_ARROW, *pTarget))
-            return RETURN_CONTINUE;
-        if (AIMED_SHOT > 0 && m_bot->IsSpellReady(AIMED_SHOT) && m_ai->In_Range(pTarget, AIMED_SHOT) && m_ai->CastSpell(AIMED_SHOT, *pTarget))
-            return RETURN_CONTINUE;
-
-//       if (MULTI_SHOT > 0 && m_bot->IsSpellReady(MULTI_SHOT) && m_ai->In_Range(pTarget,MULTI_SHOT) && m_ai->GetAttackerCount() >= 3 && m_ai->CastSpell(MULTI_SHOT, *pTarget))
-//            return RETURN_CONTINUE;
-//       if (VOLLEY > 0 && m_ai->In_Range(pTarget,VOLLEY) && m_ai->GetAttackerCount() >= 3 && m_ai->CastSpell(VOLLEY, *pTarget))
-//           return RETURN_CONTINUE;
-
-        // Auto shot
-        // m_ai->TellMaster("target dist %f",m_bot->GetCombatDistance(pTarget,true));
-        if (AUTO_SHOT > 0)
-        {
-            if (m_bot->isAttackReady(RANGED_ATTACK))
-                m_bot->CastSpell(pTarget, AUTO_SHOT, TRIGGERED_OLD_TRIGGERED);
-
-            const SpellEntry* spellInfo = sSpellTemplate.LookupEntry<SpellEntry>(AUTO_SHOT);
-            if (!spellInfo)
-                return RETURN_CONTINUE;
-
-            if (!m_ai->CheckBotCast(spellInfo))
-                m_bot->InterruptNonMeleeSpells(true, AUTO_SHOT);
-
-            return RETURN_CONTINUE;
-        }
-
-        return RETURN_NO_ACTION_OK;
-    }
-    else
-    {
-        if (MONGOOSE_BITE > 0 && m_bot->RollMeleeOutcomeAgainst(pTarget, BASE_ATTACK, SPELL_SCHOOL_MASK_NORMAL) == MELEE_HIT_DODGE && m_ai->CastSpell(MONGOOSE_BITE, *pTarget))
-            return RETURN_CONTINUE;
-        if (RAPTOR_STRIKE > 0 && m_bot->IsSpellReady(RAPTOR_STRIKE) && m_ai->In_Reach(pTarget, RAPTOR_STRIKE) && m_ai->CastSpell(RAPTOR_STRIKE, *pTarget))
-            return RETURN_CONTINUE;
-        if (EXPLOSIVE_TRAP > 0 && !pTarget->HasAura(EXPLOSIVE_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(IMMOLATION_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(FROST_TRAP, EFFECT_INDEX_0) && m_ai->CastSpell(EXPLOSIVE_TRAP, *pTarget))
-            return RETURN_CONTINUE;
-        if (WING_CLIP > 0 && m_bot->IsSpellReady(WING_CLIP) && m_ai->In_Reach(pTarget, WING_CLIP) && !pTarget->HasAura(WING_CLIP, EFFECT_INDEX_0) && m_ai->CastSpell(WING_CLIP, *pTarget))
-            return RETURN_CONTINUE;
-        if (IMMOLATION_TRAP > 0 && !pTarget->HasAura(IMMOLATION_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(EXPLOSIVE_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(FROST_TRAP, EFFECT_INDEX_0) && m_ai->CastSpell(IMMOLATION_TRAP, *pTarget))
-            return RETURN_CONTINUE;
-        if (FROST_TRAP > 0 && !pTarget->HasAura(FROST_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(IMMOLATION_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(EXPLOSIVE_TRAP, EFFECT_INDEX_0) && m_ai->CastSpell(FROST_TRAP, *pTarget))
-            return RETURN_CONTINUE;
-        else if (m_bot->getRace() == RACE_DRAENEI && m_ai->GetHealthPercent() < 25 && !m_bot->HasAura(GIFT_OF_THE_NAARU, EFFECT_INDEX_0) && m_ai->CastSpell(GIFT_OF_THE_NAARU, *m_bot))
-            return RETURN_CONTINUE;
-        else if (pet && pet->isAlive() && MISDIRECTION > 0 && pVictim == m_bot && !m_bot->HasAura(MISDIRECTION, EFFECT_INDEX_0) && m_ai->CastSpell(MISDIRECTION, *pet))
-            return RETURN_CONTINUE;
-//        if (m_bot->getRace() == RACE_TAUREN && !pTarget->HasAura(WAR_STOMP, EFFECT_INDEX_0) && m_ai->CastSpell(WAR_STOMP, *pTarget))
-//            return RETURN_CONTINUE;
-//        else if (m_bot->getRace() == RACE_DWARF && m_bot->HasAuraState(AURA_STATE_DEADLY_POISON) && m_ai->CastSpell(STONEFORM, *m_bot))
-//            return RETURN_CONTINUE;
-
-        /*else if(FREEZING_TRAP > 0 && !pTarget->HasAura(FREEZING_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(ARCANE_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(EXPLOSIVE_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(BEAR_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(IMMOLATION_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(FROST_TRAP, EFFECT_INDEX_0) && m_ai->CastSpell(FREEZING_TRAP,*pTarget) )
-            out << " > Freezing Trap"; // this can trap your bots too
-        */
-    }
-
-    return RETURN_NO_ACTION_OK;
-} // end DoNextCombatManeuver
-
-CombatManeuverReturns PlayerbotHunterAI::DoNextCombatManeuverPVP(Unit* pTarget)
-{
-    if (m_ai->CastSpell(RAPTOR_STRIKE))
-        return RETURN_CONTINUE;
-
-    return DoNextCombatManeuverPVE(pTarget); // TODO: bad idea perhaps, but better than the alternative
-}
-
-bool PlayerbotHunterAI::IsTargetEnraged(Unit* pTarget)
-{
-    if (!m_ai)  return false;
-    if (!m_bot) return false;
-    if (!pTarget) return false;
-
-    Unit::SpellAuraHolderMap const& auras = pTarget->GetSpellAuraHolderMap();
-    for (Unit::SpellAuraHolderMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
-    {
-        SpellAuraHolder* holder = itr->second;
-        // Return true is target unit has aura with DISPEL_ENRAGE dispel type
-        if ((1 << holder->GetSpellProto()->Dispel) & GetDispellMask(DISPEL_ENRAGE))
-            return true;
-    }
-
-    return false;
-}
-
-void PlayerbotHunterAI::DoNonCombatActions()
-{
-    if (!m_ai)  return;
-    if (!m_bot) return;
-
-    if (!m_rangedCombat || m_ai->GetCombatStyle() == PlayerbotAI::COMBAT_MELEE)
-    {
-        m_rangedCombat = true;
-        m_ai->SetCombatStyle(PlayerbotAI::COMBAT_RANGED);
-    }
-
-    // buff group
-    if (TRUESHOT_AURA > 0 && !m_bot->HasAura(TRUESHOT_AURA, EFFECT_INDEX_0))
-        m_ai->CastSpell(TRUESHOT_AURA, *m_bot);
-
-    // buff myself
-    if (ASPECT_OF_THE_HAWK > 0 && !m_bot->HasAura(ASPECT_OF_THE_HAWK, EFFECT_INDEX_0))
-        m_ai->CastSpell(ASPECT_OF_THE_HAWK, *m_bot);
-
-    // hp/mana check
-    if (EatDrinkBandage())
-        return;
-
-    // check for pet
-    if (PET_SUMMON > 0 && !m_petSummonFailed && m_bot->GetPetGuid())
-    {
-        // we can summon pet, and no critical summon errors before
-        Pet* pet = m_bot->GetPet();
-        if (!pet)
-        {
-            // summon pet
-            if (PET_SUMMON > 0 && m_ai->CastSpell(PET_SUMMON, *m_bot))
-                m_ai->TellMaster("summoning pet.");
-            else
-            {
-                m_petSummonFailed = true;
-                m_ai->TellMaster("summon pet failed!");
-            }
-        }
-        else if (!(pet->isAlive()))
-        {
-            if (PET_REVIVE > 0 && m_ai->CastSpell(PET_REVIVE, *m_bot))
-                m_ai->TellMaster("reviving pet.");
-        }
-        else if (pet->GetHealthPercent() < 50)
-        {
-            if (PET_MEND > 0 && pet->isAlive() && !pet->HasAura(PET_MEND, EFFECT_INDEX_0) && m_ai->CastSpell(PET_MEND, *m_bot))
-                m_ai->TellMaster("healing pet.");
-        }
-        else if (pet->GetHappinessState() != HAPPY) // if pet is hungry
-        {
-            Unit* caster = (Unit*) m_bot;
-            // list out items in main backpack
-            for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
-            {
-                Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
-                if (pItem)
-                {
-                    const ItemPrototype* const pItemProto = pItem->GetProto();
-                    if (!pItemProto)
-                        continue;
-
-                    if (pet->HaveInDiet(pItemProto)) // is pItem in pets diet
-                    {
-                        // DEBUG_LOG ("[PlayerbotHunterAI]: DoNonCombatActions - Food for pet: %s",pItemProto->Name1);
-                        // caster->CastSpell(caster, 23355, TRIGGERED_OLD_TRIGGERED); // pet feed visual
-                        uint32 count = 1; // number of items used
-                        int32 benefit = pet->GetCurrentFoodBenefitLevel(pItemProto->ItemLevel) * 15; // nutritional value of food
-                        DEBUG_LOG("FEED_PET benefit (%i)", benefit);
-                        m_bot->DestroyItemCount(pItem, count, true); // remove item from inventory
-                        m_bot->CastCustomSpell(m_bot, PET_FEED, &benefit, nullptr, nullptr, TRIGGERED_OLD_TRIGGERED); // feed pet
-                        m_ai->TellMaster("feeding pet.");
-                        m_ai->SetIgnoreUpdateTime(10);
-                        return;
-                    }
-                }
-            }
-            // list out items in other removable backpacks
-            for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
-            {
-                const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
-                if (pBag)
-                    for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
-                    {
-                        Item* const pItem = m_bot->GetItemByPos(bag, slot);
-                        if (pItem)
-                        {
-                            const ItemPrototype* const pItemProto = pItem->GetProto();
-                            if (!pItemProto)
-                                continue;
-
-                            if (pet->HaveInDiet(pItemProto)) // is pItem in pets diet
-                            {
-                                // DEBUG_LOG ("[PlayerbotHunterAI]: DoNonCombatActions - Food for pet: %s",pItemProto->Name1);
-                                // caster->CastSpell(caster, 23355, TRIGGERED_OLD_TRIGGERED); // pet feed visual
-                                uint32 count = 1; // number of items used
-                                int32 benefit = pet->GetCurrentFoodBenefitLevel(pItemProto->ItemLevel) * 15; // nutritional value of food
-                                m_bot->DestroyItemCount(pItem, count, true); // remove item from inventory
-                                m_bot->CastCustomSpell(m_bot, PET_FEED, &benefit, nullptr, nullptr, TRIGGERED_OLD_TRIGGERED); // feed pet
-                                m_ai->TellMaster("feeding pet.");
-                                m_ai->SetIgnoreUpdateTime(10);
-                                return;
-                            }
-                        }
-                    }
-            }
-            if (pet->HasAura(PET_MEND, EFFECT_INDEX_0) && !pet->HasAura(PET_FEED, EFFECT_INDEX_0))
-                m_ai->TellMaster("..no pet food!");
-            m_ai->SetIgnoreUpdateTime(7);
-        }
-    }
-
-    // Nothing else to do, Night Elves will cast Shadowmeld to reduce their aggro versus patrols or nearby mobs
-    if (SHADOWMELD && !m_bot->HasAura(SHADOWMELD, EFFECT_INDEX_0) && m_ai->CastSpell(SHADOWMELD, *m_bot))
-        return;
-} // end DoNonCombatActions
diff --git a/src/game/PlayerBot/AI/PlayerbotHunterAI.h b/src/game/PlayerBot/AI/PlayerbotHunterAI.h
deleted file mode 100644
index bc9b71085..000000000
--- a/src/game/PlayerBot/AI/PlayerbotHunterAI.h
+++ /dev/null
@@ -1,186 +0,0 @@
-/*
- * This file is part of the CMaNGOS Project. See AUTHORS file for Copyright information
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _PLAYERHUNTERAI_H
-#define _PLAYERHUNTERAI_H
-
-#include "../Base/PlayerbotClassAI.h"
-#include "../Spells/Spell.h"
-
-enum
-{
-    SPELL_HUNTER
-};
-
-enum HunterSpells
-{
-    ARCANE_SHOT_1                   = 3044,
-    ASPECT_OF_THE_BEAST_1           = 13161,
-    ASPECT_OF_THE_CHEETAH_1         = 5118,
-    ASPECT_OF_THE_HAWK_1            = 13165,
-    ASPECT_OF_THE_MONKEY_1          = 13163,
-    ASPECT_OF_THE_PACK_1            = 13159,
-    ASPECT_OF_THE_VIPER_1           = 34074,
-    ASPECT_OF_THE_WILD_1            = 20043,
-    AUTO_SHOT_1                     = 75,
-    BEAST_LORE_1                    = 1462,
-    CALL_PET_1                      = 883,
-    CONCUSSIVE_SHOT_1               = 5116,
-    DETERRENCE_1                    = 19263,
-    DISENGAGE_1                     = 781,
-    DISMISS_PET_1                   = 2641,
-    DISTRACTING_SHOT_1              = 20736,
-    EAGLE_EYE_1                     = 6197,
-    EXPLOSIVE_TRAP_1                = 13813,
-    EYES_OF_THE_BEAST_1             = 1002,
-    FEED_PET_1                      = 6991,
-    FEIGN_DEATH_1                   = 5384,
-    FLARE_1                         = 1543,
-    FREEZING_TRAP_1                 = 1499,
-    FROST_TRAP_1                    = 13809,
-    HUNTERS_MARK_1                  = 1130,
-    IMMOLATION_TRAP_1               = 13795,
-    KILL_COMMAND_1                  = 34026,
-    MEND_PET_1                      = 136,
-    MISDIRECTION_1                  = 34477,
-    MONGOOSE_BITE_1                 = 1495,
-    MULTISHOT_1                     = 2643,
-    RAPID_FIRE_1                    = 3045,
-    RAPTOR_STRIKE_1                 = 2973,
-    REVIVE_PET_1                    = 982,
-    SCARE_BEAST_1                   = 1513,
-    SCORPID_STING_1                 = 3043,
-    SERPENT_STING_1                 = 1978,
-    SNAKE_TRAP_1                    = 34600,
-    TAME_BEAST_1                    = 1515,
-    TRACK_BEASTS_1                  = 1494,
-    TRACK_DEMONS_1                  = 19878,
-    TRACK_DRAGONKIN_1               = 19879,
-    TRACK_ELEMENTALS_1              = 19880,
-    TRACK_GIANTS_1                  = 19882,
-    TRACK_HIDDEN_1                  = 19885,
-    TRACK_HUMANOIDS_1               = 19883,
-    TRACK_UNDEAD_1                  = 19884,
-    TRANQUILIZING_SHOT_1            = 19801,
-    VIPER_STING_1                   = 3034,
-    VOLLEY_1                        = 1510,
-    WING_CLIP_1                     = 2974,
-    AIMED_SHOT_1                    = 19434,
-    BESTIAL_WRATH_1                 = 19574,
-    BLACK_ARROW_1                   = 3674,
-    COUNTERATTACK_1                 = 19306,
-    INTIMIDATION_1                  = 19577,
-    READINESS_1                     = 23989,
-    SCATTER_SHOT_1                  = 19503,
-    SILENCING_SHOT_1                = 34490,
-    TRUESHOT_AURA_1                 = 19506,
-    WYVERN_STING_1                  = 19386
-};
-
-//class Player;
-
-class PlayerbotHunterAI : PlayerbotClassAI
-{
-    public:
-        PlayerbotHunterAI(Player* const master, Player* const bot, PlayerbotAI* const ai);
-        virtual ~PlayerbotHunterAI();
-        bool HasPet(Player* bot);
-
-        // all combat actions go here
-        CombatManeuverReturns DoFirstCombatManeuver(Unit* pTarget);
-        CombatManeuverReturns DoNextCombatManeuver(Unit* pTarget);
-
-        // all non combat actions go here, ex buffs, heals, rezzes
-        void DoNonCombatActions();
-
-        // buff a specific player, usually a real PC who is not in group
-        //void BuffPlayer(Player *target);
-
-    private:
-        CombatManeuverReturns DoFirstCombatManeuverPVE(Unit* pTarget);
-        CombatManeuverReturns DoNextCombatManeuverPVE(Unit* pTarget);
-        CombatManeuverReturns DoFirstCombatManeuverPVP(Unit* pTarget);
-        CombatManeuverReturns DoNextCombatManeuverPVP(Unit* pTarget);
-
-        // Hunter
-        bool IsTargetEnraged(Unit* pTarget);
-        bool m_petSummonFailed;
-        bool m_rangedCombat;
-        bool m_has_ammo;
-
-        uint32 PET_SUMMON,
-               PET_DISMISS,
-               PET_REVIVE,
-               PET_MEND,
-               PET_FEED,
-               BESTIAL_WRATH,
-               BAD_ATTITUDE,
-               SONIC_BLAST,
-               DEMORALIZING_SCREECH,
-               INTIMIDATION;
-
-        uint32 AUTO_SHOT,
-               HUNTERS_MARK,
-               ARCANE_SHOT,
-               CONCUSSIVE_SHOT,
-               DISTRACTING_SHOT,
-               MULTI_SHOT,
-               SERPENT_STING,
-               SCORPID_STING,
-               VIPER_STING,
-               WYVERN_STING,
-               AIMED_SHOT,
-               VOLLEY,
-               BLACK_ARROW,
-               TRANQUILIZING_SHOT;
-
-        uint32 RAPTOR_STRIKE,
-               WING_CLIP,
-               MONGOOSE_BITE,
-               DISENGAGE,
-               DETERRENCE,
-               FEIGN_DEATH;
-
-        uint32 BEAR_TRAP,
-               FREEZING_TRAP,
-               IMMOLATION_TRAP,
-               FROST_TRAP,
-               EXPLOSIVE_TRAP,
-               ARCANE_TRAP,
-               SNAKE_TRAP;
-
-        uint32 ASPECT_OF_THE_HAWK,
-               ASPECT_OF_THE_MONKEY,
-               RAPID_FIRE,
-               TRUESHOT_AURA,
-               MISDIRECTION;
-
-        // racial
-        uint32 ARCANE_TORRENT,
-               GIFT_OF_THE_NAARU,
-               STONEFORM,
-               ESCAPE_ARTIST,
-               PERCEPTION,
-               SHADOWMELD,
-               BLOOD_FURY,
-               WAR_STOMP,
-               BERSERKING,
-               WILL_OF_THE_FORSAKEN;
-};
-
-#endif
diff --git a/src/game/PlayerBot/AI/PlayerbotMageAI.cpp b/src/game/PlayerBot/AI/PlayerbotMageAI.cpp
deleted file mode 100644
index 6d174f973..000000000
--- a/src/game/PlayerBot/AI/PlayerbotMageAI.cpp
+++ /dev/null
@@ -1,539 +0,0 @@
-/*
- * This file is part of the CMaNGOS Project. See AUTHORS file for Copyright information
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "PlayerbotMageAI.h"
-
-class PlayerbotAI;
-
-PlayerbotMageAI::PlayerbotMageAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
-{
-    ARCANE_MISSILES         = m_ai->initSpell(ARCANE_MISSILES_1);
-    ARCANE_EXPLOSION        = m_ai->initSpell(ARCANE_EXPLOSION_1);
-    COUNTERSPELL            = m_ai->initSpell(COUNTERSPELL_1);
-    SLOW                    = m_ai->initSpell(SLOW_1);
-    ARCANE_BLAST            = m_ai->initSpell(ARCANE_BLAST_1);
-    ARCANE_POWER            = m_ai->initSpell(ARCANE_POWER_1);
-    DAMPEN_MAGIC            = m_ai->initSpell(DAMPEN_MAGIC_1);
-    AMPLIFY_MAGIC           = m_ai->initSpell(AMPLIFY_MAGIC_1);
-    MAGE_ARMOR              = m_ai->initSpell(MAGE_ARMOR_1);
-    ARCANE_INTELLECT        = m_ai->initSpell(ARCANE_INTELLECT_1);
-    ARCANE_BRILLIANCE       = m_ai->initSpell(ARCANE_BRILLIANCE_1);
-    MANA_SHIELD             = m_ai->initSpell(MANA_SHIELD_1);
-    CONJURE_WATER           = m_ai->initSpell(CONJURE_WATER_1);
-    CONJURE_FOOD            = m_ai->initSpell(CONJURE_FOOD_1);
-    CONJURE_MANA_GEM        = m_ai->initSpell(CONJURE_MANA_GEM_1);
-    EVOCATION               = m_ai->initSpell(EVOCATION_1);
-    FIREBALL                = m_ai->initSpell(FIREBALL_1);
-    FIRE_BLAST              = m_ai->initSpell(FIRE_BLAST_1);
-    FLAMESTRIKE             = m_ai->initSpell(FLAMESTRIKE_1);
-    SCORCH                  = m_ai->initSpell(SCORCH_1);
-    POLYMORPH               = m_ai->initSpell(POLYMORPH_1);
-    PRESENCE_OF_MIND        = m_ai->initSpell(PRESENCE_OF_MIND_1);
-    PYROBLAST               = m_ai->initSpell(PYROBLAST_1);
-    BLAST_WAVE              = m_ai->initSpell(BLAST_WAVE_1);
-    COMBUSTION              = m_ai->initSpell(COMBUSTION_1);
-    DRAGONS_BREATH          = m_ai->initSpell(DRAGONS_BREATH_1);
-    FIRE_WARD               = m_ai->initSpell(FIRE_WARD_1);
-    MOLTEN_ARMOR            = m_ai->initSpell(MOLTEN_ARMOR_1);
-    ICY_VEINS               = m_ai->initSpell(ICY_VEINS_1);
-    FROSTBOLT               = m_ai->initSpell(FROSTBOLT_1);
-    FROST_NOVA              = m_ai->initSpell(FROST_NOVA_1);
-    BLIZZARD                = m_ai->initSpell(BLIZZARD_1);
-    CONE_OF_COLD            = m_ai->initSpell(CONE_OF_COLD_1);
-    ICE_BARRIER             = m_ai->initSpell(ICE_BARRIER_1);
-    SUMMON_WATER_ELEMENTAL  = m_ai->initSpell(SUMMON_WATER_ELEMENTAL_1);
-    FROST_WARD              = m_ai->initSpell(FROST_WARD_1);
-    ICE_LANCE               = m_ai->initSpell(ICE_LANCE_1);
-    FROST_ARMOR             = m_ai->initSpell(FROST_ARMOR_1);
-    ICE_ARMOR               = m_ai->initSpell(ICE_ARMOR_1);
-    ICE_BLOCK               = m_ai->initSpell(ICE_BLOCK_1);
-    COLD_SNAP               = m_ai->initSpell(COLD_SNAP_1);
-    MAGE_REMOVE_CURSE       = m_ai->initSpell(REMOVE_CURSE_MAGE_1);
-
-    // TALENTS
-    IMPROVED_SCORCH         = 0;
-    for (uint8 i = 0; i < 3; i++)
-    {
-        if (m_ai->initSpell(uiImprovedScorch[i]))
-            IMPROVED_SCORCH = m_ai->initSpell(uiImprovedScorch[i]);
-    }
-    FIRE_VULNERABILITY      = 22959;
-
-    // RANGED COMBAT
-    SHOOT                   = m_ai->initSpell(SHOOT_2);
-
-    RECENTLY_BANDAGED       = 11196; // first aid check
-
-    // racial
-    ARCANE_TORRENT          = m_ai->initSpell(ARCANE_TORRENT_MANA_CLASSES); // blood elf
-    GIFT_OF_THE_NAARU       = m_ai->initSpell(GIFT_OF_THE_NAARU_ALL); // draenei
-    ESCAPE_ARTIST           = m_ai->initSpell(ESCAPE_ARTIST_ALL); // gnome
-    PERCEPTION              = m_ai->initSpell(PERCEPTION_ALL); // human
-    BERSERKING              = m_ai->initSpell(BERSERKING_ALL); // troll
-    WILL_OF_THE_FORSAKEN    = m_ai->initSpell(WILL_OF_THE_FORSAKEN_ALL); // undead
-}
-
-PlayerbotMageAI::~PlayerbotMageAI() {}
-
-CombatManeuverReturns PlayerbotMageAI::DoFirstCombatManeuver(Unit* pTarget)
-{
-    // There are NPCs in BGs and Open World PvP, so don't filter this on PvP scenarios (of course if PvP targets anyone but tank, all bets are off anyway)
-    // Wait until the tank says so, until any non-tank gains aggro or X seconds - whichever is shortest
-    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO)
-    {
-        if (m_WaitUntil > m_ai->CurrentTime() && m_ai->GroupTankHoldsAggro())
-        {
-            return RETURN_NO_ACTION_OK; // wait it out
-        }
-        else
-        {
-            m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO);
-        }
-    }
-
-    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TEMP_WAIT_OOC)
-    {
-        if (m_WaitUntil > m_ai->CurrentTime() && m_ai->IsGroupReady())
-            return RETURN_NO_ACTION_OK; // wait it out
-        else
-            m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_OOC);
-    }
-
-    switch (m_ai->GetScenarioType())
-    {
-        case PlayerbotAI::SCENARIO_PVP_DUEL:
-        case PlayerbotAI::SCENARIO_PVP_BG:
-        case PlayerbotAI::SCENARIO_PVP_ARENA:
-        case PlayerbotAI::SCENARIO_PVP_OPENWORLD:
-            return DoFirstCombatManeuverPVP(pTarget);
-        case PlayerbotAI::SCENARIO_PVE:
-        case PlayerbotAI::SCENARIO_PVE_ELITE:
-        case PlayerbotAI::SCENARIO_PVE_RAID:
-        default:
-            return DoFirstCombatManeuverPVE(pTarget);
-            break;
-    }
-
-    return RETURN_NO_ACTION_ERROR;
-}
-
-CombatManeuverReturns PlayerbotMageAI::DoFirstCombatManeuverPVE(Unit* /*pTarget*/)
-{
-    return RETURN_NO_ACTION_OK;
-}
-
-CombatManeuverReturns PlayerbotMageAI::DoFirstCombatManeuverPVP(Unit* /*pTarget*/)
-{
-    return RETURN_NO_ACTION_OK;
-}
-
-CombatManeuverReturns PlayerbotMageAI::DoNextCombatManeuver(Unit* pTarget)
-{
-    // Face enemy, make sure bot is attacking
-    m_ai->FaceTarget(pTarget);
-
-    switch (m_ai->GetScenarioType())
-    {
-        case PlayerbotAI::SCENARIO_PVP_DUEL:
-        case PlayerbotAI::SCENARIO_PVP_BG:
-        case PlayerbotAI::SCENARIO_PVP_ARENA:
-        case PlayerbotAI::SCENARIO_PVP_OPENWORLD:
-            return DoNextCombatManeuverPVP(pTarget);
-        case PlayerbotAI::SCENARIO_PVE:
-        case PlayerbotAI::SCENARIO_PVE_ELITE:
-        case PlayerbotAI::SCENARIO_PVE_RAID:
-        default:
-            return DoNextCombatManeuverPVE(pTarget);
-            break;
-    }
-
-    return RETURN_NO_ACTION_ERROR;
-}
-
-CombatManeuverReturns PlayerbotMageAI::DoNextCombatManeuverPVE(Unit* pTarget)
-{
-    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
-    if (!m_bot) return RETURN_NO_ACTION_ERROR;
-
-    Unit* pVictim = pTarget->getVictim();
-    bool meleeReach = m_bot->CanReachWithMeleeAttack(pTarget);
-
-    uint32 spec = m_bot->GetSpec();
-
-    if (m_ai->GetCombatStyle() != PlayerbotAI::COMBAT_RANGED && !meleeReach)
-        m_ai->SetCombatStyle(PlayerbotAI::COMBAT_RANGED);
-    // switch to melee if in melee range AND can't shoot OR have no ranged (wand) equipped
-    else if (m_ai->GetCombatStyle() != PlayerbotAI::COMBAT_MELEE
-             && meleeReach
-             && (SHOOT == 0 || !m_bot->GetWeaponForAttack(RANGED_ATTACK, true, true)))
-        m_ai->SetCombatStyle(PlayerbotAI::COMBAT_MELEE);
-
-    //Used to determine if this bot is highest on threat
-    Unit* newTarget = m_ai->FindAttacker((PlayerbotAI::ATTACKERINFOTYPE)(PlayerbotAI::AIT_VICTIMSELF | PlayerbotAI::AIT_HIGHESTTHREAT), m_bot);
-
-    // Remove curse on group members
-    if (Player* pCursedTarget = GetDispelTarget(DISPEL_CURSE))
-    {
-        if (MAGE_REMOVE_CURSE > 0 && CastSpell(MAGE_REMOVE_CURSE, pCursedTarget))
-            return RETURN_CONTINUE;
-    }
-
-    if (newTarget && !m_ai->IsNeutralized(newTarget)) // Bot has aggro and the mob is not already crowd controled
-    {
-        if (newTarget->GetHealthPercent() > 25)
-        {
-            // If elite
-            if (m_ai->IsElite(newTarget))
-            {
-                // If the attacker is a beast or humanoid, let's the bot give it a form more suited to the low intellect of something fool enough to attack a mage
-                Creature* pCreature = (Creature*) newTarget;
-                if (pCreature && (pCreature->GetCreatureInfo()->CreatureType == CREATURE_TYPE_HUMANOID || pCreature->GetCreatureInfo()->CreatureType == CREATURE_TYPE_BEAST))
-                {
-                    if (POLYMORPH > 0 && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_ARCANE) && CastSpell(POLYMORPH, newTarget))
-                        return RETURN_CONTINUE;
-                }
-
-                // Things are getting dire: cast Ice block
-                if (ICE_BLOCK > 0 && m_bot->IsSpellReady(ICE_BLOCK) && m_ai->GetHealthPercent() < 30 && !m_bot->HasAura(ICE_BLOCK, EFFECT_INDEX_0) && m_ai->CastSpell(ICE_BLOCK))
-                    return RETURN_CONTINUE;
-
-                // Cast Ice Barrier if health starts to goes low
-                if (ICE_BARRIER > 0 && m_bot->IsSpellReady(ICE_BARRIER) && m_ai->GetHealthPercent() < 50 && !m_bot->HasAura(ICE_BARRIER) && m_ai->SelfBuff(ICE_BARRIER))
-                    return RETURN_CONTINUE;
-
-                // Have threat, can't quickly lower it. 3 options remain: Stop attacking, lowlevel damage (wand), keep on keeping on.
-                return CastSpell(SHOOT, pTarget);
-            }
-            else // not elite
-            {
-                // Cast mana shield if no shield is already up
-                if (MANA_SHIELD > 0 && m_ai->GetHealthPercent() < 70 && !m_bot->HasAura(MANA_SHIELD) && !m_bot->HasAura(ICE_BARRIER) && m_ai->SelfBuff(MANA_SHIELD))
-                    return RETURN_CONTINUE;
-            }
-        }
-    }
-
-    // Mana check and replenishment
-    if (EVOCATION && m_ai->GetManaPercent() <= 10 && m_bot->IsSpellReady(EVOCATION) && !newTarget && m_ai->SelfBuff(EVOCATION))
-        return RETURN_CONTINUE;
-    if (m_ai->GetManaPercent() <= 20)
-    {
-        Item* gem = FindManaGem();
-        if (gem)
-            m_ai->UseItem(gem);
-    }
-
-    // If bot has frost/fire resist order use Frost/Fire Ward when available
-    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_RESIST_FROST && FROST_WARD && m_bot->IsSpellReady(FROST_WARD) && m_ai->SelfBuff(FROST_WARD))
-        return RETURN_CONTINUE;
-    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_RESIST_FIRE && FIRE_WARD && m_bot->IsSpellReady(FIRE_WARD) && m_ai->SelfBuff(FIRE_WARD))
-        return RETURN_CONTINUE;
-
-    if (COUNTERSPELL > 0 && m_bot->IsSpellReady(COUNTERSPELL) && pTarget->IsNonMeleeSpellCasted(true) && CastSpell(COUNTERSPELL, pTarget))
-        return RETURN_CONTINUE;
-
-    // If Clearcasting is active, cast arcane missiles
-    // Bot could also cast flamestrike or blizzard for free, but the AoE could break some crowd control
-    // or add threat on mobs ignoring the bot currently, so only focus on the bot's current target
-    if (m_bot->HasAura(CLEARCASTING_1) && ARCANE_MISSILES > 0 && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_ARCANE) && CastSpell(ARCANE_MISSILES, pTarget))
-    {
-        m_ai->SetIgnoreUpdateTime(3);
-        return RETURN_CONTINUE;
-    }
-
-    switch (spec)
-    {
-        case MAGE_SPEC_FROST:
-            if (ICY_VEINS > 0 && m_ai->In_Reach(m_bot, ICY_VEINS) && !m_bot->HasAura(ICY_VEINS, EFFECT_INDEX_0) && CastSpell(ICY_VEINS, m_bot))
-                return RETURN_CONTINUE;
-            if (COLD_SNAP && m_bot->IsSpellReady(COLD_SNAP) && CheckFrostCooldowns() > 2 && m_ai->SelfBuff(COLD_SNAP))  // Clear frost spell cooldowns if bot has more than 2 active
-                return RETURN_CONTINUE;
-            if (CONE_OF_COLD > 0 && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_FROST) && m_bot->IsSpellReady(CONE_OF_COLD) && meleeReach)
-            {
-                // Cone of Cold does not require a target, so ensure that the bot faces the current one before casting
-                m_ai->FaceTarget(pTarget);
-                if (m_ai->CastSpell(CONE_OF_COLD))
-                    return RETURN_CONTINUE;
-            }
-            if (FROSTBOLT > 0 && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_FROST) && m_ai->In_Reach(pTarget, FROSTBOLT) && !pTarget->HasAura(FROSTBOLT, EFFECT_INDEX_0) && CastSpell(FROSTBOLT, pTarget))
-                return RETURN_CONTINUE;
-            if (FROST_NOVA > 0 && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_FROST) && m_bot->IsSpellReady(FROST_NOVA) && meleeReach && !pTarget->HasAura(FROST_NOVA, EFFECT_INDEX_0) && CastSpell(FROST_NOVA, pTarget))
-                return RETURN_CONTINUE;
-            if (ICE_LANCE > 0 && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_FROST) && m_ai->In_Reach(pTarget, ICE_LANCE) && CastSpell(ICE_LANCE, pTarget))
-                return RETURN_CONTINUE;
-            if (SUMMON_WATER_ELEMENTAL > 0 && CastSpell(SUMMON_WATER_ELEMENTAL))
-                return RETURN_CONTINUE;
-
-            // Default frost spec action
-            if (FROSTBOLT > 0 && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_FROST) && m_ai->In_Reach(pTarget, FROSTBOLT))
-                return CastSpell(FROSTBOLT, pTarget);
-            /*
-            if (BLIZZARD > 0 && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_FROST) && m_ai->In_Reach(pTarget,BLIZZARD) && m_ai->GetAttackerCount() >= 5 && CastSpell(BLIZZARD, pTarget))
-            {
-                m_ai->SetIgnoreUpdateTime(8);
-                return RETURN_CONTINUE;
-            }
-            */
-            break;
-
-        case MAGE_SPEC_FIRE:
-            if (COMBUSTION > 0 && m_ai->SelfBuff(COMBUSTION))
-                return RETURN_CONTINUE;
-            if (BLAST_WAVE > 0 && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_FIRE) && m_ai->GetAttackerCount() >= 3 && meleeReach && CastSpell(BLAST_WAVE, pTarget))
-                return RETURN_CONTINUE;
-            // Try to have 3 scorch stacks to let tank build aggro while getting a nice crit% bonus
-            if (IMPROVED_SCORCH > 0 && SCORCH > 0 && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_FIRE))
-            {
-                if (!pTarget->HasAura(FIRE_VULNERABILITY, EFFECT_INDEX_0) && CastSpell(SCORCH, pTarget))   // no stacks: cast it
-                    return RETURN_CONTINUE;
-                else
-                {
-                    SpellAuraHolder* holder = pTarget->GetSpellAuraHolder(FIRE_VULNERABILITY);
-                    if (holder && (holder->GetStackAmount() < 3) && CastSpell(SCORCH, pTarget))
-                        return RETURN_CONTINUE;
-                }
-            }
-            // At least 3 stacks of Scorch: cast an opening fireball
-            if (FIREBALL > 0 && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_FIRE) && !pTarget->HasAura(FIREBALL, EFFECT_INDEX_1) && CastSpell(FIREBALL, pTarget))
-                return RETURN_CONTINUE;
-            // 3 stacks of Scorch and fireball DoT: use fire blast if available
-            if (FIRE_BLAST > 0 && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_FIRE) && m_bot->IsSpellReady(FIRE_BLAST) && CastSpell(FIRE_BLAST, pTarget))
-                return RETURN_CONTINUE;
-            if (DRAGONS_BREATH > 0 && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_FIRE) && meleeReach && CastSpell(DRAGONS_BREATH, pTarget))
-                return RETURN_CONTINUE;
-
-            // All DoTs, cooldowns used, try to maximise scorch stacks (5) to get a even nicer crit% bonus
-            if (IMPROVED_SCORCH > 0 && SCORCH > 0 && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_FIRE))
-            {
-                SpellAuraHolder* holder = pTarget->GetSpellAuraHolder(FIRE_VULNERABILITY);
-                if (holder && (holder->GetStackAmount() < 5) && CastSpell(SCORCH, pTarget))
-                    return RETURN_CONTINUE;
-            }
-            // Default fire spec action
-            if (FIREBALL > 0 && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_FIRE) && m_ai->In_Reach(pTarget, FIREBALL))
-                return CastSpell(FIREBALL, pTarget);
-            /*
-            if (FLAMESTRIKE > 0 && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_FIRE) && m_ai->In_Reach(pTarget,FLAMESTRIKE) && CastSpell(FLAMESTRIKE, pTarget))
-                return RETURN_CONTINUE;
-            */
-            break;
-
-        case MAGE_SPEC_ARCANE:
-            if (ARCANE_POWER > 0 && m_bot->IsSpellReady(ARCANE_POWER) && m_ai->IsElite(pTarget) && m_ai->CastSpell(ARCANE_POWER))    // Do not waste Arcane Power on normal NPCs as the bot is likely in a group
-                return RETURN_CONTINUE;
-            if (PRESENCE_OF_MIND > 0 && !m_bot->HasAura(PRESENCE_OF_MIND) && m_bot->IsSpellReady(PRESENCE_OF_MIND) && m_ai->IsElite(pTarget) && m_ai->SelfBuff(PRESENCE_OF_MIND))
-                return RETURN_CONTINUE;
-            // If bot has presence of mind active, cast long casting time spells
-            if (PRESENCE_OF_MIND && m_bot->HasAura(PRESENCE_OF_MIND))
-            {
-                // Instant Pyroblast, yeah! Tanks will probably hate this, but what do they know about power? Nothing...
-                if (PYROBLAST > 0 && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_FIRE) && CastSpell(PYROBLAST, pTarget))
-                    return RETURN_CONTINUE;
-                if (FIREBALL > 0 && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_FIRE) && CastSpell(FIREBALL, pTarget))
-                    return RETURN_CONTINUE;
-            }
-            if (ARCANE_EXPLOSION > 0 && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_ARCANE) && m_ai->GetAttackerCount() >= 3 && meleeReach && CastSpell(ARCANE_EXPLOSION, pTarget))
-                return RETURN_CONTINUE;
-            // Default arcane spec actions (yes, two fire spells)
-            if (FIRE_BLAST > 0 && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_FIRE) && m_bot->IsSpellReady(FIRE_BLAST) && CastSpell(FIRE_BLAST, pTarget))
-                return RETURN_CONTINUE;
-            if (SLOW > 0 && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_ARCANE) && m_ai->In_Reach(pTarget, SLOW) && !pTarget->HasAura(SLOW, EFFECT_INDEX_0) && CastSpell(SLOW, pTarget))
-                return RETURN_CONTINUE;
-            if (ARCANE_BLAST > 0 && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_ARCANE) && m_ai->In_Reach(pTarget, ARCANE_BLAST) && CastSpell(ARCANE_BLAST, pTarget))
-                return RETURN_CONTINUE;
-
-            if (FIREBALL > 0 && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_FIRE) && m_ai->In_Reach(pTarget, FIREBALL))
-                return CastSpell(FIREBALL, pTarget);
-            // If no fireball, arcane missiles
-            if (ARCANE_MISSILES > 0 && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_ARCANE) && CastSpell(ARCANE_MISSILES, pTarget))
-            {
-                m_ai->SetIgnoreUpdateTime(3);
-                return RETURN_CONTINUE;
-            }
-            break;
-    }
-
-    // No spec due to low level OR no spell found yet
-    if (FROSTBOLT > 0 && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_FROST) && m_ai->In_Reach(pTarget, FROSTBOLT) && !pTarget->HasAura(FROSTBOLT, EFFECT_INDEX_0) && CastSpell(FROSTBOLT, pTarget))
-        return RETURN_CONTINUE;
-    if (FIREBALL > 0 && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_FIRE) && m_ai->In_Reach(pTarget, FIREBALL) && CastSpell(FIREBALL, pTarget)) // Very low levels
-        return RETURN_CONTINUE;
-
-    // Default: shoot with wand
-    return CastSpell(SHOOT, pTarget);
-
-    return RETURN_NO_ACTION_ERROR; // What? Not even Fireball or wand are available?
-} // end DoNextCombatManeuver
-
-CombatManeuverReturns PlayerbotMageAI::DoNextCombatManeuverPVP(Unit* pTarget)
-{
-    if (FIREBALL && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_FIRE) && m_ai->In_Reach(pTarget, FIREBALL) && m_ai->CastSpell(FIREBALL))
-        return RETURN_CONTINUE;
-
-    return DoNextCombatManeuverPVE(pTarget); // TODO: bad idea perhaps, but better than the alternative
-}
-
-// Function to keep track of active frost cooldowns to clear with Cold Snap
-uint8 PlayerbotMageAI::CheckFrostCooldowns()
-{
-    uint8 uiFrostActiveCooldown = 0;
-    if (FROST_NOVA && !m_bot->IsSpellReady(FROST_NOVA))
-        uiFrostActiveCooldown++;
-    if (ICE_BARRIER && !m_bot->IsSpellReady(ICE_BARRIER))
-        uiFrostActiveCooldown++;
-    if (CONE_OF_COLD && !m_bot->IsSpellReady(CONE_OF_COLD))
-        uiFrostActiveCooldown++;
-    if (ICE_BLOCK && !m_bot->IsSpellReady(ICE_BLOCK))
-        uiFrostActiveCooldown++;
-    if (FROST_WARD && !m_bot->IsSpellReady(FROST_WARD))
-        uiFrostActiveCooldown++;
-
-    return uiFrostActiveCooldown;
-}
-
-static const uint32 uPriorizedManaGemIds[5] =
-{
-    MANA_EMERALD_DISPLAYID, MANA_RUBY_DISPLAYID, MANA_CITRINE_DISPLAYID, MANA_AGATE_DISPLAYID, MANA_JADE_DISPLAYID
-};
-
-// Return a mana gem Item based on the priorized list
-Item* PlayerbotMageAI::FindManaGem() const
-{
-    Item* gem;
-    for (uint8 i = 0; i < countof(uPriorizedManaGemIds); ++i)
-    {
-        gem = m_ai->FindConsumable(uPriorizedManaGemIds[i]);
-        if (gem)
-            return gem;
-    }
-    return nullptr;
-}
-
-void PlayerbotMageAI::DoNonCombatActions()
-{
-    Player* master = GetMaster();
-
-    if (!m_bot || !master)
-        return;
-
-    // Remove curse on group members if orders allow bot to do so
-    if (Player* pCursedTarget = GetDispelTarget(DISPEL_CURSE))
-    {
-        if (MAGE_REMOVE_CURSE > 0 && (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_NODISPEL) == 0 && CastSpell(MAGE_REMOVE_CURSE, pCursedTarget))
-            return;
-    }
-
-    // Buff armor
-    if (MOLTEN_ARMOR)
-    {
-        if (m_ai->SelfBuff(MOLTEN_ARMOR))
-            return;
-    }
-    else if (MAGE_ARMOR)
-    {
-        if (m_ai->SelfBuff(MAGE_ARMOR))
-            return;
-    }
-    else if (ICE_ARMOR)
-    {
-        if (m_ai->SelfBuff(ICE_ARMOR))
-            return;
-    }
-    else if (FROST_ARMOR)
-    {
-        if (m_ai->SelfBuff(FROST_ARMOR))
-            return;
-    }
-
-    if (COMBUSTION && m_bot->IsSpellReady(COMBUSTION) && m_ai->SelfBuff(COMBUSTION))
-        return;
-
-    // buff group
-    // the check for group targets is performed by NeedGroupBuff (if group is found for bots by the function)
-    if (NeedGroupBuff(ARCANE_BRILLIANCE, ARCANE_INTELLECT) && m_ai->HasSpellReagents(ARCANE_BRILLIANCE))
-    {
-        if (Buff(&PlayerbotMageAI::BuffHelper, ARCANE_BRILLIANCE) & RETURN_CONTINUE)
-            return;
-    }
-    else if (Buff(&PlayerbotMageAI::BuffHelper, ARCANE_INTELLECT, JOB_MANAONLY) & RETURN_CONTINUE)
-        return;
-
-    Item* gem = FindManaGem();
-    if (!gem && CONJURE_MANA_GEM && m_ai->CastSpell(CONJURE_MANA_GEM, *m_bot))
-    {
-        m_ai->SetIgnoreUpdateTime(3);
-        return;
-    }
-
-    // TODO: The beauty of a mage is not only its ability to supply itself with water, but to share its water
-    // So, conjure at *least* 1.25 stacks, ready to trade a stack and still have some left for self
-    if (m_ai->FindDrink() == nullptr && CONJURE_WATER && m_ai->CastSpell(CONJURE_WATER, *m_bot))
-    {
-        m_ai->TellMaster("I'm conjuring some water.");
-        m_ai->SetIgnoreUpdateTime(3);
-        return;
-    }
-
-    if (m_ai->FindFood() == nullptr && CONJURE_FOOD && m_ai->CastSpell(CONJURE_FOOD, *m_bot))
-    {
-        m_ai->TellMaster("I'm conjuring some food.");
-        m_ai->SetIgnoreUpdateTime(3);
-        return;
-    }
-
-    if (EatDrinkBandage())
-        return;
-} // end DoNonCombatActions
-
-// TODO: this and priest's BuffHelper are identical and thus could probably go in PlayerbotClassAI.cpp somewhere
-bool PlayerbotMageAI::BuffHelper(PlayerbotAI* ai, uint32 spellId, Unit* target)
-{
-    if (!ai)          return false;
-    if (spellId == 0) return false;
-    if (!target)      return false;
-
-    Pet* pet = target->GetPet();
-    if (pet && !pet->HasAuraType(SPELL_AURA_MOD_UNATTACKABLE) && ai->Buff(spellId, pet))
-        return true;
-
-    if (ai->Buff(spellId, target))
-        return true;
-
-    return false;
-}
-
-// Return to UpdateAI the spellId usable to neutralize a target with creaturetype
-uint32 PlayerbotMageAI::Neutralize(uint8 creatureType)
-{
-    if (!m_bot)         return 0;
-    if (!m_ai)          return 0;
-    if (!creatureType)  return 0;
-
-    if (creatureType != CREATURE_TYPE_HUMANOID && creatureType != CREATURE_TYPE_BEAST)
-    {
-        m_ai->TellMaster("I can't polymorph that target.");
-        return 0;
-    }
-
-    if (POLYMORPH)
-        return POLYMORPH;
-    else
-        return 0;
-
-    return 0;
-}
\ No newline at end of file
diff --git a/src/game/PlayerBot/AI/PlayerbotMageAI.h b/src/game/PlayerBot/AI/PlayerbotMageAI.h
deleted file mode 100644
index 58b1af915..000000000
--- a/src/game/PlayerBot/AI/PlayerbotMageAI.h
+++ /dev/null
@@ -1,201 +0,0 @@
-/*
- * This file is part of the CMaNGOS Project. See AUTHORS file for Copyright information
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _PlayerbotMageAI_H
-#define _PlayerbotMageAI_H
-
-#include "../Base/PlayerbotClassAI.h"
-
-enum
-{
-    SPELL_FROST,
-    SPELL_FIRE,
-    SPELL_ARCANE
-};
-
-enum ManaGemIds
-{
-    MANA_RUBY_DISPLAYID             = 7045,
-    MANA_CITRINE_DISPLAYID          = 6496,
-    MANA_AGATE_DISPLAYID            = 6851,
-    MANA_JADE_DISPLAYID             = 7393,
-    MANA_EMERALD_DISPLAYID          = 1262,
-};
-
-enum MageSpells
-{
-    AMPLIFY_MAGIC_1                 = 1008,
-    ARCANE_BLAST_1                  = 30451,
-    ARCANE_BRILLIANCE_1             = 23028,
-    ARCANE_EXPLOSION_1              = 1449,
-    ARCANE_INTELLECT_1              = 1459,
-    ARCANE_MISSILES_1               = 5143,
-    ARCANE_POWER_1                  = 12042,
-    BLAST_WAVE_1                    = 11113,
-    BLINK_1                         = 1953,
-    BLIZZARD_1                      = 10,
-    CLEARCASTING_1                  = 12536,
-    COLD_SNAP_1                     = 11958,
-    COMBUSTION_1                    = 11129,
-    CONE_OF_COLD_1                  = 120,
-    CONJURE_FOOD_1                  = 587,
-    CONJURE_MANA_GEM_1              = 759,
-    CONJURE_WATER_1                 = 5504,
-    COUNTERSPELL_1                  = 2139,
-    DAMPEN_MAGIC_1                  = 604,
-    DRAGONS_BREATH_1                = 31661,
-    EVOCATION_1                     = 12051,
-    FIRE_BLAST_1                    = 2136,
-    FIRE_WARD_1                     = 543,
-    FIREBALL_1                      = 133,
-    FLAMESTRIKE_1                   = 2120,
-    FROST_ARMOR_1                   = 168,
-    FROST_NOVA_1                    = 122,
-    FROST_WARD_1                    = 6143,
-    FROSTBOLT_1                     = 116,
-    ICE_ARMOR_1                     = 7302,
-    ICE_BARRIER_1                   = 11426,
-    ICE_BLOCK_1                     = 27619,
-    ICE_LANCE_1                     = 30455,
-    ICY_VEINS_1                     = 12472,
-    INVISIBILITY_1                  = 66,
-    MAGE_ARMOR_1                    = 6117,
-    MANA_SHIELD_1                   = 1463,
-    MOLTEN_ARMOR_1                  = 30482,
-    POLYMORPH_1                     = 118,
-    PRESENCE_OF_MIND_1              = 12043,
-    PYROBLAST_1                     = 11366,
-    REMOVE_CURSE_MAGE_1             = 475,
-    SCORCH_1                        = 2948,
-    SHOOT_2                                          = 5019,
-    SLOW_1                          = 31589,
-    SLOW_FALL_1                     = 130,
-    SPELLSTEAL_1                    = 30449,
-    SUMMON_WATER_ELEMENTAL_1        = 31687
-};
-
-enum MageTalents
-{
-    IMPROVED_SCORCH_1               = 11095,
-    IMPROVED_SCORCH_2               = 12872,
-    IMPROVED_SCORCH_3               = 12873
-};
-
-static const uint32 uiImprovedScorch[3] =
-{
-    IMPROVED_SCORCH_1, IMPROVED_SCORCH_2, IMPROVED_SCORCH_3
-};
-
-//class Player;
-
-class PlayerbotMageAI : PlayerbotClassAI
-{
-    public:
-        PlayerbotMageAI(Player* const master, Player* const bot, PlayerbotAI* const ai);
-        virtual ~PlayerbotMageAI();
-
-        // all combat actions go here
-        CombatManeuverReturns DoFirstCombatManeuver(Unit* pTarget);
-        CombatManeuverReturns DoNextCombatManeuver(Unit* pTarget);
-        uint32 Neutralize(uint8 creatureType);
-
-        // all non combat actions go here, ex buffs, heals, rezzes
-        void DoNonCombatActions();
-
-    private:
-        CombatManeuverReturns DoFirstCombatManeuverPVE(Unit* pTarget);
-        CombatManeuverReturns DoNextCombatManeuverPVE(Unit* pTarget);
-        CombatManeuverReturns DoFirstCombatManeuverPVP(Unit* pTarget);
-        CombatManeuverReturns DoNextCombatManeuverPVP(Unit* pTarget);
-        Item* FindManaGem() const;
-
-        CombatManeuverReturns CastSpell(uint32 nextAction, Unit* pTarget = nullptr) { return CastSpellWand(nextAction, pTarget, SHOOT); }
-
-        static bool BuffHelper(PlayerbotAI* ai, uint32 spellId, Unit* target);
-
-        uint8 CheckFrostCooldowns();
-
-        // ARCANE
-        uint32 ARCANE_MISSILES,
-               ARCANE_EXPLOSION,
-               COUNTERSPELL,
-               SLOW,
-               ARCANE_BLAST,
-               EVOCATION,
-               POLYMORPH,
-               PRESENCE_OF_MIND,
-               ARCANE_POWER;
-        // ranged
-        uint32 SHOOT;
-
-        // FIRE
-        uint32 FIREBALL,
-               FIRE_BLAST,
-               FLAMESTRIKE,
-               SCORCH,
-               FIRE_VULNERABILITY,
-               IMPROVED_SCORCH,
-               PYROBLAST,
-               BLAST_WAVE,
-               COMBUSTION,
-               DRAGONS_BREATH,
-               FIRE_WARD;
-
-        // FROST
-        uint32 FROSTBOLT,
-               FROST_NOVA,
-               BLIZZARD,
-               ICY_VEINS,
-               CONE_OF_COLD,
-               ICE_BARRIER,
-               SUMMON_WATER_ELEMENTAL,
-               ICE_LANCE,
-               FROST_WARD,
-               ICE_BLOCK,
-               COLD_SNAP;
-
-        // buffs
-        uint32 FROST_ARMOR,
-               ICE_ARMOR,
-               MAGE_ARMOR,
-               MOLTEN_ARMOR,
-               ARCANE_INTELLECT,
-               ARCANE_BRILLIANCE,
-               MANA_SHIELD,
-               DAMPEN_MAGIC,
-               AMPLIFY_MAGIC,
-               MAGE_REMOVE_CURSE;
-
-        // racial
-        uint32 ARCANE_TORRENT,
-               GIFT_OF_THE_NAARU,
-               STONEFORM,
-               ESCAPE_ARTIST,
-               PERCEPTION,
-               SHADOWMELD,
-               BLOOD_FURY,
-               WAR_STOMP,
-               BERSERKING,
-               WILL_OF_THE_FORSAKEN;
-
-        uint32 CONJURE_WATER,
-               CONJURE_FOOD,
-               CONJURE_MANA_GEM;
-};
-
-#endif
diff --git a/src/game/PlayerBot/AI/PlayerbotPaladinAI.cpp b/src/game/PlayerBot/AI/PlayerbotPaladinAI.cpp
deleted file mode 100644
index 438962a08..000000000
--- a/src/game/PlayerBot/AI/PlayerbotPaladinAI.cpp
+++ /dev/null
@@ -1,797 +0,0 @@
-/*
- * This file is part of the CMaNGOS Project. See AUTHORS file for Copyright information
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "PlayerbotPaladinAI.h"
-#include "../Base/PlayerbotMgr.h"
-
-class PlayerbotAI;
-
-PlayerbotPaladinAI::PlayerbotPaladinAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
-{
-    RETRIBUTION_AURA              = m_ai->initSpell(RETRIBUTION_AURA_1);
-    CRUSADER_AURA                 = m_ai->initSpell(CRUSADER_AURA_1);
-    CRUSADER_STRIKE               = m_ai->initSpell(CRUSADER_STRIKE_1);
-    SEAL_OF_COMMAND               = m_ai->initSpell(SEAL_OF_COMMAND_1);
-    SEAL_OF_RIGHTEOUSNESS         = m_ai->initSpell(SEAL_OF_RIGHTEOUSNESS_1);
-    SEAL_OF_JUSTICE               = m_ai->initSpell(SEAL_OF_JUSTICE_1);
-    SEAL_OF_LIGHT                 = m_ai->initSpell(SEAL_OF_LIGHT_1);
-    SEAL_OF_VENGEANCE             = m_ai->initSpell(SEAL_OF_VENGEANCE_1);
-    SEAL_OF_WISDOM                = m_ai->initSpell(SEAL_OF_WISDOM_1);
-    SEAL_OF_THE_CRUSADER          = m_ai->initSpell(SEAL_OF_THE_CRUSADER_1);
-    JUDGEMENT                     = m_ai->initSpell(JUDGEMENT_1);
-    BLESSING_OF_MIGHT             = m_ai->initSpell(BLESSING_OF_MIGHT_1);
-    GREATER_BLESSING_OF_MIGHT     = m_ai->initSpell(GREATER_BLESSING_OF_MIGHT_1);
-    HAMMER_OF_WRATH               = m_ai->initSpell(HAMMER_OF_WRATH_1);
-    FLASH_OF_LIGHT                = m_ai->initSpell(FLASH_OF_LIGHT_1); // Holy
-    HOLY_LIGHT                    = m_ai->initSpell(HOLY_LIGHT_1);
-    HOLY_SHOCK                    = m_ai->initSpell(HOLY_SHOCK_1);
-    HOLY_WRATH                    = m_ai->initSpell(HOLY_WRATH_1);
-    DIVINE_FAVOR                  = m_ai->initSpell(DIVINE_FAVOR_1);
-    CONCENTRATION_AURA            = m_ai->initSpell(CONCENTRATION_AURA_1);
-    BLESSING_OF_WISDOM            = m_ai->initSpell(BLESSING_OF_WISDOM_1);
-    GREATER_BLESSING_OF_WISDOM    = m_ai->initSpell(GREATER_BLESSING_OF_WISDOM_1);
-    CONSECRATION                  = m_ai->initSpell(CONSECRATION_1);
-    AVENGING_WRATH                = m_ai->initSpell(AVENGING_WRATH_1);
-    LAY_ON_HANDS                  = m_ai->initSpell(LAY_ON_HANDS_1);
-    EXORCISM                      = m_ai->initSpell(EXORCISM_1);
-    BLESSING_OF_KINGS             = m_ai->initSpell(BLESSING_OF_KINGS_1);
-    GREATER_BLESSING_OF_KINGS     = m_ai->initSpell(GREATER_BLESSING_OF_KINGS_1);
-    BLESSING_OF_SANCTUARY         = m_ai->initSpell(BLESSING_OF_SANCTUARY_1);
-    GREATER_BLESSING_OF_SANCTUARY = m_ai->initSpell(GREATER_BLESSING_OF_SANCTUARY_1);
-    HAMMER_OF_JUSTICE             = m_ai->initSpell(HAMMER_OF_JUSTICE_1);
-    RIGHTEOUS_FURY                = m_ai->initSpell(RIGHTEOUS_FURY_1);
-    RIGHTEOUS_DEFENSE             = m_ai->initSpell(RIGHTEOUS_DEFENSE_1);
-    SHADOW_RESISTANCE_AURA        = m_ai->initSpell(SHADOW_RESISTANCE_AURA_1);
-    DEVOTION_AURA                 = m_ai->initSpell(DEVOTION_AURA_1);
-    FIRE_RESISTANCE_AURA          = m_ai->initSpell(FIRE_RESISTANCE_AURA_1);
-    FROST_RESISTANCE_AURA         = m_ai->initSpell(FROST_RESISTANCE_AURA_1);
-    BLESSING_OF_PROTECTION        = m_ai->initSpell(BLESSING_OF_PROTECTION_1);
-    DIVINE_PROTECTION             = m_ai->initSpell(DIVINE_PROTECTION_1);
-    DIVINE_INTERVENTION           = m_ai->initSpell(DIVINE_INTERVENTION_1);
-    DIVINE_SHIELD                 = m_ai->initSpell(DIVINE_SHIELD_1);
-    HOLY_SHIELD                   = m_ai->initSpell(HOLY_SHIELD_1);
-    AVENGERS_SHIELD               = m_ai->initSpell(AVENGERS_SHIELD_1);
-    BLESSING_OF_SACRIFICE         = m_ai->initSpell(BLESSING_OF_SACRIFICE_1);
-    REDEMPTION                    = m_ai->initSpell(REDEMPTION_1);
-    PURIFY                        = m_ai->initSpell(PURIFY_1);
-    CLEANSE                       = m_ai->initSpell(CLEANSE_1);
-
-    // Warrior auras
-    DEFENSIVE_STANCE              = 71;   //Def Stance
-    BERSERKER_STANCE              = 2458; //Ber Stance
-    BATTLE_STANCE                 = 2457; //Bat Stance
-
-    FORBEARANCE                   = 25771; // cannot be protected
-
-    RECENTLY_BANDAGED             = 11196; // first aid check
-
-    // racial
-    ARCANE_TORRENT                = m_ai->initSpell(ARCANE_TORRENT_MANA_CLASSES);
-    GIFT_OF_THE_NAARU             = m_ai->initSpell(GIFT_OF_THE_NAARU_ALL); // draenei
-    STONEFORM                     = m_ai->initSpell(STONEFORM_ALL); // dwarf
-    PERCEPTION                    = m_ai->initSpell(PERCEPTION_ALL); // human
-
-    //The check doesn't work for now
-    //PRAYER_OF_SHADOW_PROTECTION   = m_ai->initSpell(PriestSpells::PRAYER_OF_SHADOW_PROTECTION_1);
-}
-
-PlayerbotPaladinAI::~PlayerbotPaladinAI() {}
-
-CombatManeuverReturns PlayerbotPaladinAI::DoFirstCombatManeuver(Unit* pTarget)
-{
-    // There are NPCs in BGs and Open World PvP, so don't filter this on PvP scenarios (of course if PvP targets anyone but tank, all bets are off anyway)
-    // Wait until the tank says so, until any non-tank gains aggro or X seconds - whichever is shortest
-    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO)
-    {
-        if (m_WaitUntil > m_ai->CurrentTime() && m_ai->GroupTankHoldsAggro())
-        {
-            if (PlayerbotAI::ORDERS_TANK & m_ai->GetCombatOrder())
-            {
-                if (m_bot->CanReachWithMeleeAttack(pTarget))
-                {
-                    // Set everyone's UpdateAI() waiting to 2 seconds
-                    m_ai->SetGroupIgnoreUpdateTime(2);
-                    // Clear their TEMP_WAIT_TANKAGGRO flag
-                    m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO);
-                    // Start attacking, force target on current target
-                    m_ai->Attack(m_ai->GetCurrentTarget());
-
-                    // While everyone else is waiting 2 second, we need to build up aggro, so don't return
-                }
-                else
-                {
-                    // TODO: add check if target is ranged
-                    return RETURN_NO_ACTION_OK; // wait for target to get nearer
-                }
-            }
-            else if (PlayerbotAI::ORDERS_HEAL & m_ai->GetCombatOrder())
-                return HealPlayer(GetHealTarget());
-            else
-                return RETURN_NO_ACTION_OK; // wait it out
-        }
-        else
-        {
-            m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO);
-        }
-    }
-
-    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TEMP_WAIT_OOC)
-    {
-        if (m_WaitUntil > m_ai->CurrentTime() && m_ai->IsGroupReady())
-            return RETURN_NO_ACTION_OK; // wait it out
-        else
-            m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_OOC);
-    }
-
-    // Check if bot needs to cast seal on self
-    m_CurrentSeal      = 0;
-    m_CurrentJudgement = 0;
-
-    switch (m_ai->GetScenarioType())
-    {
-        case PlayerbotAI::SCENARIO_PVP_DUEL:
-        case PlayerbotAI::SCENARIO_PVP_BG:
-        case PlayerbotAI::SCENARIO_PVP_ARENA:
-        case PlayerbotAI::SCENARIO_PVP_OPENWORLD:
-            return DoFirstCombatManeuverPVP(pTarget);
-        case PlayerbotAI::SCENARIO_PVE:
-        case PlayerbotAI::SCENARIO_PVE_ELITE:
-        case PlayerbotAI::SCENARIO_PVE_RAID:
-        default:
-            return DoFirstCombatManeuverPVE(pTarget);
-            break;
-    }
-
-    return RETURN_NO_ACTION_ERROR;
-}
-
-CombatManeuverReturns PlayerbotPaladinAI::DoFirstCombatManeuverPVE(Unit* /*pTarget*/)
-{
-    return RETURN_NO_ACTION_OK;
-}
-
-CombatManeuverReturns PlayerbotPaladinAI::DoFirstCombatManeuverPVP(Unit* /*pTarget*/)
-{
-    return RETURN_NO_ACTION_OK;
-}
-
-CombatManeuverReturns PlayerbotPaladinAI::DoNextCombatManeuver(Unit* pTarget)
-{
-    // Face enemy, make sure bot is attacking
-    m_ai->FaceTarget(pTarget);
-
-    switch (m_ai->GetScenarioType())
-    {
-        case PlayerbotAI::SCENARIO_PVP_DUEL:
-        case PlayerbotAI::SCENARIO_PVP_BG:
-        case PlayerbotAI::SCENARIO_PVP_ARENA:
-        case PlayerbotAI::SCENARIO_PVP_OPENWORLD:
-            return DoNextCombatManeuverPVP(pTarget);
-        case PlayerbotAI::SCENARIO_PVE:
-        case PlayerbotAI::SCENARIO_PVE_ELITE:
-        case PlayerbotAI::SCENARIO_PVE_RAID:
-        default:
-            return DoNextCombatManeuverPVE(pTarget);
-            break;
-    }
-
-    return RETURN_NO_ACTION_ERROR;
-}
-
-CombatManeuverReturns PlayerbotPaladinAI::DoNextCombatManeuverPVE(Unit* pTarget)
-{
-    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
-    if (!m_bot) return RETURN_NO_ACTION_ERROR;
-    if (!pTarget) return RETURN_NO_ACTION_INVALIDTARGET;
-
-    // damage spells
-    uint32 spec = m_bot->GetSpec();
-    std::ostringstream out;
-
-    // Make sure healer stays put, don't even melee (aggro) if in range.
-    if (m_ai->IsHealer() && m_ai->GetCombatStyle() != PlayerbotAI::COMBAT_RANGED)
-        m_ai->SetCombatStyle(PlayerbotAI::COMBAT_RANGED);
-    else if (!m_ai->IsHealer() && m_ai->GetCombatStyle() != PlayerbotAI::COMBAT_MELEE)
-        m_ai->SetCombatStyle(PlayerbotAI::COMBAT_MELEE);
-
-    // Emergency check: bot is about to die: use Divine Shield (first)
-    // Use Divine Protection if Divine Shield is not available and bot is not tanking because of the pacify effect
-    // TODO adjust treshold (may be too low)
-    if (m_ai->GetHealthPercent() < 8)
-    {
-        if (DIVINE_SHIELD > 0 && m_bot->IsSpellReady(DIVINE_SHIELD) && !m_bot->HasAura(DIVINE_SHIELD, EFFECT_INDEX_0) && !m_bot->HasAura(DIVINE_PROTECTION, EFFECT_INDEX_0) && !m_bot->HasAura(FORBEARANCE, EFFECT_INDEX_0) && m_ai->CastSpell(DIVINE_SHIELD, *m_bot))
-            return RETURN_CONTINUE;
-
-        if (DIVINE_PROTECTION > 0 && !(m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TANK) && m_bot->IsSpellReady(DIVINE_PROTECTION) && !m_bot->HasAura(DIVINE_SHIELD, EFFECT_INDEX_0) && !m_bot->HasAura(DIVINE_PROTECTION, EFFECT_INDEX_0) && !m_bot->HasAura(FORBEARANCE, EFFECT_INDEX_0) && m_ai->CastSpell(DIVINE_PROTECTION, *m_bot))
-            return RETURN_CONTINUE;
-    }
-
-    // Check if bot needs to cast a seal on self or judge the target
-    if (CheckSealAndJudgement(pTarget))
-        return RETURN_CONTINUE;
-
-    // Heal
-    if (m_ai->IsHealer())
-    {
-        if (HealPlayer(GetHealTarget()) & (RETURN_NO_ACTION_OK | RETURN_CONTINUE))
-            return RETURN_CONTINUE;
-    }
-    else
-    {
-        // Is this desirable? Debatable.
-        // TODO: In a group/raid with a healer you'd want this bot to focus on DPS (it's not specced/geared for healing either)
-        if (HealPlayer(m_bot) & (RETURN_NO_ACTION_OK | RETURN_CONTINUE))
-            return RETURN_CONTINUE;
-    }
-
-    //Used to determine if this bot has highest threat
-    Unit* newTarget = m_ai->FindAttacker((PlayerbotAI::ATTACKERINFOTYPE)(PlayerbotAI::AIT_VICTIMSELF | PlayerbotAI::AIT_HIGHESTTHREAT), m_bot);
-    if (newTarget && !(m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TANK) && !m_ai->IsNeutralized(newTarget)) // TODO: && party has a tank
-    {
-        if (HealPlayer(m_bot) == RETURN_CONTINUE)
-            return RETURN_CONTINUE;
-
-        // Aggroed by an elite
-        if (m_ai->IsElite(newTarget))
-        {
-            // Try to stun the mob
-            if (HAMMER_OF_JUSTICE > 0 && m_ai->In_Reach(newTarget, HAMMER_OF_JUSTICE) && m_bot->IsSpellReady(HAMMER_OF_JUSTICE) && !newTarget->HasAura(HAMMER_OF_JUSTICE) && m_ai->CastSpell(HAMMER_OF_JUSTICE, *newTarget))
-                return RETURN_CONTINUE;
-
-            // Bot has low life: use divine powers to protect him/herself
-            if (m_ai->GetHealthPercent() < 15)
-            {
-                if (DIVINE_SHIELD > 0 && m_bot->IsSpellReady(DIVINE_SHIELD) && !m_bot->HasAura(DIVINE_SHIELD, EFFECT_INDEX_0) && !m_bot->HasAura(DIVINE_PROTECTION, EFFECT_INDEX_0) && !m_bot->HasAura(FORBEARANCE, EFFECT_INDEX_0) && m_ai->CastSpell(DIVINE_SHIELD, *m_bot))
-                    return RETURN_CONTINUE;
-
-                if (DIVINE_PROTECTION > 0 && m_bot->IsSpellReady(DIVINE_PROTECTION) && !m_bot->HasAura(DIVINE_SHIELD, EFFECT_INDEX_0) && !m_bot->HasAura(DIVINE_PROTECTION, EFFECT_INDEX_0) && !m_bot->HasAura(FORBEARANCE, EFFECT_INDEX_0) && m_ai->CastSpell(DIVINE_PROTECTION, *m_bot))
-                    return RETURN_CONTINUE;
-            }
-
-            // Else: do nothing and pray for tank to pick aggro from mob
-            return RETURN_NO_ACTION_OK;
-        }
-    }
-
-    // Damage rotation
-    switch (spec)
-    {
-        case PALADIN_SPEC_HOLY:
-            if (m_ai->IsHealer())
-                return RETURN_NO_ACTION_OK;
-        // else: DPS (retribution, NEVER protection)
-
-        case PALADIN_SPEC_RETRIBUTION:
-            if (HAMMER_OF_WRATH > 0 && pTarget->GetHealth() < pTarget->GetMaxHealth() * 0.20 && m_ai->CastSpell(HAMMER_OF_WRATH, *pTarget))
-                return RETURN_CONTINUE;
-            if (CRUSADER_STRIKE > 0 && m_bot->IsSpellReady(CRUSADER_STRIKE) && m_ai->CastSpell(CRUSADER_STRIKE, *pTarget))
-                return RETURN_CONTINUE;
-            if (JUDGEMENT > 0 && m_ai->CastSpell(JUDGEMENT, *pTarget))
-                return RETURN_CONTINUE;
-            if (AVENGING_WRATH > 0 && m_ai->CastSpell(AVENGING_WRATH, *m_bot))
-                return RETURN_CONTINUE;
-            /*if (HAMMER_OF_JUSTICE > 0 && !pTarget->HasAura(HAMMER_OF_JUSTICE, EFFECT_INDEX_0) && m_ai->CastSpell (HAMMER_OF_JUSTICE, *pTarget))
-                return RETURN_CONTINUE;*/
-            /*if (HOLY_WRATH > 0 && m_ai->GetAttackerCount() >= 3 && meleeReach && m_ai->CastSpell (HOLY_WRATH, *pTarget))
-                return RETURN_CONTINUE;*/
-            /*if (BLESSING_OF_SACRIFICE > 0 && pVictim == GetMaster() && !GetMaster()->HasAura(BLESSING_OF_SACRIFICE, EFFECT_INDEX_0) && m_ai->CastSpell (BLESSING_OF_SACRIFICE, *GetMaster()))
-                return RETURN_CONTINUE;*/
-            /*if (RIGHTEOUS_DEFENSE > 0 && pVictim != m_bot && m_ai->GetHealthPercent() > 70 && m_ai->CastSpell (RIGHTEOUS_DEFENSE, *pTarget))
-                return RETURN_CONTINUE;*/
-            /*if (DIVINE_FAVOR > 0 && !m_bot->HasAura(DIVINE_FAVOR, EFFECT_INDEX_0) && m_ai->CastSpell (DIVINE_FAVOR, *m_bot))
-                return RETURN_CONTINUE;*/
-            return RETURN_NO_ACTION_OK;
-
-        case PALADIN_SPEC_PROTECTION:
-            //Taunt if orders specify
-            if (CONSECRATION > 0 && m_bot->IsSpellReady(CONSECRATION) && m_ai->CastSpell(CONSECRATION, *pTarget))
-                return RETURN_CONTINUE;
-            if (HOLY_SHIELD > 0 && !m_bot->HasAura(HOLY_SHIELD) && m_ai->CastSpell(HOLY_SHIELD, *m_bot))
-                return RETURN_CONTINUE;
-            if (AVENGERS_SHIELD > 0 && m_bot->IsSpellReady(AVENGERS_SHIELD) && m_ai->CastSpell(AVENGERS_SHIELD, *pTarget))
-                return RETURN_CONTINUE;
-            if (JUDGEMENT > 0 && m_ai->CastSpell(JUDGEMENT, *pTarget))
-                return RETURN_CONTINUE;
-            return RETURN_NO_ACTION_OK;
-    }
-
-    return RETURN_NO_ACTION_OK;
-}
-
-CombatManeuverReturns PlayerbotPaladinAI::DoNextCombatManeuverPVP(Unit* pTarget)
-{
-    if (m_ai->CastSpell(HAMMER_OF_JUSTICE))
-        return RETURN_CONTINUE;
-
-    return DoNextCombatManeuverPVE(pTarget); // TODO: bad idea perhaps, but better than the alternative
-}
-
-CombatManeuverReturns PlayerbotPaladinAI::HealPlayer(Player* target)
-{
-    CombatManeuverReturns r = PlayerbotClassAI::HealPlayer(target);
-    if (r != RETURN_NO_ACTION_OK)
-        return r;
-
-    if (!target->isAlive())
-    {
-        if (REDEMPTION && m_ai->CastSpell(REDEMPTION, *target))
-        {
-            std::string msg = "Resurrecting ";
-            msg += target->GetName();
-            m_bot->Say(msg, LANG_UNIVERSAL);
-            return RETURN_CONTINUE;
-        }
-        return RETURN_NO_ACTION_ERROR; // not error per se - possibly just OOM
-    }
-
-    uint32 dispel = CLEANSE > 0 ? CLEANSE : PURIFY;
-    // Remove negative magic on group members if orders allow bot to do so
-    if (Player* pCursedTarget = GetDispelTarget(DISPEL_MAGIC))
-    {
-        if (dispel > 0 && (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_NODISPEL) == 0 && m_ai->CastSpell(dispel, *pCursedTarget))
-            return RETURN_CONTINUE;
-    }
-    // Remove poison on group members if orders allow bot to do so
-    if (Player* pPoisonedTarget = GetDispelTarget(DISPEL_POISON))
-    {
-        m_ai->TellMaster("Has poison %s :", pPoisonedTarget->GetName());
-        if (dispel > 0 && (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_NODISPEL) == 0 && m_ai->CastSpell(dispel, *pPoisonedTarget))
-            return RETURN_CONTINUE;
-    }
-
-    // Remove disease on group members if orders allow bot to do so
-    if (Player* pDiseasedTarget = GetDispelTarget(DISPEL_DISEASE))
-    {
-        if (dispel > 0 && (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_NODISPEL) == 0 && m_ai->CastSpell(dispel, *pDiseasedTarget))
-            return RETURN_CONTINUE;
-    }
-
-    // Define a tank bot will look at
-    Unit* pMainTank = GetHealTarget(JOB_TANK);
-
-    // If target is out of range (40 yards) and is a tank: move towards it
-    // Other classes have to adjust their position to the healers
-    // TODO: This code should be common to all healers and will probably
-    // move to a more suitable place
-    if (pMainTank && !m_ai->In_Reach(pMainTank, FLASH_OF_LIGHT))
-    {
-        m_bot->GetMotionMaster()->MoveFollow(target, 39.0f, m_bot->GetOrientation());
-        return RETURN_CONTINUE;
-    }
-
-    uint8 hp = target->GetHealthPercent();
-
-    // Everyone is healthy enough, return OK. MUST correlate to highest value below (should be last HP check)
-    if (hp >= 90)
-        return RETURN_NO_ACTION_OK;
-
-    if (hp < 10 && LAY_ON_HANDS && m_bot->IsSpellReady(LAY_ON_HANDS) && m_ai->In_Reach(target, LAY_ON_HANDS) && m_ai->CastSpell(LAY_ON_HANDS, *target))
-        return RETURN_CONTINUE;
-
-    // Target is a moderately wounded healer or a badly wounded not tank? Blessing of Protection!
-    if (BLESSING_OF_PROTECTION > 0
-            && ((hp < 25 && (GetTargetJob(target) & JOB_HEAL)) || (hp < 15 && !(GetTargetJob(target) & JOB_TANK)))
-            && m_bot->IsSpellReady(BLESSING_OF_PROTECTION) && m_ai->In_Reach(target, BLESSING_OF_PROTECTION)
-            && !target->HasAura(FORBEARANCE, EFFECT_INDEX_0)
-            && !target->HasAura(BLESSING_OF_PROTECTION, EFFECT_INDEX_0) && !target->HasAura(DIVINE_PROTECTION, EFFECT_INDEX_0)
-            && !target->HasAura(DIVINE_SHIELD, EFFECT_INDEX_0)
-            && m_ai->CastSpell(BLESSING_OF_PROTECTION, *target))
-        return RETURN_CONTINUE;
-
-    // Low HP : activate Divine Favor to make next heal a critical heal
-    if (hp < 25 && DIVINE_FAVOR > 0 && !m_bot->HasAura(DIVINE_FAVOR, EFFECT_INDEX_0) && m_bot->IsSpellReady(DIVINE_FAVOR) && m_ai->CastSpell(DIVINE_FAVOR, *m_bot))
-        return RETURN_CONTINUE;
-
-    if (hp < 40 && FLASH_OF_LIGHT && m_ai->In_Reach(target, FLASH_OF_LIGHT) && m_ai->CastSpell(FLASH_OF_LIGHT, *target))
-        return RETURN_CONTINUE;
-
-    if (hp < 60 && HOLY_SHOCK && m_ai->In_Reach(target, HOLY_SHOCK) && m_ai->CastSpell(HOLY_SHOCK, *target))
-        return RETURN_CONTINUE;
-
-    if (hp < 90 && HOLY_LIGHT && m_ai->In_Reach(target, HOLY_LIGHT) && m_ai->CastSpell(HOLY_LIGHT, *target))
-        return RETURN_CONTINUE;
-
-    return RETURN_NO_ACTION_UNKNOWN;
-} // end HealTarget
-
-void PlayerbotPaladinAI::CheckAuras()
-{
-    if (!m_ai)  return;
-    if (!m_bot) return;
-
-    uint32 spec = m_bot->GetSpec();
-    PlayerbotAI::ResistType ResistType = m_ai->GetResistType();
-    //Bool to determine whether or not we have resist orders
-    bool resist = false;
-
-    // If we have resist orders, adjust accordingly
-    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_RESIST_FROST)
-    {
-        if (!m_bot->HasAura(FROST_RESISTANCE_AURA) && FROST_RESISTANCE_AURA > 0 && !m_bot->HasAura(FROST_RESISTANCE_AURA))
-            m_ai->CastSpell(FROST_RESISTANCE_AURA);
-        return;
-    }
-    else if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_RESIST_FIRE)
-    {
-        if (!m_bot->HasAura(FIRE_RESISTANCE_AURA) && FIRE_RESISTANCE_AURA > 0 && !m_bot->HasAura(FIRE_RESISTANCE_AURA))
-            m_ai->CastSpell(FIRE_RESISTANCE_AURA);
-        return;
-    }
-    else if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_RESIST_SHADOW)
-    {
-        // Shadow protection check is broken, they stack!
-        if (!m_bot->HasAura(SHADOW_RESISTANCE_AURA) && SHADOW_RESISTANCE_AURA > 0 && !m_bot->HasAura(SHADOW_RESISTANCE_AURA)) // /*&& !m_bot->HasAura(PRAYER_OF_SHADOW_PROTECTION)*/ /*&& !m_bot->HasAura(PRAYER_OF_SHADOW_PROTECTION)*/
-            m_ai->CastSpell(SHADOW_RESISTANCE_AURA);
-        return;
-    }
-
-    // if there is a tank in the group, use concentration aura
-    bool tankInGroup = false;
-    if (m_bot->GetGroup())
-    {
-        Group::MemberSlotList const& groupSlot = m_bot->GetGroup()->GetMemberSlots();
-        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
-        {
-            Player* groupMember = sObjectMgr.GetPlayer(itr->guid);
-            if (!groupMember)
-                continue;
-
-            if (GetTargetJob(groupMember) & JOB_TANK)
-            {
-                tankInGroup = true;
-                break;
-            }
-        }
-    }
-
-    // If we have no resist orders, adjust aura based on spec or tank
-    if (spec == PALADIN_SPEC_PROTECTION || tankInGroup)
-    {
-        if (DEVOTION_AURA > 0 && !m_bot->HasAura(DEVOTION_AURA))
-            m_ai->CastSpell(DEVOTION_AURA);
-        return;
-    }
-    else if (spec == PALADIN_SPEC_HOLY)
-    {
-        if (CONCENTRATION_AURA > 0 && !m_bot->HasAura(CONCENTRATION_AURA))
-            m_ai->CastSpell(CONCENTRATION_AURA);
-        return;
-    }
-    else if (spec == PALADIN_SPEC_RETRIBUTION)
-    {
-        if (RETRIBUTION_AURA > 0 && !m_bot->HasAura(RETRIBUTION_AURA))
-            m_ai->CastSpell(RETRIBUTION_AURA);
-        return;
-    }
-}
-
-// Check if the paladin bot needs to cast/refresh a seal on him/herself
-// also check if the paladin bot needs to judge its target and first buff
-// him/herself with the relevant seal
-// TODO: handle other paladins in group/raid, for example to cast Seal/Judgement of Light
-bool PlayerbotPaladinAI::CheckSealAndJudgement(Unit* pTarget)
-{
-    if (!m_ai)      return false;
-    if (!m_bot)     return false;
-    if (!pTarget)   return false;
-
-    Creature* pCreature = (Creature*) pTarget;
-
-    // Prevent low health humanoid from fleeing by judging them with Seal of Justice
-    if (pCreature && pCreature->GetCreatureInfo()->CreatureType == CREATURE_TYPE_HUMANOID && pTarget->GetHealthPercent() < 20 && !pCreature->IsWorldBoss())
-    {
-        if (SEAL_OF_JUSTICE > 0 && !m_bot->HasAura(SEAL_OF_JUSTICE, EFFECT_INDEX_0) && m_ai->CastSpell(SEAL_OF_JUSTICE, *m_bot))
-        {
-            m_CurrentSeal = SEAL_OF_JUSTICE;
-            m_CurrentJudgement = 0;
-            return true;
-        }
-    }
-
-    // Bot already defined a seal and a judgement and each is active on bot and target: don't waste time to go further
-    if (m_CurrentSeal > 0 && m_bot->HasAura(m_CurrentSeal, EFFECT_INDEX_0) && m_CurrentJudgement > 0 && pTarget->HasAura(m_CurrentJudgement, EFFECT_INDEX_0))
-        return false;
-
-    // Refresh judgement if needed by forcing paladin bot to cast seal and judgement anew
-    // But first, unleash current seal if bot can do extra damage to the target in the process
-    if (m_CurrentJudgement > 0 && !pTarget->HasAura(m_CurrentJudgement, EFFECT_INDEX_0))
-    {
-        if (m_bot->HasAura(SEAL_OF_COMMAND, EFFECT_INDEX_0) || m_bot->HasAura(SEAL_OF_RIGHTEOUSNESS, EFFECT_INDEX_0))
-            if (JUDGEMENT > 0 && m_bot->IsSpellReady(JUDGEMENT) && m_ai->In_Reach(pTarget, JUDGEMENT))
-                m_ai->CastSpell(JUDGEMENT, *pTarget);
-
-        m_CurrentJudgement = 0;
-        m_CurrentSeal = 0;
-        return false;
-    }
-
-    // Judgement is still active on target: refresh seal on bot if needed
-    if (m_CurrentJudgement > 0 && m_CurrentSeal > 0 && !m_bot->HasAura(m_CurrentSeal, EFFECT_INDEX_0))
-        if (m_CurrentSeal > 0 && !m_bot->HasAura(m_CurrentSeal, EFFECT_INDEX_0) && m_ai->CastSpell(m_CurrentSeal, *m_bot))
-            return true;
-
-    // No judgement on target but bot has seal active: time to judge the target
-    if (m_CurrentJudgement == 0 && m_CurrentSeal > 0 && m_bot->HasAura(m_CurrentSeal, EFFECT_INDEX_0))
-    {
-        if (JUDGEMENT > 0 && m_bot->IsSpellReady(JUDGEMENT) && m_ai->In_Reach(pTarget, JUDGEMENT) && m_ai->CastSpell(JUDGEMENT, *pTarget))
-        {
-            if (m_CurrentSeal == SEAL_OF_JUSTICE)
-                m_CurrentJudgement = JUDGEMENT_OF_JUSTICE;
-            else if (m_CurrentSeal == SEAL_OF_WISDOM)
-                m_CurrentJudgement = JUDGEMENT_OF_WISDOM;
-            else if (m_CurrentSeal == SEAL_OF_THE_CRUSADER)
-                m_CurrentJudgement = JUDGEMENT_OF_THE_CRUSADER;
-            else
-                return false;
-
-            // Set current seal to 0 to force the bot to seal him/herself for combat now that the target is judged
-            m_CurrentSeal = 0;
-            return true;
-        }
-
-        return false;
-    }
-
-    // Now bot casts seal on him/herself
-    // No judgement on target: look for best seal to judge target next
-    // Target already judged: bot will buff him/herself for combat according to spec/orders
-    uint32 spec = m_bot->GetSpec();
-
-    // Bypass spec if combat orders were given
-    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_HEAL) spec = PALADIN_SPEC_HOLY;
-    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TANK) spec = PALADIN_SPEC_PROTECTION;
-    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_ASSIST) spec = PALADIN_SPEC_RETRIBUTION;
-
-    if (m_CurrentJudgement == 0)
-    {
-        if (spec == PALADIN_SPEC_HOLY || m_ai->IsHealer())
-            m_CurrentSeal = SEAL_OF_WISDOM;
-        else
-            m_CurrentSeal = SEAL_OF_THE_CRUSADER;
-    }
-    else
-    {
-        if (spec == PALADIN_SPEC_HOLY)
-            m_CurrentSeal = SEAL_OF_WISDOM;
-        else if (spec == PALADIN_SPEC_PROTECTION)
-            m_CurrentSeal = SEAL_OF_RIGHTEOUSNESS;
-        else if (spec == PALADIN_SPEC_RETRIBUTION && SEAL_OF_COMMAND > 0)
-            m_CurrentSeal = SEAL_OF_COMMAND;
-        // no spec: try Seal of Righteouness
-        else
-            m_CurrentSeal = SEAL_OF_RIGHTEOUSNESS;
-    }
-
-    if (m_CurrentSeal > 0 && !m_bot->HasAura(m_CurrentSeal, EFFECT_INDEX_0) && m_ai->CastSpell(m_CurrentSeal, *m_bot))
-        return true;
-
-    return false;
-}
-
-void PlayerbotPaladinAI::DoNonCombatActions()
-{
-    if (!m_ai)   return;
-    if (!m_bot)  return;
-
-    if (!m_bot->isAlive() || m_bot->IsInDuel()) return;
-
-    CheckAuras();
-
-    //Put up RF if tank
-    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TANK)
-        m_ai->SelfBuff(RIGHTEOUS_FURY);
-    //Disable RF if not tank
-    else if (m_bot->HasAura(RIGHTEOUS_FURY))
-        m_bot->RemoveAurasDueToSpell(RIGHTEOUS_FURY);
-
-    // Revive
-    if (HealPlayer(GetResurrectionTarget()) & RETURN_CONTINUE)
-        return;
-
-    // Heal
-    if (m_ai->IsHealer())
-    {
-        if (HealPlayer(GetHealTarget()) & RETURN_CONTINUE)
-            return;// RETURN_CONTINUE;
-    }
-    else
-    {
-        // Is this desirable? Debatable.
-        // TODO: In a group/raid with a healer you'd want this bot to focus on DPS (it's not specced/geared for healing either)
-        if (HealPlayer(m_bot) & RETURN_CONTINUE)
-            return;// RETURN_CONTINUE;
-    }
-
-    // buff group
-    if (Buff(&PlayerbotPaladinAI::BuffHelper, 1) & RETURN_CONTINUE) // Paladin's BuffHelper takes care of choosing the specific Blessing so just pass along a non-zero value
-        return;
-
-    // hp/mana check
-    if (EatDrinkBandage())
-        return;
-
-    // Search and apply stones to weapons
-    // Mainhand ...
-    Item* stone, * weapon;
-    weapon = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
-    if (weapon && weapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT) == 0)
-    {
-        stone = m_ai->FindStoneFor(weapon);
-        if (stone)
-        {
-            m_ai->UseItem(stone, EQUIPMENT_SLOT_MAINHAND);
-            m_ai->SetIgnoreUpdateTime(5);
-        }
-    }
-}
-
-/**
- * BuffHelper
- * BuffHelper is a static function, takes an AI, spellId (ignored for paladin) and a target and attempts to buff them as well as their pets as
- * best as possible.
- *
- * Return bool - returns true if a buff took place.
- */
-bool PlayerbotPaladinAI::BuffHelper(PlayerbotAI* ai, uint32 spellId, Unit* target)
-{
-    if (!ai)          return false;
-    if (spellId == 0) return false;
-    if (!target)      return false;
-
-    PlayerbotPaladinAI* c = (PlayerbotPaladinAI*) ai->GetClassAI();
-    uint32 bigSpellId = 0;
-
-    Pet* pet = target->GetPet();
-    uint32 petSpellId = 0, petBigSpellId = 0;
-
-    // See which buff is appropriate according to class
-    // TODO: take into account other paladins in the group
-    switch (target->getClass())
-    {
-        case CLASS_DRUID:
-        case CLASS_SHAMAN:
-        case CLASS_PALADIN:
-            spellId = c->BLESSING_OF_MIGHT;
-            if (!spellId)
-            {
-                spellId = c->BLESSING_OF_KINGS;
-                if (!spellId)
-                {
-                    spellId = c->BLESSING_OF_WISDOM;
-                    if (!spellId)
-                    {
-                        spellId = c->BLESSING_OF_SANCTUARY;
-                        if (!spellId)
-                            return false;
-                    }
-                }
-            }
-            break;
-        case CLASS_HUNTER:
-            if (pet && ai->CanReceiveSpecificSpell(SPELL_BLESSING, pet) && !pet->HasAuraType(SPELL_AURA_MOD_UNATTACKABLE))
-            {
-                petSpellId = c->BLESSING_OF_MIGHT;
-                if (!petSpellId)
-                {
-                    petSpellId = c->BLESSING_OF_KINGS;
-                    if (!petSpellId)
-                        petSpellId = c->BLESSING_OF_SANCTUARY;
-                }
-            }
-        case CLASS_ROGUE:
-        case CLASS_WARRIOR:
-            spellId = c->BLESSING_OF_MIGHT;
-            if (!spellId)
-            {
-                spellId = c->BLESSING_OF_KINGS;
-                if (!spellId)
-                {
-                    spellId = c->BLESSING_OF_SANCTUARY;
-                    if (!spellId)
-                        return false;
-                }
-            }
-            break;
-        case CLASS_WARLOCK:
-            if (pet && ai->CanReceiveSpecificSpell(SPELL_BLESSING, pet) && !pet->HasAuraType(SPELL_AURA_MOD_UNATTACKABLE))
-            {
-                if (pet->GetPowerType() == POWER_MANA)
-                    petSpellId = c->BLESSING_OF_WISDOM;
-                else
-                    petSpellId = c->BLESSING_OF_MIGHT;
-
-                if (!petSpellId)
-                {
-                    petSpellId = c->BLESSING_OF_KINGS;
-                    if (!petSpellId)
-                        petSpellId = c->BLESSING_OF_SANCTUARY;
-                }
-            }
-        case CLASS_PRIEST:
-        case CLASS_MAGE:
-            spellId = c->BLESSING_OF_WISDOM;
-            if (!spellId)
-            {
-                spellId = c->BLESSING_OF_KINGS;
-                if (!spellId)
-                {
-                    spellId = c->BLESSING_OF_SANCTUARY;
-                    if (!spellId)
-                        return false;
-                }
-            }
-            break;
-    }
-
-    if (petSpellId == c->BLESSING_OF_MIGHT)
-        petBigSpellId = c->GREATER_BLESSING_OF_MIGHT;
-    else if (petSpellId == c->BLESSING_OF_WISDOM)
-        petBigSpellId = c->GREATER_BLESSING_OF_WISDOM;
-    else if (petSpellId == c->BLESSING_OF_KINGS)
-        petBigSpellId = c->GREATER_BLESSING_OF_KINGS;
-    else if (petSpellId == c->BLESSING_OF_SANCTUARY)
-        petBigSpellId = c->GREATER_BLESSING_OF_SANCTUARY;
-
-    if (spellId == c->BLESSING_OF_MIGHT)
-        bigSpellId = c->GREATER_BLESSING_OF_MIGHT;
-    else if (spellId == c->BLESSING_OF_WISDOM)
-        bigSpellId = c->GREATER_BLESSING_OF_WISDOM;
-    else if (spellId == c->BLESSING_OF_KINGS)
-        bigSpellId = c->GREATER_BLESSING_OF_KINGS;
-    else if (spellId == c->BLESSING_OF_SANCTUARY)
-        bigSpellId = c->GREATER_BLESSING_OF_SANCTUARY;
-
-    if (pet && !pet->HasAuraType(SPELL_AURA_MOD_UNATTACKABLE) && ai->HasSpellReagents(petBigSpellId) && ai->Buff(petBigSpellId, pet))
-        return true;
-    if (ai->HasSpellReagents(bigSpellId) && ai->Buff(bigSpellId, target))
-        return true;
-    if ((pet && !pet->HasAuraType(SPELL_AURA_MOD_UNATTACKABLE) && ai->Buff(petSpellId, pet)) || ai->Buff(spellId, target))
-        return true;
-    return false;
-}
-
-// Match up with "Pull()" below
-bool PlayerbotPaladinAI::CanPull()
-{
-    if (EXORCISM && m_bot->IsSpellReady(EXORCISM))
-        return true;
-
-    return false;
-}
-
-// Match up with "CanPull()" above
-bool PlayerbotPaladinAI::Pull()
-{
-    if (EXORCISM && m_ai->CastSpell(EXORCISM))
-        return true;
-
-    return false;
-}
-
-bool PlayerbotPaladinAI::CastHoTOnTank()
-{
-    if (!m_ai) return false;
-
-    if ((PlayerbotAI::ORDERS_HEAL & m_ai->GetCombatOrder()) == 0) return false;
-
-    // Paladin: Sheath of Light (with talents), Flash of Light (with Infusion of Light talent and only on a target with the Sacred Shield buff),
-    //          Holy Shock (with Tier 8 set bonus)
-    // None of these are HoTs to cast before pulling (I think)
-
-    return false;
-}
diff --git a/src/game/PlayerBot/AI/PlayerbotPaladinAI.h b/src/game/PlayerBot/AI/PlayerbotPaladinAI.h
deleted file mode 100644
index 9a4bfb8c4..000000000
--- a/src/game/PlayerBot/AI/PlayerbotPaladinAI.h
+++ /dev/null
@@ -1,195 +0,0 @@
-#ifndef _PlayerbotPaladinAI_H
-#define _PlayerbotPaladinAI_H
-
-#include "../Base/PlayerbotClassAI.h"
-
-enum
-{
-    Combat,
-    Healing
-};
-
-enum PaladinSpells
-{
-    AVENGERS_SHIELD_1               = 31935,
-    AVENGING_WRATH_1                = 31884,
-    BLESSING_OF_KINGS_1             = 20217,
-    BLESSING_OF_MIGHT_1             = 19740,
-    BLESSING_OF_SANCTUARY_1         = 20911,
-    BLESSING_OF_WISDOM_1            = 19742,
-    CLEANSE_1                       = 4987,
-    CONCENTRATION_AURA_1            = 19746,
-    CONSECRATION_1                  = 26573,
-    CRUSADER_AURA_1                 = 32223,
-    CRUSADER_STRIKE_1               = 35395,
-    DEVOTION_AURA_1                 = 465,
-    DIVINE_FAVOR_1                  = 20216,
-    DIVINE_ILLUMINATION_1           = 31842,
-    DIVINE_INTERVENTION_1           = 19752,
-    DIVINE_PROTECTION_1             = 498,
-    DIVINE_SHIELD_1                 = 642,
-    EXORCISM_1                      = 879,
-    FIRE_RESISTANCE_AURA_1          = 19891,
-    FLASH_OF_LIGHT_1                = 19750,
-    FROST_RESISTANCE_AURA_1         = 19888,
-    GREATER_BLESSING_OF_KINGS_1     = 25898,
-    GREATER_BLESSING_OF_MIGHT_1     = 25782,
-    GREATER_BLESSING_OF_SANCTUARY_1 = 25899,
-    GREATER_BLESSING_OF_WISDOM_1    = 25894,
-    HAMMER_OF_JUSTICE_1             = 853,
-    HAMMER_OF_WRATH_1               = 24275,
-    HAND_OF_FREEDOM_1               = 1044,
-    BLESSING_OF_PROTECTION_1        = 1022,
-    BLESSING_OF_SACRIFICE_1         = 6940,
-    HAND_OF_SALVATION_1             = 1038,
-    HOLY_LIGHT_1                    = 635,
-    HOLY_SHIELD_1                   = 20925,
-    HOLY_SHOCK_1                    = 20473,
-    HOLY_WRATH_1                    = 2812,
-    JUDGEMENT_1                     = 20271,
-    LAY_ON_HANDS_1                  = 633,
-    PURIFY_1                        = 1152,
-    REDEMPTION_1                    = 7328,
-    REPENTANCE_1                    = 20066,
-    RETRIBUTION_AURA_1              = 7294,
-    RIGHTEOUS_DEFENSE_1             = 31789,
-    RIGHTEOUS_FURY_1                = 25780,
-    SEAL_OF_COMMAND_1               = 20375,
-    SEAL_OF_JUSTICE_1               = 20164,
-    SEAL_OF_LIGHT_1                 = 20165,
-    SEAL_OF_RIGHTEOUSNESS_1         = 21084,
-    SEAL_OF_VENGEANCE_1             = 31801,
-    SEAL_OF_WISDOM_1                = 20166,
-    SEAL_OF_THE_CRUSADER_1          = 21082,
-    SENSE_UNDEAD_1                  = 5502,
-    SHADOW_RESISTANCE_AURA_1        = 19876,
-    TURN_EVIL_1                     = 10326,
-
-    // Judgement auras on target
-    JUDGEMENT_OF_WISDOM             = 20355, // rank 2: 20354, rank 1: 20186
-    JUDGEMENT_OF_JUSTICE            = 20184,
-    JUDGEMENT_OF_THE_CRUSADER       = 20303  // rank 5: 20302, rank 4: 20301, rank 3: 20300, rank 2: 20188, rank 1: 21183
-};
-//class Player;
-
-class PlayerbotPaladinAI : PlayerbotClassAI
-{
-    public:
-        PlayerbotPaladinAI(Player* const master, Player* const bot, PlayerbotAI* const ai);
-        virtual ~PlayerbotPaladinAI();
-
-        // all combat actions go here
-        CombatManeuverReturns DoFirstCombatManeuver(Unit* pTarget);
-        CombatManeuverReturns DoNextCombatManeuver(Unit* pTarget);
-        bool Pull();
-
-        // all non combat actions go here, ex buffs, heals, rezzes
-        void DoNonCombatActions();
-
-        // Utility Functions
-        bool CanPull();
-        bool CastHoTOnTank();
-
-    private:
-        CombatManeuverReturns DoFirstCombatManeuverPVE(Unit* pTarget);
-        CombatManeuverReturns DoNextCombatManeuverPVE(Unit* pTarget);
-        CombatManeuverReturns DoFirstCombatManeuverPVP(Unit* pTarget);
-        CombatManeuverReturns DoNextCombatManeuverPVP(Unit* pTarget);
-
-        // Heals the target based off its hps
-        CombatManeuverReturns HealPlayer(Player* target);
-
-        //Changes aura according to spec/orders
-        void CheckAuras();
-        //Changes Seal according to spec
-        bool CheckSealAndJudgement(Unit* target);
-        uint32 m_CurrentSeal;
-        uint32 m_CurrentJudgement;
-
-        static bool BuffHelper(PlayerbotAI* ai, uint32 spellId, Unit* target);
-
-        // make this public so the static function can access it. Either that or make an accessor function for each
-    public:
-        // Retribution
-        uint32 RETRIBUTION_AURA,
-               SEAL_OF_COMMAND,
-               JUDGEMENT,
-               GREATER_BLESSING_OF_WISDOM,
-               GREATER_BLESSING_OF_MIGHT,
-               BLESSING_OF_WISDOM,
-               BLESSING_OF_MIGHT,
-               HAMMER_OF_JUSTICE,
-               RIGHTEOUS_FURY,
-               CRUSADER_AURA,
-               CRUSADER_STRIKE,
-               AVENGING_WRATH,
-               JUDGEMENT_OF_JUSTICE,
-               ART_OF_WAR;
-
-        // Holy
-        uint32 FLASH_OF_LIGHT,
-               HOLY_LIGHT,
-               DIVINE_SHIELD,
-               HAMMER_OF_WRATH,
-               CONSECRATION,
-               CONCENTRATION_AURA,
-               DIVINE_FAVOR,
-               SACRED_SHIELD,
-               HOLY_SHOCK,
-               HOLY_WRATH,
-               LAY_ON_HANDS,
-               EXORCISM,
-               REDEMPTION,
-               DIVINE_PLEA,
-               SEAL_OF_JUSTICE,
-               SEAL_OF_LIGHT,
-               SEAL_OF_RIGHTEOUSNESS,
-               SEAL_OF_VENGEANCE,
-               SEAL_OF_WISDOM,
-               SEAL_OF_THE_CRUSADER,
-               PURIFY,
-               CLEANSE;
-
-        // Protection
-        uint32 GREATER_BLESSING_OF_KINGS,
-               BLESSING_OF_KINGS,
-               BLESSING_OF_PROTECTION,
-               SHADOW_RESISTANCE_AURA,
-               DEVOTION_AURA,
-               FIRE_RESISTANCE_AURA,
-               FROST_RESISTANCE_AURA,
-               DEFENSIVE_STANCE,
-               BERSERKER_STANCE,
-               BATTLE_STANCE,
-               DIVINE_PROTECTION,
-               DIVINE_INTERVENTION,
-               HOLY_SHIELD,
-               AVENGERS_SHIELD,
-               RIGHTEOUS_DEFENSE,
-               BLESSING_OF_SANCTUARY,
-               GREATER_BLESSING_OF_SANCTUARY,
-               BLESSING_OF_SACRIFICE;
-
-        // cannot be protected
-        uint32 FORBEARANCE;
-
-        // racial
-        uint32 ARCANE_TORRENT,
-               GIFT_OF_THE_NAARU,
-               STONEFORM,
-               ESCAPE_ARTIST,
-               PERCEPTION,
-               SHADOWMELD,
-               BLOOD_FURY,
-               WAR_STOMP,
-               BERSERKING,
-               WILL_OF_THE_FORSAKEN;
-
-        //Non-Stacking buffs
-        uint32 PRAYER_OF_SHADOW_PROTECTION;
-
-    private:
-        uint32 SpellSequence, CombatCounter, HealCounter;
-};
-
-#endif
diff --git a/src/game/PlayerBot/AI/PlayerbotPriestAI.cpp b/src/game/PlayerBot/AI/PlayerbotPriestAI.cpp
deleted file mode 100644
index 44119f233..000000000
--- a/src/game/PlayerBot/AI/PlayerbotPriestAI.cpp
+++ /dev/null
@@ -1,600 +0,0 @@
-/*
- * This file is part of the CMaNGOS Project. See AUTHORS file for Copyright information
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "PlayerbotPriestAI.h"
-
-class PlayerbotAI;
-
-PlayerbotPriestAI::PlayerbotPriestAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
-{
-    RENEW                         = m_ai->initSpell(RENEW_1);
-    LESSER_HEAL                   = m_ai->initSpell(LESSER_HEAL_1);
-    FLASH_HEAL                    = m_ai->initSpell(FLASH_HEAL_1);
-    (FLASH_HEAL > 0) ? FLASH_HEAL : FLASH_HEAL = LESSER_HEAL;
-    HEAL                          = m_ai->initSpell(HEAL_1);
-    (HEAL > 0) ? HEAL : HEAL = FLASH_HEAL;
-    GREATER_HEAL                  = m_ai->initSpell(GREATER_HEAL_1);
-    (GREATER_HEAL > 0) ? GREATER_HEAL : GREATER_HEAL = HEAL;
-    RESURRECTION                  = m_ai->initSpell(RESURRECTION_1);
-    SMITE                         = m_ai->initSpell(SMITE_1);
-    MANA_BURN                     = m_ai->initSpell(MANA_BURN_1);
-    HOLY_NOVA                     = m_ai->initSpell(HOLY_NOVA_1);
-    HOLY_FIRE                     = m_ai->initSpell(HOLY_FIRE_1);
-    DESPERATE_PRAYER              = m_ai->initSpell(DESPERATE_PRAYER_1);
-    PRAYER_OF_HEALING             = m_ai->initSpell(PRAYER_OF_HEALING_1);
-    CIRCLE_OF_HEALING             = m_ai->initSpell(CIRCLE_OF_HEALING_1);
-    BINDING_HEAL                  = m_ai->initSpell(BINDING_HEAL_1);
-    PRAYER_OF_MENDING             = m_ai->initSpell(PRAYER_OF_MENDING_1);
-    CURE_DISEASE                  = m_ai->initSpell(CURE_DISEASE_1);
-    ABOLISH_DISEASE               = m_ai->initSpell(ABOLISH_DISEASE_1);
-    SHACKLE_UNDEAD                = m_ai->initSpell(SHACKLE_UNDEAD_1);
-
-    // SHADOW
-    FADE                          = m_ai->initSpell(FADE_1);
-    SHADOW_WORD_PAIN              = m_ai->initSpell(SHADOW_WORD_PAIN_1);
-    MIND_BLAST                    = m_ai->initSpell(MIND_BLAST_1);
-    SCREAM                        = m_ai->initSpell(PSYCHIC_SCREAM_1);
-    MIND_FLAY                     = m_ai->initSpell(MIND_FLAY_1);
-    DEVOURING_PLAGUE              = m_ai->initSpell(DEVOURING_PLAGUE_1);
-    SHADOW_PROTECTION             = m_ai->initSpell(SHADOW_PROTECTION_1);
-    VAMPIRIC_TOUCH                = m_ai->initSpell(VAMPIRIC_TOUCH_1);
-    PRAYER_OF_SHADOW_PROTECTION   = m_ai->initSpell(PRAYER_OF_SHADOW_PROTECTION_1);
-    SHADOWFIEND                   = m_ai->initSpell(SHADOWFIEND_1);
-    SHADOWFORM                    = m_ai->initSpell(SHADOWFORM_1);
-    VAMPIRIC_EMBRACE              = m_ai->initSpell(VAMPIRIC_EMBRACE_1);
-
-    // RANGED COMBAT
-    SHOOT                         = m_ai->initSpell(SHOOT_1);
-
-    // DISCIPLINE
-    INNER_FIRE                    = m_ai->initSpell(INNER_FIRE_1);
-    POWER_WORD_SHIELD             = m_ai->initSpell(POWER_WORD_SHIELD_1);
-    POWER_WORD_FORTITUDE          = m_ai->initSpell(POWER_WORD_FORTITUDE_1);
-    PRAYER_OF_FORTITUDE           = m_ai->initSpell(PRAYER_OF_FORTITUDE_1);
-    FEAR_WARD                     = m_ai->initSpell(FEAR_WARD_1);
-    DIVINE_SPIRIT                 = m_ai->initSpell(DIVINE_SPIRIT_1);
-    PRAYER_OF_SPIRIT              = m_ai->initSpell(PRAYER_OF_SPIRIT_1);
-    MASS_DISPEL                   = m_ai->initSpell(MASS_DISPEL_1);
-    POWER_INFUSION                = m_ai->initSpell(POWER_INFUSION_1);
-    INNER_FOCUS                   = m_ai->initSpell(INNER_FOCUS_1);
-    PRIEST_DISPEL_MAGIC           = m_ai->initSpell(DISPEL_MAGIC_1);
-
-    RECENTLY_BANDAGED  = 11196; // first aid check
-
-    // racial
-    ARCANE_TORRENT                = m_ai->initSpell(ARCANE_TORRENT_MANA_CLASSES);
-    GIFT_OF_THE_NAARU             = m_ai->initSpell(GIFT_OF_THE_NAARU_ALL); // draenei
-    STONEFORM                     = m_ai->initSpell(STONEFORM_ALL); // dwarf
-    ELUNES_GRACE                  = m_ai->initSpell(ELUNES_GRACE_1); // night elf
-    PERCEPTION                    = m_ai->initSpell(PERCEPTION_ALL); // human
-    SHADOWMELD                    = m_ai->initSpell(SHADOWMELD_ALL);
-    BERSERKING                    = m_ai->initSpell(BERSERKING_ALL); // troll
-    WILL_OF_THE_FORSAKEN          = m_ai->initSpell(WILL_OF_THE_FORSAKEN_ALL); // undead
-}
-
-PlayerbotPriestAI::~PlayerbotPriestAI() {}
-
-CombatManeuverReturns PlayerbotPriestAI::DoFirstCombatManeuver(Unit* pTarget)
-{
-    // There are NPCs in BGs and Open World PvP, so don't filter this on PvP scenarios (of course if PvP targets anyone but tank, all bets are off anyway)
-    // Wait until the tank says so, until any non-tank gains aggro or X seconds - whichever is shortest
-    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO)
-    {
-        if (m_WaitUntil > m_ai->CurrentTime() && m_ai->GroupTankHoldsAggro())
-        {
-            if (PlayerbotAI::ORDERS_HEAL & m_ai->GetCombatOrder())
-                return HealPlayer(GetHealTarget());
-            else
-                return RETURN_NO_ACTION_OK; // wait it out
-        }
-        else
-        {
-            m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO);
-        }
-    }
-
-    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TEMP_WAIT_OOC)
-    {
-        if (m_WaitUntil > m_ai->CurrentTime() && m_ai->IsGroupReady())
-            return RETURN_NO_ACTION_OK; // wait it out
-        else
-            m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_OOC);
-    }
-
-    switch (m_ai->GetScenarioType())
-    {
-        case PlayerbotAI::SCENARIO_PVP_DUEL:
-        case PlayerbotAI::SCENARIO_PVP_BG:
-        case PlayerbotAI::SCENARIO_PVP_ARENA:
-        case PlayerbotAI::SCENARIO_PVP_OPENWORLD:
-            return DoFirstCombatManeuverPVP(pTarget);
-        case PlayerbotAI::SCENARIO_PVE:
-        case PlayerbotAI::SCENARIO_PVE_ELITE:
-        case PlayerbotAI::SCENARIO_PVE_RAID:
-        default:
-            return DoFirstCombatManeuverPVE(pTarget);
-            break;
-    }
-
-    return RETURN_NO_ACTION_ERROR;
-}
-
-CombatManeuverReturns PlayerbotPriestAI::DoFirstCombatManeuverPVE(Unit* /*pTarget*/)
-{
-    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
-    if (!m_bot) return RETURN_NO_ACTION_ERROR;
-
-    if (m_ai->IsHealer())
-    {
-        // TODO: This must be done with toggles: FullHealth allowed
-        Unit* healTarget = GetHealTarget(JOB_TANK);
-        // This is cast on a target, which activates (and switches to another target within the group) upon receiving+healing damage
-        // Mana efficient even at one use
-        if (healTarget && PRAYER_OF_MENDING > 0 && m_ai->In_Reach(healTarget, PRAYER_OF_MENDING) && !healTarget->HasAura(PRAYER_OF_MENDING, EFFECT_INDEX_0) && CastSpell(PRAYER_OF_MENDING, healTarget) & RETURN_CONTINUE)
-            return RETURN_FINISHED_FIRST_MOVES;
-
-        // Cast renew on tank
-        if (CastHoTOnTank())
-            return RETURN_FINISHED_FIRST_MOVES;
-    }
-    return RETURN_NO_ACTION_OK;
-}
-
-CombatManeuverReturns PlayerbotPriestAI::DoFirstCombatManeuverPVP(Unit* /*pTarget*/)
-{
-    return RETURN_NO_ACTION_OK;
-}
-
-CombatManeuverReturns PlayerbotPriestAI::DoNextCombatManeuver(Unit* pTarget)
-{
-    // Face enemy, make sure bot is attacking
-    m_ai->FaceTarget(pTarget);
-
-    switch (m_ai->GetScenarioType())
-    {
-        case PlayerbotAI::SCENARIO_PVP_DUEL:
-        case PlayerbotAI::SCENARIO_PVP_BG:
-        case PlayerbotAI::SCENARIO_PVP_ARENA:
-        case PlayerbotAI::SCENARIO_PVP_OPENWORLD:
-            return DoNextCombatManeuverPVP(pTarget);
-        case PlayerbotAI::SCENARIO_PVE:
-        case PlayerbotAI::SCENARIO_PVE_ELITE:
-        case PlayerbotAI::SCENARIO_PVE_RAID:
-        default:
-            return DoNextCombatManeuverPVE(pTarget);
-            break;
-    }
-
-    return RETURN_NO_ACTION_ERROR;
-}
-
-CombatManeuverReturns PlayerbotPriestAI::DoNextCombatManeuverPVE(Unit* pTarget)
-{
-    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
-    if (!m_bot) return RETURN_NO_ACTION_ERROR;
-
-    bool meleeReach = m_bot->CanReachWithMeleeAttack(pTarget);
-    uint32 spec = m_bot->GetSpec();
-
-    // Define a tank bot will look at
-    Unit* pMainTank = GetHealTarget(JOB_TANK);
-
-    if (m_ai->GetCombatStyle() != PlayerbotAI::COMBAT_RANGED && !meleeReach)
-        m_ai->SetCombatStyle(PlayerbotAI::COMBAT_RANGED);
-    // switch to melee if in melee range AND can't shoot OR have no ranged (wand) equipped AND is not healer
-    else if (m_ai->GetCombatStyle() != PlayerbotAI::COMBAT_MELEE
-             && meleeReach
-             && (SHOOT == 0 || !m_bot->GetWeaponForAttack(RANGED_ATTACK, true, true))
-             && !m_ai->IsHealer())
-        m_ai->SetCombatStyle(PlayerbotAI::COMBAT_MELEE);
-
-    // Priests will try to buff with Fear Ward
-    if (FEAR_WARD > 0 && m_bot->IsSpellReady(FEAR_WARD))
-    {
-        // Buff tank first
-        if (pMainTank)
-        {
-            if (m_ai->In_Reach(pMainTank, FEAR_WARD) && !pMainTank->HasAura(FEAR_WARD, EFFECT_INDEX_0) && CastSpell(FEAR_WARD, pMainTank))
-                return RETURN_CONTINUE;
-        }
-        // Else try to buff master
-        else if (GetMaster())
-        {
-            if (m_ai->In_Reach(GetMaster(), FEAR_WARD) && !GetMaster()->HasAura(FEAR_WARD, EFFECT_INDEX_0) && CastSpell(FEAR_WARD, GetMaster()))
-                return RETURN_CONTINUE;
-        }
-    }
-
-    //Used to determine if this bot is highest on threat
-    Unit* newTarget = m_ai->FindAttacker((PlayerbotAI::ATTACKERINFOTYPE)(PlayerbotAI::AIT_VICTIMSELF | PlayerbotAI::AIT_HIGHESTTHREAT), m_bot);
-    if (newTarget && !m_ai->IsNeutralized(newTarget)) // TODO: && party has a tank
-    {
-        if (FADE > 0 && !m_bot->HasAura(FADE, EFFECT_INDEX_0) && m_bot->IsSpellReady(FADE))
-        {
-            if (CastSpell(FADE, m_bot))
-            {
-                m_ai->TellMaster("I'm casting fade.");
-                return RETURN_CONTINUE;
-            }
-            else
-                m_ai->TellMaster("I have AGGRO.");
-        }
-
-        // Heal myself
-        // TODO: move to HealTarget code
-        if (m_ai->GetHealthPercent() < 35 && POWER_WORD_SHIELD > 0 && !m_bot->HasAura(POWER_WORD_SHIELD, EFFECT_INDEX_0) && !m_bot->HasAura(WEAKNED_SOUL, EFFECT_INDEX_0))
-        {
-            if (CastSpell(POWER_WORD_SHIELD) & RETURN_CONTINUE)
-            {
-                m_ai->TellMaster("I'm casting PW:S on myself.");
-                return RETURN_CONTINUE;
-            }
-            else if (m_ai->IsHealer()) // Even if any other RETURN_ANY_OK - aside from RETURN_CONTINUE
-                m_ai->TellMaster("Your healer's about TO DIE. HELP ME.");
-        }
-        if (m_ai->GetHealthPercent() < 35 && DESPERATE_PRAYER > 0 && m_ai->In_Reach(m_bot, DESPERATE_PRAYER) && CastSpell(DESPERATE_PRAYER, m_bot) & RETURN_CONTINUE)
-        {
-            m_ai->TellMaster("I'm casting desperate prayer.");
-            return RETURN_CONTINUE;
-        }
-        // Night Elves priest bot can also cast Elune's Grace to improve his/her dodge rating
-        if (ELUNES_GRACE && !m_bot->HasAura(ELUNES_GRACE, EFFECT_INDEX_0) && m_bot->IsSpellReady(ELUNES_GRACE) && CastSpell(ELUNES_GRACE, m_bot))
-            return RETURN_CONTINUE;
-
-        // If enemy comes in melee reach
-        if (meleeReach)
-        {
-            // Already healed self or tank. If healer, do nothing else to anger mob
-            if (m_ai->IsHealer())
-                return RETURN_NO_ACTION_OK; // In a sense, mission accomplished.
-
-            // Have threat, can't quickly lower it. 3 options remain: Stop attacking, lowlevel damage (wand), keep on keeping on.
-            if (newTarget->GetHealthPercent() > 25)
-            {
-                // If elite, do nothing and pray tank gets aggro off you
-                if (m_ai->IsElite(newTarget))
-                    return RETURN_NO_ACTION_OK;
-
-                // Not an elite. You could insert PSYCHIC SCREAM here but in any PvE situation that's 90-95% likely
-                // to worsen the situation for the group. ... So please don't.
-                return CastSpell(SHOOT, pTarget);
-            }
-        }
-    }
-
-    // Damage tweaking for healers
-    if (m_ai->IsHealer())
-    {
-        // Heal other players/bots first
-        if (HealPlayer(GetHealTarget()) & RETURN_CONTINUE)
-            return RETURN_CONTINUE;
-
-        // No one needs to be healed: do small damage instead
-        // If target is elite and not handled by MT: do nothing
-        if (m_ai->IsElite(pTarget) && pMainTank && pMainTank->getVictim() != pTarget)
-            return RETURN_NO_ACTION_OK;
-
-        // Cast Shadow Word:Pain on current target and keep its up (if mana >= 40% or target HP < 15%)
-        if (SHADOW_WORD_PAIN > 0 && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_SHADOW) && m_ai->In_Reach(pTarget, SHADOW_WORD_PAIN) && !pTarget->HasAura(SHADOW_WORD_PAIN, EFFECT_INDEX_0) &&
-                (pTarget->GetHealthPercent() < 15 || m_ai->GetManaPercent() >= 40) && CastSpell(SHADOW_WORD_PAIN, pTarget))
-            return RETURN_CONTINUE;
-        else // else shoot at it
-            return CastSpell(SHOOT, pTarget);
-    }
-
-    // Damage Spells
-    switch (spec)
-    {
-        case PRIEST_SPEC_HOLY:
-            if (HOLY_FIRE > 0 && m_ai->In_Reach(pTarget, HOLY_FIRE) && !pTarget->HasAura(HOLY_FIRE, EFFECT_INDEX_0) && CastSpell(HOLY_FIRE, pTarget))
-                return RETURN_CONTINUE;
-            if (SMITE > 0 && m_ai->In_Reach(pTarget, SMITE) && CastSpell(SMITE, pTarget))
-                return RETURN_CONTINUE;
-            //if (HOLY_NOVA > 0 && m_ai->In_Reach(pTarget,HOLY_NOVA) && meleeReach && m_ai->CastSpell(HOLY_NOVA))
-            //    return RETURN_CONTINUE;
-            break;
-
-        case PRIEST_SPEC_SHADOW:
-            if (DEVOURING_PLAGUE > 0 && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_SHADOW) && m_ai->In_Reach(pTarget, DEVOURING_PLAGUE) && !pTarget->HasAura(DEVOURING_PLAGUE, EFFECT_INDEX_0) && CastSpell(DEVOURING_PLAGUE, pTarget))
-                return RETURN_CONTINUE;
-            if (VAMPIRIC_TOUCH > 0 && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_SHADOW) && m_ai->In_Reach(pTarget, VAMPIRIC_TOUCH) && !pTarget->HasAura(VAMPIRIC_TOUCH, EFFECT_INDEX_0) && CastSpell(VAMPIRIC_TOUCH, pTarget))
-                return RETURN_CONTINUE;
-            if (SHADOW_WORD_PAIN > 0 && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_SHADOW) && m_ai->In_Reach(pTarget, SHADOW_WORD_PAIN) && !pTarget->HasAura(SHADOW_WORD_PAIN, EFFECT_INDEX_0) && CastSpell(SHADOW_WORD_PAIN, pTarget))
-                return RETURN_CONTINUE;
-            if (MIND_BLAST > 0 && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_SHADOW) && m_ai->In_Reach(pTarget, MIND_BLAST) && (m_bot->IsSpellReady(MIND_BLAST)) && CastSpell(MIND_BLAST, pTarget))
-                return RETURN_CONTINUE;
-            if (MIND_FLAY > 0 && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_SHADOW) && m_ai->In_Reach(pTarget, MIND_FLAY) && CastSpell(MIND_FLAY, pTarget))
-            {
-                m_ai->SetIgnoreUpdateTime(3);
-                return RETURN_CONTINUE;
-            }
-            if (SHADOWFIEND > 0 && m_ai->In_Reach(pTarget, SHADOWFIEND) && !m_bot->GetPet() && CastSpell(SHADOWFIEND))
-                return RETURN_CONTINUE;
-            if (SHADOWFORM == 0 && MIND_FLAY == 0 && SMITE > 0 && m_ai->In_Reach(pTarget, SMITE) && CastSpell(SMITE, pTarget)) // low levels
-                return RETURN_CONTINUE;
-            break;
-
-        case PRIEST_SPEC_DISCIPLINE:
-            if (POWER_INFUSION > 0 && m_ai->In_Reach(GetMaster(), POWER_INFUSION) && CastSpell(POWER_INFUSION, GetMaster())) // TODO: just master?
-                return RETURN_CONTINUE;
-            if (INNER_FOCUS > 0 && m_ai->In_Reach(m_bot, INNER_FOCUS) && !m_bot->HasAura(INNER_FOCUS, EFFECT_INDEX_0) && CastSpell(INNER_FOCUS, m_bot))
-                return RETURN_CONTINUE;
-            if (SMITE > 0 && m_ai->In_Reach(pTarget, SMITE) && CastSpell(SMITE, pTarget))
-                return RETURN_CONTINUE;
-            break;
-    }
-
-    // No spec due to low level OR no spell found yet
-    if (MIND_BLAST > 0 && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_SHADOW) && m_ai->In_Reach(pTarget, MIND_BLAST) && (m_bot->IsSpellReady(MIND_BLAST)) && CastSpell(MIND_BLAST, pTarget))
-        return RETURN_CONTINUE;
-    if (SHADOW_WORD_PAIN > 0 && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_SHADOW) && m_ai->In_Reach(pTarget, SHADOW_WORD_PAIN) && !pTarget->HasAura(SHADOW_WORD_PAIN, EFFECT_INDEX_0) && CastSpell(SHADOW_WORD_PAIN, pTarget))
-        return RETURN_CONTINUE;
-    if (MIND_FLAY > 0 && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_SHADOW) && m_ai->In_Reach(pTarget, MIND_FLAY) && CastSpell(MIND_FLAY, pTarget))
-    {
-        m_ai->SetIgnoreUpdateTime(3);
-        return RETURN_CONTINUE;
-    }
-    if (SHADOWFORM == 0 && SMITE > 0 && m_ai->In_Reach(pTarget, SMITE) && CastSpell(SMITE, pTarget))
-        return RETURN_CONTINUE;
-
-    // Default: shoot with wand
-    return CastSpell(SHOOT, pTarget);
-
-    return RETURN_NO_ACTION_OK;
-} // end DoNextCombatManeuver
-
-CombatManeuverReturns PlayerbotPriestAI::DoNextCombatManeuverPVP(Unit* pTarget)
-{
-    switch (m_ai->GetScenarioType())
-    {
-        case PlayerbotAI::SCENARIO_PVP_DUEL:
-            // TODO: spec tweaking
-            if (m_ai->HasAura(SCREAM, *pTarget) && m_ai->GetHealthPercent() < 60 && HEAL && m_ai->In_Reach(pTarget, HEAL) && CastSpell(HEAL) & RETURN_ANY_OK)
-                return RETURN_CONTINUE;
-
-            if (SHADOW_WORD_PAIN && m_ai->In_Reach(pTarget, SHADOW_WORD_PAIN) && CastSpell(SHADOW_WORD_PAIN) & RETURN_ANY_OK) // TODO: Check whether enemy has it active yet
-                return RETURN_CONTINUE;
-
-            if (m_ai->GetHealthPercent() < 80 && RENEW && m_ai->In_Reach(pTarget, RENEW) && CastSpell(RENEW) & RETURN_ANY_OK) // TODO: Check whether you have renew active on you
-                return RETURN_CONTINUE;
-
-            if (SCREAM && m_ai->In_Reach(pTarget, SCREAM) && CastSpell(SCREAM) & RETURN_ANY_OK) // TODO: Check for cooldown
-                return RETURN_CONTINUE;
-
-            if (MIND_BLAST && m_ai->In_Reach(pTarget, MIND_BLAST) && CastSpell(MIND_BLAST) & RETURN_ANY_OK) // TODO: Check for cooldown
-                return RETURN_CONTINUE;
-
-            if (m_ai->GetHealthPercent() < 50 && GREATER_HEAL && m_ai->In_Reach(pTarget, GREATER_HEAL) && CastSpell(GREATER_HEAL) & RETURN_ANY_OK)
-                return RETURN_CONTINUE;
-
-            if (SMITE && m_ai->In_Reach(pTarget, SMITE) && CastSpell(SMITE) & RETURN_ANY_OK)
-                return RETURN_CONTINUE;
-
-            m_ai->TellMaster("Couldn't find a spell to cast while dueling");
-        default:
-            break;
-    }
-
-    return DoNextCombatManeuverPVE(pTarget); // TODO: bad idea perhaps, but better than the alternative
-}
-
-CombatManeuverReturns PlayerbotPriestAI::HealPlayer(Player* target)
-{
-    CombatManeuverReturns r = PlayerbotClassAI::HealPlayer(target);
-    if (r != RETURN_NO_ACTION_OK)
-        return r;
-
-    if (!target->isAlive())
-    {
-        if (RESURRECTION && m_ai->In_Reach(target, RESURRECTION) && m_ai->CastSpell(RESURRECTION, *target))
-        {
-            std::string msg = "Resurrecting ";
-            msg += target->GetName();
-            m_bot->Say(msg, LANG_UNIVERSAL);
-            return RETURN_CONTINUE;
-        }
-        return RETURN_NO_ACTION_ERROR; // not error per se - possibly just OOM
-    }
-
-    // Remove negative magic on group members if orders allow bot to do so
-    if (Player* pCursedTarget = GetDispelTarget(DISPEL_MAGIC))
-    {
-        if (PRIEST_DISPEL_MAGIC > 0 && (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_NODISPEL) == 0 && CastSpell(PRIEST_DISPEL_MAGIC, pCursedTarget))
-            return RETURN_CONTINUE;
-    }
-
-    // Remove disease on group members if orders allow bot to do so
-    if (Player* pDiseasedTarget = GetDispelTarget(DISPEL_DISEASE))
-    {
-        uint32 cure = ABOLISH_DISEASE > 0 ? ABOLISH_DISEASE : CURE_DISEASE;
-        // uint32 poison = ABOLISH_POISON ? ABOLISH_POISON : CURE_POISON;
-        if (cure > 0 && (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_NODISPEL) == 0 && CastSpell(cure, pDiseasedTarget))
-            return RETURN_CONTINUE;
-    }
-
-    uint8 hp = target->GetHealthPercent();
-    uint8 hpSelf = m_ai->GetHealthPercent();
-
-    // Define a tank bot will look at
-    Unit* pMainTank = GetHealTarget(JOB_TANK);
-
-    if (hp >= 90)
-        return RETURN_NO_ACTION_OK;
-
-    // If target is out of range (40 yards) and is a tank: move towards it
-    // Other classes have to adjust their position to the healers
-    // TODO: This code should be common to all healers and will probably
-    // move to a more suitable place
-    if (pMainTank && !m_ai->In_Reach(pMainTank, FLASH_HEAL))
-    {
-        m_bot->GetMotionMaster()->MoveFollow(target, 39.0f, m_bot->GetOrientation());
-        return RETURN_CONTINUE;
-    }
-
-    // Get a free and more efficient heal if needed: low mana for bot or average health for target
-    if (m_ai->IsInCombat() && (hp < 50 || m_ai->GetManaPercent() < 40))
-        if (INNER_FOCUS > 0 && m_bot->IsSpellReady(INNER_FOCUS) && !m_bot->HasAura(INNER_FOCUS, EFFECT_INDEX_0) && CastSpell(INNER_FOCUS, m_bot))
-            return RETURN_CONTINUE;
-
-    if (hp < 25 && POWER_WORD_SHIELD > 0 && m_ai->In_Reach(target, POWER_WORD_SHIELD) && !m_bot->HasAura(POWER_WORD_SHIELD, EFFECT_INDEX_0) && !target->HasAura(WEAKNED_SOUL, EFFECT_INDEX_0) && m_ai->CastSpell(POWER_WORD_SHIELD, *target))
-        return RETURN_CONTINUE;
-    if (hp < 35 && FLASH_HEAL > 0 && m_ai->In_Reach(target, FLASH_HEAL) && m_ai->CastSpell(FLASH_HEAL, *target))
-        return RETURN_CONTINUE;
-    if (hp < 50 && GREATER_HEAL > 0 && m_ai->In_Reach(target, GREATER_HEAL) && m_ai->CastSpell(GREATER_HEAL, *target))
-        return RETURN_CONTINUE;
-    // Heals target AND self for equal amount
-    if (hp < 60 && hpSelf < 80 && BINDING_HEAL > 0 && m_ai->In_Reach(target, BINDING_HEAL) && m_ai->CastSpell(BINDING_HEAL, *target))
-        return RETURN_CONTINUE;
-    if (hp < 60 && PRAYER_OF_MENDING > 0 && m_ai->In_Reach(target, PRAYER_OF_MENDING) && !target->HasAura(PRAYER_OF_MENDING, EFFECT_INDEX_0) && CastSpell(PRAYER_OF_MENDING, target))
-        return RETURN_FINISHED_FIRST_MOVES;
-    if (hp < 70 && HEAL > 0 && m_ai->In_Reach(target, HEAL) && m_ai->CastSpell(HEAL, *target))
-        return RETURN_CONTINUE;
-    if (hp < 90 && RENEW > 0 && m_ai->In_Reach(target, RENEW) && !target->HasAura(RENEW) && m_ai->CastSpell(RENEW, *target))
-        return RETURN_CONTINUE;
-
-    // Group heal. Not really useful until a group check is available?
-    //if (hp < 40 && PRAYER_OF_HEALING > 0 && m_ai->CastSpell(PRAYER_OF_HEALING, *target) & RETURN_CONTINUE)
-    //    return RETURN_CONTINUE;
-    // Group heal. Not really useful until a group check is available?
-    //if (hp < 50 && CIRCLE_OF_HEALING > 0 && m_ai->CastSpell(CIRCLE_OF_HEALING, *target) & RETURN_CONTINUE)
-    //    return RETURN_CONTINUE;
-
-    return RETURN_NO_ACTION_OK;
-} // end HealTarget
-
-void PlayerbotPriestAI::DoNonCombatActions()
-{
-    if (!m_ai)   return;
-    if (!m_bot)  return;
-
-    if (!m_bot->isAlive() || m_bot->IsInDuel()) return;
-
-    uint32 spec = m_bot->GetSpec();
-
-    // selfbuff goes first
-    if (m_ai->SelfBuff(INNER_FIRE))
-        return;
-
-    // Revive
-    if (HealPlayer(GetResurrectionTarget()) & RETURN_CONTINUE)
-        return;
-
-    // After revive
-    if (spec == PRIEST_SPEC_SHADOW && SHADOWFORM > 0)
-        m_ai->SelfBuff(SHADOWFORM);
-    if (VAMPIRIC_EMBRACE > 0)
-        m_ai->SelfBuff(VAMPIRIC_EMBRACE);
-
-    // Heal
-    if (m_ai->IsHealer())
-    {
-        if (HealPlayer(GetHealTarget()) & RETURN_CONTINUE)
-            return;// RETURN_CONTINUE;
-    }
-    else
-    {
-        // Is this desirable? Debatable.
-        // TODO: In a group/raid with a healer you'd want this bot to focus on DPS (it's not specced/geared for healing either)
-        if (HealPlayer(m_bot) & RETURN_CONTINUE)
-            return;// RETURN_CONTINUE;
-    }
-
-    // Buffing
-    // the check for group targets is performed by NeedGroupBuff (if group is found for bots by the function)
-    if (NeedGroupBuff(PRAYER_OF_FORTITUDE, POWER_WORD_FORTITUDE) && m_ai->HasSpellReagents(PRAYER_OF_FORTITUDE))
-    {
-        if (Buff(&PlayerbotPriestAI::BuffHelper, PRAYER_OF_FORTITUDE) & RETURN_CONTINUE)
-            return;
-    }
-    else if (Buff(&PlayerbotPriestAI::BuffHelper, POWER_WORD_FORTITUDE) & RETURN_CONTINUE)
-        return;
-
-    if (NeedGroupBuff(PRAYER_OF_SPIRIT, DIVINE_SPIRIT) && m_ai->HasSpellReagents(PRAYER_OF_FORTITUDE))
-    {
-        if (Buff(&PlayerbotPriestAI::BuffHelper, PRAYER_OF_SPIRIT) & RETURN_CONTINUE)
-            return;
-    }
-    else if (Buff(&PlayerbotPriestAI::BuffHelper, DIVINE_SPIRIT, (JOB_ALL | JOB_MANAONLY)) & RETURN_CONTINUE)
-        return;
-
-    if (NeedGroupBuff(PRAYER_OF_SHADOW_PROTECTION, SHADOW_PROTECTION) && m_ai->HasSpellReagents(PRAYER_OF_FORTITUDE))
-    {
-        if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_RESIST_SHADOW && Buff(&PlayerbotPriestAI::BuffHelper, PRAYER_OF_SHADOW_PROTECTION) & RETURN_CONTINUE)
-            return;
-    }
-    else if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_RESIST_SHADOW && Buff(&PlayerbotPriestAI::BuffHelper, SHADOW_PROTECTION) & RETURN_CONTINUE)
-        return;
-
-    if (EatDrinkBandage())
-        return;
-
-    // Nothing else to do, Night Elves will cast Shadowmeld to reduce their aggro versus patrols or nearby mobs
-    if (SHADOWMELD && !m_bot->HasAura(SHADOWMELD, EFFECT_INDEX_0) && m_ai->CastSpell(SHADOWMELD, *m_bot))
-        return;
-} // end DoNonCombatActions
-
-// TODO: this and mage's BuffHelper are identical and thus could probably go in PlayerbotClassAI.cpp somewhere
-bool PlayerbotPriestAI::BuffHelper(PlayerbotAI* ai, uint32 spellId, Unit* target)
-{
-    if (!ai)          return false;
-    if (spellId == 0) return false;
-    if (!target)      return false;
-
-    Pet* pet = target->GetPet();
-    if (pet && !pet->HasAuraType(SPELL_AURA_MOD_UNATTACKABLE) && ai->Buff(spellId, pet))
-        return true;
-
-    if (ai->Buff(spellId, target))
-        return true;
-
-    return false;
-}
-
-bool PlayerbotPriestAI::CastHoTOnTank()
-{
-    if (!m_ai) return false;
-
-    if ((PlayerbotAI::ORDERS_HEAL & m_ai->GetCombatOrder()) == 0) return false;
-
-    // Priest HoTs: Renew (with talents, channeled)
-    if (RENEW && m_ai->In_Reach(m_ai->GetGroupTank(), RENEW))
-        return (RETURN_CONTINUE & CastSpell(RENEW, m_ai->GetGroupTank()));
-
-    return false;
-}
-
-// Return to UpdateAI the spellId usable to neutralize a target with creaturetype
-uint32 PlayerbotPriestAI::Neutralize(uint8 creatureType)
-{
-    if (!m_bot)         return 0;
-    if (!m_ai)          return 0;
-    if (!creatureType)  return 0;
-
-    if (creatureType != CREATURE_TYPE_UNDEAD)
-    {
-        m_ai->TellMaster("I can't shackle that target.");
-        return 0;
-    }
-
-    if (SHACKLE_UNDEAD)
-        return SHACKLE_UNDEAD;
-    else
-        return 0;
-
-    return 0;
-}
diff --git a/src/game/PlayerBot/AI/PlayerbotPriestAI.h b/src/game/PlayerBot/AI/PlayerbotPriestAI.h
deleted file mode 100644
index e0804d664..000000000
--- a/src/game/PlayerBot/AI/PlayerbotPriestAI.h
+++ /dev/null
@@ -1,182 +0,0 @@
-/*
- * This file is part of the CMaNGOS Project. See AUTHORS file for Copyright information
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _PLAYERBOTPRIESTAI_H
-#define _PLAYERBOTPRIESTAI_H
-
-#include "../Base/PlayerbotClassAI.h"
-
-enum
-{
-    SPELL_HOLY,
-    SPELL_SHADOWMAGIC,
-    SPELL_DISCIPLINE
-};
-
-enum PriestSpells
-{
-    ABOLISH_DISEASE_1               = 552,
-    BINDING_HEAL_1                  = 32546,
-    CIRCLE_OF_HEALING_1             = 34861,
-    CURE_DISEASE_1                  = 528,
-    DESPERATE_PRAYER_1              = 19236,
-    DEVOURING_PLAGUE_1              = 2944,
-    DISPEL_MAGIC_1                  = 527,
-    DIVINE_SPIRIT_1                 = 14752,
-    ELUNES_GRACE_1                  = 2651,
-    FADE_1                          = 586,
-    FEAR_WARD_1                     = 6346,
-    FLASH_HEAL_1                    = 2061,
-    GREATER_HEAL_1                  = 2060,
-    HEAL_1                          = 2054,
-    HOLY_FIRE_1                     = 14914,
-    HOLY_NOVA_1                     = 15237,
-    INNER_FIRE_1                    = 588,
-    INNER_FOCUS_1                   = 14751,
-    LESSER_HEAL_1                   = 2050,
-    LEVITATE_1                      = 1706,
-    LIGHTWELL_1                     = 724,
-    MANA_BURN_1                     = 8129,
-    MASS_DISPEL_1                   = 32375,
-    MIND_BLAST_1                    = 8092,
-    MIND_CONTROL_1                  = 605,
-    MIND_FLAY_1                     = 15407,
-    MIND_SOOTHE_1                   = 453,
-    MIND_VISION_1                   = 2096,
-    PAIN_SUPPRESSION_1              = 33206,
-    POWER_INFUSION_1                = 10060,
-    POWER_WORD_FORTITUDE_1          = 1243,
-    POWER_WORD_SHIELD_1             = 17,
-    PRAYER_OF_FORTITUDE_1           = 21562,
-    PRAYER_OF_HEALING_1             = 596,
-    PRAYER_OF_MENDING_1             = 33076,
-    PRAYER_OF_SHADOW_PROTECTION_1   = 27683,
-    PRAYER_OF_SPIRIT_1              = 27681,
-    PSYCHIC_SCREAM_1                = 8122,
-    RENEW_1                         = 139,
-    RESURRECTION_1                  = 2006,
-    SHACKLE_UNDEAD_1                = 9484,
-    SHADOW_PROTECTION_1             = 976,
-    SHADOW_WORD_DEATH_1             = 32379,
-    SHADOW_WORD_PAIN_1              = 589,
-    SHADOWFIEND_1                   = 34433,
-    SHADOWFORM_1                    = 15473,
-    SHOOT_1                                          = 5019,
-    SILENCE_1                       = 15487,
-    SMITE_1                         = 585,
-    VAMPIRIC_EMBRACE_1              = 15286,
-    VAMPIRIC_TOUCH_1                = 34914,
-    WEAKNED_SOUL                    = 6788
-};
-//class Player;
-
-class PlayerbotPriestAI : PlayerbotClassAI
-{
-    public:
-        PlayerbotPriestAI(Player* const master, Player* const bot, PlayerbotAI* const ai);
-        virtual ~PlayerbotPriestAI();
-
-        // all combat actions go here
-        CombatManeuverReturns DoFirstCombatManeuver(Unit* pTarget);
-        CombatManeuverReturns DoNextCombatManeuver(Unit* pTarget);
-        uint32 Neutralize(uint8 creatureType);
-
-        // all non combat actions go here, ex buffs, heals, rezzes
-        void DoNonCombatActions();
-
-        // Utility Functions
-        bool CastHoTOnTank();
-
-    private:
-        CombatManeuverReturns DoFirstCombatManeuverPVE(Unit* pTarget);
-        CombatManeuverReturns DoNextCombatManeuverPVE(Unit* pTarget);
-        CombatManeuverReturns DoFirstCombatManeuverPVP(Unit* pTarget);
-        CombatManeuverReturns DoNextCombatManeuverPVP(Unit* pTarget);
-
-        CombatManeuverReturns CastSpell(uint32 nextAction, Unit* pTarget = nullptr) { return CastSpellWand(nextAction, pTarget, SHOOT); }
-
-        // Heals the target based off its hps
-        CombatManeuverReturns HealPlayer(Player* target);
-
-        static bool BuffHelper(PlayerbotAI* ai, uint32 spellId, Unit* target);
-
-        // holy
-        uint32 BINDING_HEAL,
-               CIRCLE_OF_HEALING,
-               CLEARCASTING,
-               DESPERATE_PRAYER,
-               FLASH_HEAL,
-               GREATER_HEAL,
-               HEAL,
-               HOLY_FIRE,
-               HOLY_NOVA,
-               LESSER_HEAL,
-               MANA_BURN,
-               PRAYER_OF_HEALING,
-               PRAYER_OF_MENDING,
-               RENEW,
-               RESURRECTION,
-               SHACKLE_UNDEAD,
-               SMITE,
-               CURE_DISEASE,
-               ABOLISH_DISEASE,
-               PRIEST_DISPEL_MAGIC;
-
-        // ranged
-        uint32 SHOOT;
-
-        // shadowmagic
-        uint32 FADE,
-               SHADOW_WORD_PAIN,
-               MIND_BLAST,
-               SCREAM,
-               MIND_FLAY,
-               DEVOURING_PLAGUE,
-               SHADOW_PROTECTION,
-               VAMPIRIC_TOUCH,
-               PRAYER_OF_SHADOW_PROTECTION,
-               SHADOWFIEND,
-               SHADOWFORM,
-               VAMPIRIC_EMBRACE;
-
-        // discipline
-        uint32 POWER_WORD_SHIELD,
-               INNER_FIRE,
-               POWER_WORD_FORTITUDE,
-               PRAYER_OF_FORTITUDE,
-               FEAR_WARD,
-               POWER_INFUSION,
-               MASS_DISPEL,
-               DIVINE_SPIRIT,
-               PRAYER_OF_SPIRIT,
-               INNER_FOCUS;
-
-        // racial
-        uint32 ARCANE_TORRENT,
-               GIFT_OF_THE_NAARU,
-               STONEFORM,
-               ELUNES_GRACE,
-               ESCAPE_ARTIST,
-               PERCEPTION,
-               SHADOWMELD,
-               WAR_STOMP,
-               BERSERKING,
-               WILL_OF_THE_FORSAKEN;
-};
-
-#endif
diff --git a/src/game/PlayerBot/AI/PlayerbotRogueAI.cpp b/src/game/PlayerBot/AI/PlayerbotRogueAI.cpp
deleted file mode 100644
index 5e5b93d30..000000000
--- a/src/game/PlayerBot/AI/PlayerbotRogueAI.cpp
+++ /dev/null
@@ -1,549 +0,0 @@
-/*
- * This file is part of the CMaNGOS Project. See AUTHORS file for Copyright information
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "PlayerbotRogueAI.h"
-#include "../Base/PlayerbotMgr.h"
-
-class PlayerbotAI;
-PlayerbotRogueAI::PlayerbotRogueAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
-{
-    ADRENALINE_RUSH          = m_ai->initSpell(ADRENALINE_RUSH_1);
-    SINISTER_STRIKE          = m_ai->initSpell(SINISTER_STRIKE_1);
-    BACKSTAB                 = m_ai->initSpell(BACKSTAB_1);
-    KICK                     = m_ai->initSpell(KICK_1);
-    FEINT                    = m_ai->initSpell(FEINT_1);
-    GOUGE                    = m_ai->initSpell(GOUGE_1);
-    SPRINT                   = m_ai->initSpell(SPRINT_1);
-
-    SHADOWSTEP               = m_ai->initSpell(SHADOWSTEP_1);
-    STEALTH                  = m_ai->initSpell(STEALTH_1);
-    VANISH                   = m_ai->initSpell(VANISH_1);
-    EVASION                  = m_ai->initSpell(EVASION_1);
-    CLOAK_OF_SHADOWS         = m_ai->initSpell(CLOAK_OF_SHADOWS_1);
-    HEMORRHAGE               = m_ai->initSpell(HEMORRHAGE_1);
-    GHOSTLY_STRIKE           = m_ai->initSpell(GHOSTLY_STRIKE_1);
-    BLIND                    = m_ai->initSpell(BLIND_1);
-    DISTRACT                 = m_ai->initSpell(DISTRACT_1);
-    PREPARATION              = m_ai->initSpell(PREPARATION_1);
-    PREMEDITATION            = m_ai->initSpell(PREMEDITATION_1);
-    PICK_POCKET              = m_ai->initSpell(PICK_POCKET_1);
-
-    EVISCERATE               = m_ai->initSpell(EVISCERATE_1);
-    KIDNEY_SHOT              = m_ai->initSpell(KIDNEY_SHOT_1);
-    SLICE_DICE               = m_ai->initSpell(SLICE_AND_DICE_1);
-    GARROTE                  = m_ai->initSpell(GARROTE_1);
-    EXPOSE_ARMOR             = m_ai->initSpell(EXPOSE_ARMOR_1);
-    RUPTURE                  = m_ai->initSpell(RUPTURE_1);
-    CHEAP_SHOT               = m_ai->initSpell(CHEAP_SHOT_1);
-    AMBUSH                   = m_ai->initSpell(AMBUSH_1);
-    MUTILATE                 = m_ai->initSpell(MUTILATE_1);
-    COLD_BLOOD               = m_ai->initSpell(COLD_BLOOD_1);
-
-    RECENTLY_BANDAGED        = 11196; // first aid check
-    // racial
-    ARCANE_TORRENT           = m_ai->initSpell(ARCANE_TORRENT_ROGUE);
-    STONEFORM                = m_ai->initSpell(STONEFORM_ALL); // dwarf
-    ESCAPE_ARTIST            = m_ai->initSpell(ESCAPE_ARTIST_ALL); // gnome
-    PERCEPTION               = m_ai->initSpell(PERCEPTION_ALL); // human
-    SHADOWMELD               = m_ai->initSpell(SHADOWMELD_ALL);
-    BLOOD_FURY               = m_ai->initSpell(BLOOD_FURY_MELEE_CLASSES); // orc
-    BERSERKING               = m_ai->initSpell(BERSERKING_ALL); // troll
-    WILL_OF_THE_FORSAKEN     = m_ai->initSpell(WILL_OF_THE_FORSAKEN_ALL); // undead
-}
-
-PlayerbotRogueAI::~PlayerbotRogueAI() {}
-
-CombatManeuverReturns PlayerbotRogueAI::DoFirstCombatManeuver(Unit* pTarget)
-{
-    // There are NPCs in BGs and Open World PvP, so don't filter this on PvP scenarios (of course if PvP targets anyone but tank, all bets are off anyway)
-    // Wait until the tank says so, until any non-tank gains aggro or X seconds - whichever is shortest
-    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO)
-    {
-        if (m_WaitUntil > m_ai->CurrentTime() && m_ai->GroupTankHoldsAggro())
-        {
-            return RETURN_NO_ACTION_OK; // wait it out
-        }
-        else
-        {
-            m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO);
-        }
-    }
-
-    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TEMP_WAIT_OOC)
-    {
-        if (m_WaitUntil > m_ai->CurrentTime() && m_ai->IsGroupReady())
-            return RETURN_NO_ACTION_OK; // wait it out
-        else
-            m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_OOC);
-    }
-
-    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
-    if (!m_bot) return RETURN_NO_ACTION_ERROR;
-
-    switch (m_ai->GetScenarioType())
-    {
-        case PlayerbotAI::SCENARIO_PVP_DUEL:
-        case PlayerbotAI::SCENARIO_PVP_BG:
-        case PlayerbotAI::SCENARIO_PVP_ARENA:
-        case PlayerbotAI::SCENARIO_PVP_OPENWORLD:
-            return DoFirstCombatManeuverPVP(pTarget);
-        case PlayerbotAI::SCENARIO_PVE:
-        case PlayerbotAI::SCENARIO_PVE_ELITE:
-        case PlayerbotAI::SCENARIO_PVE_RAID:
-        default:
-            return DoFirstCombatManeuverPVE(pTarget);
-            break;
-    }
-
-    return RETURN_NO_ACTION_ERROR;
-}
-
-CombatManeuverReturns PlayerbotRogueAI::DoFirstCombatManeuverPVE(Unit* pTarget)
-{
-    if (STEALTH > 0 && !m_bot->HasAura(STEALTH, EFFECT_INDEX_0) && m_ai->CastSpell(STEALTH, *m_bot))
-    {
-        return RETURN_FINISHED_FIRST_MOVES; // DoNextCombatManeuver handles active stealth
-    }
-    else if (m_bot->HasAura(STEALTH, EFFECT_INDEX_0))
-    {
-        m_bot->GetMotionMaster()->MoveFollow(pTarget, 4.5f, m_bot->GetOrientation()); // TODO: this isn't the place for movement code, is it?
-        return RETURN_FINISHED_FIRST_MOVES; // DoNextCombatManeuver handles active stealth
-    }
-
-    // Not in stealth, can't cast stealth; Off to DoNextCombatManeuver
-    return RETURN_NO_ACTION_OK;
-}
-
-// TODO: blatant copy of PVE for now, please PVP-port it
-CombatManeuverReturns PlayerbotRogueAI::DoFirstCombatManeuverPVP(Unit* pTarget)
-{
-    if (STEALTH > 0 && !m_bot->HasAura(STEALTH, EFFECT_INDEX_0) && m_ai->CastSpell(STEALTH, *m_bot))
-    {
-        return RETURN_FINISHED_FIRST_MOVES; // DoNextCombatManeuver handles active stealth
-    }
-    else if (m_bot->HasAura(STEALTH, EFFECT_INDEX_0))
-    {
-        m_bot->GetMotionMaster()->MoveFollow(pTarget, 4.5f, m_bot->GetOrientation()); // TODO: this isn't the place for movement code, is it?
-        return RETURN_FINISHED_FIRST_MOVES; // DoNextCombatManeuver handles active stealth
-    }
-
-    // Not in stealth, can't cast stealth; Off to DoNextCombatManeuver
-    return RETURN_NO_ACTION_OK;
-}
-
-CombatManeuverReturns PlayerbotRogueAI::DoNextCombatManeuver(Unit* pTarget)
-{
-    // Face enemy, make sure bot is attacking
-    m_ai->FaceTarget(pTarget);
-
-    switch (m_ai->GetScenarioType())
-    {
-        case PlayerbotAI::SCENARIO_PVP_DUEL:
-        case PlayerbotAI::SCENARIO_PVP_BG:
-        case PlayerbotAI::SCENARIO_PVP_ARENA:
-        case PlayerbotAI::SCENARIO_PVP_OPENWORLD:
-            return DoNextCombatManeuverPVP(pTarget);
-        case PlayerbotAI::SCENARIO_PVE:
-        case PlayerbotAI::SCENARIO_PVE_ELITE:
-        case PlayerbotAI::SCENARIO_PVE_RAID:
-        default:
-            return DoNextCombatManeuverPVE(pTarget);
-            break;
-    }
-
-    return RETURN_NO_ACTION_ERROR;
-}
-
-CombatManeuverReturns PlayerbotRogueAI::DoNextCombatManeuverPVE(Unit* pTarget)
-{
-    if (!pTarget) return RETURN_NO_ACTION_ERROR;
-    if (!m_ai)    return RETURN_NO_ACTION_ERROR;
-    if (!m_bot)   return RETURN_NO_ACTION_ERROR;
-
-    Unit* pVictim = pTarget->getVictim();
-    bool meleeReach = m_bot->CanReachWithMeleeAttack(pTarget);
-
-    // TODO: make this work better...
-    /*if (pVictim)
-       {
-        if( pVictim!=m_bot && !m_bot->hasUnitState(UNIT_STAT_FOLLOW) && !pTarget->isInBackInMap(m_bot,10) ) {
-            m_ai->TellMaster( "getting behind target" );
-            m_bot->GetMotionMaster()->Clear( true );
-            m_bot->GetMotionMaster()->MoveFollow( pTarget, 1, 2*M_PI );
-        }
-        else if( pVictim==m_bot && m_bot->hasUnitState(UNIT_STAT_FOLLOW) )
-        {
-            m_ai->TellMaster( "chasing attacking target" );
-            m_bot->GetMotionMaster()->Clear( true );
-            m_bot->GetMotionMaster()->MoveChase( pTarget );
-        }
-       }*/
-
-    // If bot is stealthed: pre-combat actions
-    if (m_bot->HasAura(STEALTH, EFFECT_INDEX_0))
-    {
-        if (PICK_POCKET > 0 && m_ai->In_Reach(pTarget, PICK_POCKET) && (pTarget->GetCreatureTypeMask() & CREATURE_TYPEMASK_HUMANOID_OR_UNDEAD) != 0 && m_ai->PickPocket(pTarget))
-            return RETURN_CONTINUE;
-        if (PREMEDITATION > 0 && m_ai->CastSpell(PREMEDITATION, *pTarget))
-            return RETURN_CONTINUE;
-        if (AMBUSH > 0 && pTarget->isInBackInMap(m_bot, 5.0f) && m_ai->CastSpell(AMBUSH, *pTarget))
-            return RETURN_CONTINUE;
-        if (CHEAP_SHOT > 0 && !pTarget->HasAura(CHEAP_SHOT, EFFECT_INDEX_0) && m_ai->CastSpell(CHEAP_SHOT, *pTarget))
-            return RETURN_CONTINUE;
-        if (GARROTE > 0 && pTarget->isInBackInMap(m_bot, 5.0f) && m_ai->CastSpell(GARROTE, *pTarget))
-            return RETURN_CONTINUE;
-
-        // No appropriate action found, remove stealth
-        m_bot->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
-        return RETURN_CONTINUE;
-    }
-
-    //Used to determine if this bot has highest threat
-    Unit* newTarget = m_ai->FindAttacker((PlayerbotAI::ATTACKERINFOTYPE)(PlayerbotAI::AIT_VICTIMSELF | PlayerbotAI::AIT_HIGHESTTHREAT), m_bot);
-    if (newTarget && !(m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TANK) && !m_ai->IsNeutralized(newTarget)) // TODO: && party has a tank
-    {
-        // Aggroed by an elite
-        if (m_ai->IsElite(newTarget))
-        {
-            if (VANISH > 0 && m_ai->GetHealthPercent() <= 20 && m_bot->IsSpellReady(VANISH) && !m_bot->HasAura(FEINT, EFFECT_INDEX_0) && m_ai->CastSpell(VANISH))
-            {
-                m_ai->SetIgnoreUpdateTime(11);
-                return RETURN_CONTINUE;
-            }
-            if (BLIND > 0 && m_ai->GetHealthPercent() <= 30 && m_ai->HasSpellReagents(BLIND) && !newTarget->HasAura(BLIND, EFFECT_INDEX_0) && m_ai->CastSpell(BLIND, *newTarget))
-                return RETURN_CONTINUE;
-            if (EVASION > 0 && m_ai->GetHealthPercent() <= 35 && m_bot->IsSpellReady(EVASION) && !m_bot->HasAura(EVASION, EFFECT_INDEX_0) && m_ai->CastSpell(EVASION))
-                return RETURN_CONTINUE;
-            if (FEINT > 0 && m_bot->IsSpellReady(FEINT) && m_ai->CastSpell(FEINT, *newTarget))
-                return RETURN_CONTINUE;
-            if (PREPARATION > 0 && m_bot->IsSpellReady(PREPARATION) && (!m_bot->IsSpellReady(EVASION) || !m_bot->IsSpellReady(VANISH)) && m_ai->CastSpell(PREPARATION))
-                return RETURN_CONTINUE;
-        }
-
-        // Default: Gouge the target
-        if (GOUGE > 0 && pTarget->isInFrontInMap(m_bot, 5.0f) && !pTarget->HasAura(GOUGE, EFFECT_INDEX_0) && m_ai->CastSpell(GOUGE, *newTarget))
-            return RETURN_CONTINUE;
-    }
-
-    // Buff bot with cold blood if available
-    // This buff is done after the stealth and aggro management code because we don't want to give starting extra damage (= extra threat) to a bot
-    // as it is obviously not soloing his/her target
-    if (COLD_BLOOD > 0 && !m_bot->HasAura(COLD_BLOOD, EFFECT_INDEX_0) && m_bot->IsSpellReady(COLD_BLOOD) && m_ai->CastSpell(COLD_BLOOD, *m_bot))
-        return RETURN_CONTINUE;
-
-    // Rogue like behaviour ^^
-    /*if (VANISH > 0 && GetMaster()->isDead()) { //Causes the server to crash :( removed for now.
-        m_bot->AttackStop();
-        m_bot->RemoveAllAttackers();
-        m_ai->CastSpell(VANISH);
-        //m_bot->RemoveAllSpellCooldown();
-        m_ai->TellMaster("AttackStop, CombatStop, Vanish");
-    }*/
-
-    // we fight in melee, target is not in range, skip the next part!
-    if (!meleeReach)
-        return RETURN_CONTINUE;
-
-    // If target is elite and wounded: use adrenaline rush to finish it quicker
-    if (ADRENALINE_RUSH > 0 && m_ai->IsElite(pTarget) && pTarget->GetHealthPercent() < 50 && !m_bot->HasAura(ADRENALINE_RUSH, EFFECT_INDEX_0) && m_bot->IsSpellReady(ADRENALINE_RUSH) && m_ai->CastSpell(ADRENALINE_RUSH, *m_bot))
-        return RETURN_CONTINUE;
-
-    // Bot's target is casting a spell: try to interrupt it
-    if (pTarget->IsNonMeleeSpellCasted(true))
-    {
-        if (KIDNEY_SHOT > 0 && m_bot->IsSpellReady(KIDNEY_SHOT) && m_bot->GetComboPoints() >= 1 && m_ai->CastSpell(KIDNEY_SHOT, *pTarget))
-            return RETURN_CONTINUE;
-        else if (KICK > 0 && m_bot->IsSpellReady(KICK) && m_ai->CastSpell(KICK, *pTarget))
-            return RETURN_CONTINUE;
-    }
-
-    // Finishing moves
-    // Bot will try to activate finishing move at 4 combos points (5 combos points case will be bonus)
-    // TODO : define combo points treshold depending on target rank and HP
-    if (m_bot->GetComboPoints() >= 4)
-    {
-        Creature* pCreature = (Creature*) pTarget;
-        // wait for energy
-        if (m_ai->GetEnergyAmount() < 25 && (KIDNEY_SHOT || SLICE_DICE || EXPOSE_ARMOR || RUPTURE))
-            return RETURN_NO_ACTION_OK;
-
-        // If target is elite Slice & Dice is a must have
-        if (SLICE_DICE > 0 && m_ai->IsElite(pTarget) && !m_bot->HasAura(SLICE_DICE, EFFECT_INDEX_1) && m_ai->CastSpell(SLICE_DICE, *pTarget)) // 25 energy (checked above)
-            return RETURN_CONTINUE;
-
-        // If target is a warrior or paladin type (high armor): expose its armor if not a worldboss
-        if (EXPOSE_ARMOR > 0 && !m_ai->IsElite(pTarget, true) && pCreature && pCreature->GetCreatureInfo()->UnitClass != 8 && !pTarget->HasAura(EXPOSE_ARMOR, EFFECT_INDEX_0) && m_ai->CastSpell(EXPOSE_ARMOR, *pTarget)) // 25 energy (checked above)
-            return RETURN_CONTINUE;
-
-        if (RUPTURE > 0 && !pTarget->HasAura(RUPTURE, EFFECT_INDEX_0) && m_ai->CastSpell(RUPTURE, *pTarget)) // 25 energy (checked above)
-            return RETURN_CONTINUE;
-
-        // default combo action or if other combo action is unavailable/failed
-        // wait for energy
-        if (m_ai->GetEnergyAmount() < 35 && EVISCERATE > 0)
-            return RETURN_NO_ACTION_OK;
-        if (EVISCERATE > 0 && m_ai->CastSpell(EVISCERATE, *pTarget))
-            return RETURN_CONTINUE;
-
-        // failed for some (non-energy related) reason, fall through to normal attacks to maximize DPS
-    }
-
-    // Combo generating or damage increasing attacks
-    if (HEMORRHAGE > 0 && !pTarget->HasAura(HEMORRHAGE, EFFECT_INDEX_2) && m_ai->CastSpell(HEMORRHAGE, *pTarget))
-        return RETURN_CONTINUE;
-    if (BACKSTAB > 0 && pTarget->isInBackInMap(m_bot, 5.0f) && m_ai->CastSpell(BACKSTAB, *pTarget))
-        return RETURN_CONTINUE;
-    if (GHOSTLY_STRIKE > 0 && m_bot->IsSpellReady(GHOSTLY_STRIKE) && m_ai->CastSpell(GHOSTLY_STRIKE, *pTarget))
-        return RETURN_CONTINUE;
-    if (SINISTER_STRIKE > 0 && m_ai->CastSpell(SINISTER_STRIKE, *pTarget))
-        return RETURN_CONTINUE;
-
-    return RETURN_NO_ACTION_OK;
-} // end DoNextCombatManeuver
-
-CombatManeuverReturns PlayerbotRogueAI::DoNextCombatManeuverPVP(Unit* pTarget)
-{
-    if (!pTarget) return RETURN_NO_ACTION_ERROR;
-    if (!m_ai)    return RETURN_NO_ACTION_ERROR;
-    if (!m_bot)   return RETURN_NO_ACTION_ERROR;
-
-    Unit* pVictim = pTarget->getVictim();
-    bool meleeReach = m_bot->CanReachWithMeleeAttack(pTarget);
-
-    // decide what to do:
-    if (pVictim == m_bot && CLOAK_OF_SHADOWS > 0 && m_bot->HasAura(SPELL_AURA_PERIODIC_DAMAGE) && !m_bot->HasAura(CLOAK_OF_SHADOWS, EFFECT_INDEX_0) && m_ai->CastSpell(CLOAK_OF_SHADOWS))
-    {
-        if (m_ai->GetManager()->m_confDebugWhisper)
-            m_ai->TellMaster("CoS!");
-        return RETURN_CONTINUE;
-    }
-    else if (m_bot->HasAura(STEALTH, EFFECT_INDEX_0))
-        SpellSequence = RogueStealth;
-    else if (pTarget->IsNonMeleeSpellCasted(true))
-        SpellSequence = RogueSpellPreventing;
-    else if (pVictim == m_bot && m_ai->GetHealthPercent() < 40)
-        SpellSequence = RogueThreat;
-    else
-        SpellSequence = RogueCombat;
-
-    // we fight in melee, target is not in range, skip the next part!
-    if (!meleeReach)
-        return RETURN_CONTINUE;
-
-    std::ostringstream out;
-    switch (SpellSequence)
-    {
-        case RogueStealth:
-            if (PREMEDITATION > 0 && m_ai->CastSpell(PREMEDITATION, *pTarget))
-                return RETURN_CONTINUE;
-            if (AMBUSH > 0 && m_ai->CastSpell(AMBUSH, *pTarget))
-                return RETURN_CONTINUE;
-            if (CHEAP_SHOT > 0 && !pTarget->HasAura(CHEAP_SHOT, EFFECT_INDEX_0) && m_ai->CastSpell(CHEAP_SHOT, *pTarget))
-                return RETURN_CONTINUE;
-            if (GARROTE > 0 && m_ai->CastSpell(GARROTE, *pTarget))
-                return RETURN_CONTINUE;
-
-            // No appropriate action found, remove stealth
-            m_bot->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
-            return RETURN_CONTINUE;
-
-        case RogueThreat:
-            if (GOUGE > 0 && !pTarget->HasAura(GOUGE, EFFECT_INDEX_0) && m_ai->CastSpell(GOUGE, *pTarget))
-                return RETURN_CONTINUE;
-            if (EVASION > 0 && m_ai->GetHealthPercent() <= 35 && !m_bot->HasAura(EVASION, EFFECT_INDEX_0) && m_ai->CastSpell(EVASION))
-                return RETURN_CONTINUE;
-            if (BLIND > 0 && m_ai->GetHealthPercent() <= 30 && !pTarget->HasAura(BLIND, EFFECT_INDEX_0) && m_ai->CastSpell(BLIND, *pTarget))
-                return RETURN_CONTINUE;
-            if (FEINT > 0 && m_ai->GetHealthPercent() <= 25 && m_ai->CastSpell(FEINT))
-                return RETURN_CONTINUE;
-            if (VANISH > 0 && m_ai->GetHealthPercent() <= 20 && !m_bot->HasAura(FEINT, EFFECT_INDEX_0) && m_ai->CastSpell(VANISH))
-                return RETURN_CONTINUE;
-            if (PREPARATION > 0 && m_ai->CastSpell(PREPARATION))
-                return RETURN_CONTINUE;
-            break;
-
-        case RogueSpellPreventing:
-            if (KIDNEY_SHOT > 0 && m_bot->GetComboPoints() >= 2 && m_ai->CastSpell(KIDNEY_SHOT, *pTarget))
-                return RETURN_CONTINUE;
-            else if (KICK > 0 && m_ai->CastSpell(KICK, *pTarget))
-                return RETURN_CONTINUE;
-        // break; // No action? Go combat!
-
-        case RogueCombat:
-        default:
-            if (m_bot->GetComboPoints() >= 5)
-            {
-                // wait for energy
-                if (m_ai->GetEnergyAmount() < 25 && (KIDNEY_SHOT || SLICE_DICE || EXPOSE_ARMOR))
-                    return RETURN_NO_ACTION_OK;
-
-                switch (pTarget->getClass())
-                {
-                    case CLASS_SHAMAN:
-                        if (KIDNEY_SHOT > 0 && m_ai->CastSpell(KIDNEY_SHOT, *pTarget)) // 25 energy (checked above)
-                            return RETURN_CONTINUE;
-                        break;
-
-                    case CLASS_WARLOCK:
-                    case CLASS_HUNTER:
-                        if (SLICE_DICE > 0 && m_ai->CastSpell(SLICE_DICE, *pTarget)) // 25 energy (checked above)
-                            return RETURN_CONTINUE;
-                        break;
-
-                    case CLASS_WARRIOR:
-                    case CLASS_PALADIN:
-                        if (EXPOSE_ARMOR > 0 && !pTarget->HasAura(EXPOSE_ARMOR, EFFECT_INDEX_0) && m_ai->CastSpell(EXPOSE_ARMOR, *pTarget)) // 25 energy (checked above)
-                            return RETURN_CONTINUE;
-                        break;
-
-
-                    case CLASS_MAGE:
-                    case CLASS_PRIEST:
-                        if (RUPTURE > 0 && m_ai->CastSpell(RUPTURE, *pTarget)) // 25 energy (checked above)
-                            return RETURN_CONTINUE;
-                        break;
-
-                    case CLASS_ROGUE:
-                    case CLASS_DRUID:
-                    default:
-                        break; // fall through to below
-                }
-
-                // default combo action for rogue/druid or if other combo action is unavailable/failed
-                // wait for energy
-                if (m_ai->GetEnergyAmount() < 35 && EVISCERATE)
-                    return RETURN_NO_ACTION_OK;
-                if (EVISCERATE > 0 && m_ai->CastSpell(EVISCERATE, *pTarget))
-                    return RETURN_CONTINUE;
-
-                // failed for some (non-energy related) reason, fall through to normal attacks to maximize DPS
-            }
-
-            if (CHEAP_SHOT > 0 && !pTarget->HasAura(CHEAP_SHOT, EFFECT_INDEX_0) && m_ai->CastSpell(CHEAP_SHOT, *pTarget))
-                return RETURN_CONTINUE;
-            if (AMBUSH > 0 && m_ai->CastSpell(AMBUSH, *pTarget))
-                return RETURN_CONTINUE;
-            if (GARROTE > 0 && m_ai->CastSpell(GARROTE, *pTarget))
-                return RETURN_CONTINUE;
-            if (BACKSTAB > 0 && pTarget->isInBackInMap(m_bot, 1) && m_ai->CastSpell(BACKSTAB, *pTarget))
-                return RETURN_CONTINUE;
-            if (SINISTER_STRIKE > 0 && m_ai->CastSpell(SINISTER_STRIKE, *pTarget))
-                return RETURN_CONTINUE;
-            if (GHOSTLY_STRIKE > 0 && m_ai->CastSpell(GHOSTLY_STRIKE, *pTarget))
-                return RETURN_CONTINUE;
-            if (HEMORRHAGE > 0 && m_ai->CastSpell(HEMORRHAGE, *pTarget))
-                return RETURN_CONTINUE;
-            if (SHADOWSTEP > 0 && m_ai->CastSpell(SHADOWSTEP, *pTarget))
-                return RETURN_CONTINUE;
-            if (m_bot->getRace() == RACE_BLOODELF && !pTarget->HasAura(ARCANE_TORRENT, EFFECT_INDEX_0) && m_ai->CastSpell(ARCANE_TORRENT, *pTarget))
-                return RETURN_CONTINUE;
-            if (m_bot->getRace() == RACE_UNDEAD && (m_bot->HasAuraType(SPELL_AURA_MOD_FEAR) || m_bot->HasAuraType(SPELL_AURA_MOD_CHARM)) && m_ai->CastSpell(WILL_OF_THE_FORSAKEN, *m_bot))
-                return RETURN_CONTINUE;
-//            if (m_bot->getRace() == RACE_DWARF && m_bot->HasAuraState(AURA_STATE_DEADLY_POISON) && m_ai->CastSpell(STONEFORM, *m_bot))
-//                return RETURN_CONTINUE;
-            if (m_bot->getRace() == RACE_GNOME && (m_bot->hasUnitState(UNIT_STAT_STUNNED) || m_bot->HasAuraType(SPELL_AURA_MOD_DECREASE_SPEED)) && m_ai->CastSpell(ESCAPE_ARTIST, *m_bot))
-                return RETURN_CONTINUE;
-            else if (m_bot->getRace() == RACE_ORC && !m_bot->HasAura(BLOOD_FURY, EFFECT_INDEX_0) && m_ai->CastSpell(BLOOD_FURY, *m_bot))
-                return RETURN_CONTINUE;
-            else if (m_bot->getRace() == RACE_TROLL && !m_bot->HasAura(BERSERKING, EFFECT_INDEX_0) && m_ai->CastSpell(BERSERKING, *m_bot))
-                return RETURN_CONTINUE;
-
-            break;
-    }
-
-    return RETURN_NO_ACTION_OK;
-}
-
-static const uint32 uPriorizedPoisonIds[4] =
-{
-    ANESTHETIC_POISON_DISPLAYID, INSTANT_POISON_DISPLAYID, WOUND_POISON_DISPLAYID, DEADLY_POISON_DISPLAYID
-};
-
-// Return a poison Item based
-Item* PlayerbotRogueAI::FindPoison() const
-{
-    Item* poison;
-    for (uint8 i = 0; i < countof(uPriorizedPoisonIds); ++i)
-    {
-        poison = m_ai->FindConsumable(uPriorizedPoisonIds[i]);
-        if (poison)
-            return poison;
-    }
-    return nullptr;
-}
-
-void PlayerbotRogueAI::DoNonCombatActions()
-{
-    if (!m_ai)  return;
-    if (!m_bot) return;
-
-    // remove stealth
-    if (m_bot->HasAura(STEALTH))
-        m_bot->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
-
-    // hp check
-    if (EatDrinkBandage(false))
-        return;
-
-    // Search and apply poisons to weapons, if no poison found, try to apply a sharpening/weight stone
-    // Mainhand ...
-    Item* poison, * stone, * weapon;
-    weapon = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
-    if (weapon && weapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT) == 0)
-    {
-        poison = FindPoison();
-        if (poison)
-        {
-            m_ai->UseItem(poison, EQUIPMENT_SLOT_MAINHAND);
-            m_ai->SetIgnoreUpdateTime(5);
-        }
-        else
-        {
-            stone = m_ai->FindStoneFor(weapon);
-            if (stone)
-            {
-                m_ai->UseItem(stone, EQUIPMENT_SLOT_MAINHAND);
-                m_ai->SetIgnoreUpdateTime(5);
-            }
-        }
-    }
-    //... and offhand
-    weapon = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
-    if (weapon && weapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT) == 0)
-    {
-        poison = FindPoison();
-        if (poison)
-        {
-            m_ai->UseItem(poison, EQUIPMENT_SLOT_OFFHAND);
-            m_ai->SetIgnoreUpdateTime(5);
-        }
-        else
-        {
-            stone = m_ai->FindStoneFor(weapon);
-            if (stone)
-            {
-                m_ai->UseItem(stone, EQUIPMENT_SLOT_OFFHAND);
-                m_ai->SetIgnoreUpdateTime(5);
-            }
-        }
-    }
-
-    // Nothing else to do, Night Elves will cast Shadowmeld to reduce their aggro versus patrols or nearby mobs
-    if (SHADOWMELD && !m_bot->HasAura(SHADOWMELD, EFFECT_INDEX_0) && m_ai->CastSpell(SHADOWMELD, *m_bot))
-        return;
-} // end DoNonCombatActions
diff --git a/src/game/PlayerBot/AI/PlayerbotRogueAI.h b/src/game/PlayerBot/AI/PlayerbotRogueAI.h
deleted file mode 100644
index 054ba5791..000000000
--- a/src/game/PlayerBot/AI/PlayerbotRogueAI.h
+++ /dev/null
@@ -1,160 +0,0 @@
-/*
- * This file is part of the CMaNGOS Project. See AUTHORS file for Copyright information
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _PlayerbotRogueAI_H
-#define _PlayerbotRogueAI_H
-
-#include "../Base/PlayerbotClassAI.h"
-
-enum
-{
-    RogueCombat,
-    RogueSpellPreventing,
-    RogueThreat,
-    RogueStealth
-};
-
-enum RoguePoisonDisplayId
-{
-    DEADLY_POISON_DISPLAYID         = 13707,
-    CRIPPLING_POISON_DISPLAYID      = 13708,
-    MIND_NUMBLING_POISON_DISPLAYID  = 13709,
-    INSTANT_POISON_DISPLAYID        = 13710,
-    WOUND_POISON_DISPLAYID          = 37278,
-    ANESTHETIC_POISON_DISPLAYID     = 34432,
-};
-
-enum RogueSpells
-{
-    ADRENALINE_RUSH_1               = 13750,
-    AMBUSH_1                        = 8676,
-    BACKSTAB_1                      = 53,
-    BLADE_FLURRY_1                  = 13877,
-    BLIND_1                         = 2094,
-    CHEAP_SHOT_1                    = 1833,
-    CLOAK_OF_SHADOWS_1              = 31224,
-    COLD_BLOOD_1                    = 14177,
-    DEADLY_THROW_1                  = 26679,
-    DISARM_TRAP_1                   = 1842,
-    DISTRACT_1                      = 1725,
-    ENVENOM_1                       = 32645,
-    EVASION_1                       = 5277,
-    EVISCERATE_1                    = 2098,
-    EXPOSE_ARMOR_1                  = 8647,
-    FEINT_1                         = 1966,
-    GARROTE_1                       = 703,
-    GHOSTLY_STRIKE_1                = 14278,
-    GOUGE_1                         = 1776,
-    HEMORRHAGE_1                    = 16511,
-    KICK_1                          = 1766,
-    KIDNEY_SHOT_1                   = 408,
-    MUTILATE_1                      = 1329,
-    PICK_LOCK_1                     = 1804,
-    PICK_POCKET_1                   = 921,
-    PREMEDITATION_1                 = 14183,
-    PREPARATION_1                   = 14185,
-    RIPOSTE_1                       = 14251,
-    RUPTURE_1                       = 1943,
-    SAP_1                           = 6770,
-    SHADOWSTEP_1                    = 36554,
-    SHIV_1                          = 5938,
-    SINISTER_STRIKE_1               = 1752,
-    SLICE_AND_DICE_1                = 5171,
-    SPRINT_1                        = 2983,
-    STEALTH_1                       = 1784,
-    VANISH_1                        = 1856
-};
-//class Player;
-
-class PlayerbotRogueAI : PlayerbotClassAI
-{
-    public:
-        PlayerbotRogueAI(Player* const master, Player* const bot, PlayerbotAI* const ai);
-        virtual ~PlayerbotRogueAI();
-
-        // all combat actions go here
-        CombatManeuverReturns DoFirstCombatManeuver(Unit* pTarget);
-        CombatManeuverReturns DoNextCombatManeuver(Unit* pTarget);
-
-        // all non combat actions go here, ex buffs, heals, rezzes
-        void DoNonCombatActions();
-
-    private:
-        CombatManeuverReturns DoFirstCombatManeuverPVE(Unit* pTarget);
-        CombatManeuverReturns DoNextCombatManeuverPVE(Unit* pTarget);
-        CombatManeuverReturns DoFirstCombatManeuverPVP(Unit* pTarget);
-        CombatManeuverReturns DoNextCombatManeuverPVP(Unit* pTarget);
-        Item* FindPoison() const;
-
-        // COMBAT
-        uint32 ADRENALINE_RUSH,
-               SINISTER_STRIKE,
-               BACKSTAB,
-               GOUGE,
-               EVASION,
-               SPRINT,
-               KICK,
-               FEINT,
-               SHIV;
-
-        // SUBTLETY
-        uint32 SHADOWSTEP,
-               STEALTH,
-               VANISH,
-               HEMORRHAGE,
-               BLIND,
-               PICK_POCKET,
-               CLOAK_OF_SHADOWS,
-               CRIPPLING_POISON,
-               DEADLY_POISON,
-               MIND_NUMBING_POISON,
-               GHOSTLY_STRIKE,
-               DISTRACT,
-               PREPARATION,
-               PREMEDITATION;
-
-        // ASSASSINATION
-        uint32 COLD_BLOOD,
-               EVISCERATE,
-               SLICE_DICE,
-               GARROTE,
-               EXPOSE_ARMOR,
-               AMBUSH,
-               RUPTURE,
-               CHEAP_SHOT,
-               KIDNEY_SHOT,
-               MUTILATE,
-               ENVENOM,
-               DEADLY_THROW;
-
-        // racial
-        uint32 ARCANE_TORRENT,
-               GIFT_OF_THE_NAARU,
-               STONEFORM,
-               ESCAPE_ARTIST,
-               PERCEPTION,
-               SHADOWMELD,
-               BLOOD_FURY,
-               WAR_STOMP,
-               BERSERKING,
-               WILL_OF_THE_FORSAKEN;
-
-        uint32 SpellSequence, LastSpellCombat, LastSpellSubtlety, LastSpellAssassination, Aura;
-};
-
-#endif
diff --git a/src/game/PlayerBot/AI/PlayerbotShamanAI.cpp b/src/game/PlayerBot/AI/PlayerbotShamanAI.cpp
deleted file mode 100644
index 84b59fdf7..000000000
--- a/src/game/PlayerBot/AI/PlayerbotShamanAI.cpp
+++ /dev/null
@@ -1,497 +0,0 @@
-/*
- * This file is part of the CMaNGOS Project. See AUTHORS file for Copyright information
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "PlayerbotShamanAI.h"
-#include "../../Entities/Totem.h"
-
-class PlayerbotAI;
-PlayerbotShamanAI::PlayerbotShamanAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
-{
-    // restoration
-    CHAIN_HEAL               = m_ai->initSpell(CHAIN_HEAL_1);
-    HEALING_WAVE             = m_ai->initSpell(HEALING_WAVE_1);
-    LESSER_HEALING_WAVE      = m_ai->initSpell(LESSER_HEALING_WAVE_1);
-    ANCESTRAL_SPIRIT         = m_ai->initSpell(ANCESTRAL_SPIRIT_1);
-    EARTH_SHIELD             = m_ai->initSpell(EARTH_SHIELD_1);
-    TREMOR_TOTEM             = m_ai->initSpell(TREMOR_TOTEM_1); // totems
-    MANA_SPRING_TOTEM        = m_ai->initSpell(MANA_SPRING_TOTEM_1);
-    MANA_TIDE_TOTEM          = m_ai->initSpell(MANA_TIDE_TOTEM_1);
-    CURE_DISEASE_SHAMAN      = m_ai->initSpell(CURE_DISEASE_SHAMAN_1);
-    CURE_POISON_SHAMAN       = m_ai->initSpell(CURE_POISON_SHAMAN_1);
-    // enhancement
-    FOCUSED                  = 0; // Focused what?
-    STORMSTRIKE              = m_ai->initSpell(STORMSTRIKE_1);
-    SHAMANISTIC_RAGE         = m_ai->initSpell(SHAMANISTIC_RAGE_1);
-    BLOODLUST                = m_ai->initSpell(BLOODLUST_1);
-    LIGHTNING_SHIELD         = m_ai->initSpell(LIGHTNING_SHIELD_1);
-    ROCKBITER_WEAPON         = m_ai->initSpell(ROCKBITER_WEAPON_1);
-    FLAMETONGUE_WEAPON       = m_ai->initSpell(FLAMETONGUE_WEAPON_1);
-    FROSTBRAND_WEAPON        = m_ai->initSpell(FROSTBRAND_WEAPON_1);
-    WINDFURY_WEAPON          = m_ai->initSpell(WINDFURY_WEAPON_1);
-    STONESKIN_TOTEM          = m_ai->initSpell(STONESKIN_TOTEM_1); // totems
-    STRENGTH_OF_EARTH_TOTEM  = m_ai->initSpell(STRENGTH_OF_EARTH_TOTEM_1);
-    FROST_RESISTANCE_TOTEM   = m_ai->initSpell(FROST_RESISTANCE_TOTEM_1);
-    FLAMETONGUE_TOTEM        = m_ai->initSpell(FLAMETONGUE_TOTEM_1);
-    FIRE_RESISTANCE_TOTEM    = m_ai->initSpell(FIRE_RESISTANCE_TOTEM_1);
-    GROUNDING_TOTEM          = m_ai->initSpell(GROUNDING_TOTEM_1);
-    NATURE_RESISTANCE_TOTEM  = m_ai->initSpell(NATURE_RESISTANCE_TOTEM_1);
-    WIND_FURY_TOTEM          = m_ai->initSpell(WINDFURY_TOTEM_1);
-    STONESKIN_TOTEM          = m_ai->initSpell(STONESKIN_TOTEM_1);
-    WRATH_OF_AIR_TOTEM       = m_ai->initSpell(WRATH_OF_AIR_TOTEM_1);
-    EARTH_ELEMENTAL_TOTEM    = m_ai->initSpell(EARTH_ELEMENTAL_TOTEM_1);
-    // elemental
-    LIGHTNING_BOLT           = m_ai->initSpell(LIGHTNING_BOLT_1);
-    EARTH_SHOCK              = m_ai->initSpell(EARTH_SHOCK_1);
-    FLAME_SHOCK              = m_ai->initSpell(FLAME_SHOCK_1);
-    PURGE                    = m_ai->initSpell(PURGE_1);
-    WIND_SHOCK               = 0; //NPC spell
-    FROST_SHOCK              = m_ai->initSpell(FROST_SHOCK_1);
-    CHAIN_LIGHTNING          = m_ai->initSpell(CHAIN_LIGHTNING_1);
-    STONECLAW_TOTEM          = m_ai->initSpell(STONECLAW_TOTEM_1); // totems
-    SEARING_TOTEM            = m_ai->initSpell(SEARING_TOTEM_1);
-    FIRE_NOVA_TOTEM          = 0; // NPC only spell, check FIRE_NOVA_1
-    MAGMA_TOTEM              = m_ai->initSpell(MAGMA_TOTEM_1);
-    EARTHBIND_TOTEM          = m_ai->initSpell(EARTHBIND_TOTEM_1);
-    TOTEM_OF_WRATH           = m_ai->initSpell(TOTEM_OF_WRATH_1);
-    FIRE_ELEMENTAL_TOTEM     = m_ai->initSpell(FIRE_ELEMENTAL_TOTEM_1);
-
-    RECENTLY_BANDAGED        = 11196; // first aid check
-
-    // racial
-    GIFT_OF_THE_NAARU        = m_ai->initSpell(GIFT_OF_THE_NAARU_ALL); // draenei
-    BLOOD_FURY               = m_ai->initSpell(BLOOD_FURY_SHAMAN); // orc
-    WAR_STOMP                = m_ai->initSpell(WAR_STOMP_ALL); // tauren
-    BERSERKING               = m_ai->initSpell(BERSERKING_ALL); // troll
-
-    // totem buffs
-    STRENGTH_OF_EARTH_EFFECT    = m_ai->initSpell(STRENGTH_OF_EARTH_EFFECT_1);
-    FLAMETONGUE_EFFECT          = m_ai->initSpell(FLAMETONGUE_EFFECT_1);
-    MAGMA_TOTEM_EFFECT          = m_ai->initSpell(MAGMA_TOTEM_EFFECT_1);
-    STONECLAW_EFFECT            = m_ai->initSpell(STONECLAW_EFFECT_1);
-    FIRE_RESISTANCE_EFFECT      = m_ai->initSpell(FIRE_RESISTANCE_EFFECT_1);
-    FROST_RESISTANCE_EFFECT     = m_ai->initSpell(FROST_RESISTANCE_EFFECT_1);
-    GROUDNING_EFFECT            = m_ai->initSpell(GROUDNING_EFFECT_1);
-    NATURE_RESISTANCE_EFFECT    = m_ai->initSpell(NATURE_RESISTANCE_EFFECT_1);
-    STONESKIN_EFFECT            = m_ai->initSpell(STONESKIN_EFFECT_1);
-    WINDFURY_EFFECT             = m_ai->initSpell(WINDFURY_EFFECT_1);
-    WRATH_OF_AIR_EFFECT         = m_ai->initSpell(WRATH_OF_AIR_EFFECT_1);
-    CLEANSING_TOTEM_EFFECT      = m_ai->initSpell(CLEANSING_TOTEM_EFFECT_1);
-    MANA_SPRING_EFFECT          = m_ai->initSpell(MANA_SPRING_EFFECT_1);
-    TREMOR_TOTEM_EFFECT         = m_ai->initSpell(TREMOR_TOTEM_EFFECT_1);
-    STONECLAW_EFFECT            = m_ai->initSpell(STONECLAW_EFFECT_1);
-    EARTHBIND_EFFECT            = m_ai->initSpell(EARTHBIND_EFFECT_1);
-}
-
-PlayerbotShamanAI::~PlayerbotShamanAI() {}
-
-CombatManeuverReturns PlayerbotShamanAI::DoFirstCombatManeuver(Unit* pTarget)
-{
-    // There are NPCs in BGs and Open World PvP, so don't filter this on PvP scenarios (of course if PvP targets anyone but tank, all bets are off anyway)
-    // Wait until the tank says so, until any non-tank gains aggro or X seconds - whichever is shortest
-    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO)
-    {
-        if (m_WaitUntil > m_ai->CurrentTime() && m_ai->GroupTankHoldsAggro())
-        {
-            if (PlayerbotAI::ORDERS_HEAL & m_ai->GetCombatOrder())
-                return HealPlayer(GetHealTarget());
-            else
-                return RETURN_NO_ACTION_OK; // wait it out
-        }
-        else
-        {
-            m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO);
-        }
-    }
-
-    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TEMP_WAIT_OOC)
-    {
-        if (m_WaitUntil > m_ai->CurrentTime() && m_ai->IsGroupReady())
-            return RETURN_NO_ACTION_OK; // wait it out
-        else
-            m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_OOC);
-    }
-
-    switch (m_ai->GetScenarioType())
-    {
-        case PlayerbotAI::SCENARIO_PVP_DUEL:
-        case PlayerbotAI::SCENARIO_PVP_BG:
-        case PlayerbotAI::SCENARIO_PVP_ARENA:
-        case PlayerbotAI::SCENARIO_PVP_OPENWORLD:
-            return DoFirstCombatManeuverPVP(pTarget);
-        case PlayerbotAI::SCENARIO_PVE:
-        case PlayerbotAI::SCENARIO_PVE_ELITE:
-        case PlayerbotAI::SCENARIO_PVE_RAID:
-        default:
-            return DoFirstCombatManeuverPVE(pTarget);
-            break;
-    }
-
-    return RETURN_NO_ACTION_ERROR;
-}
-
-CombatManeuverReturns PlayerbotShamanAI::DoFirstCombatManeuverPVE(Unit* /*pTarget*/)
-{
-    return RETURN_NO_ACTION_OK;
-}
-
-CombatManeuverReturns PlayerbotShamanAI::DoFirstCombatManeuverPVP(Unit* /*pTarget*/)
-{
-    return RETURN_NO_ACTION_OK;
-}
-
-CombatManeuverReturns PlayerbotShamanAI::DoNextCombatManeuver(Unit* pTarget)
-{
-    // Face enemy, make sure bot is attacking
-    m_ai->FaceTarget(pTarget);
-
-    switch (m_ai->GetScenarioType())
-    {
-        case PlayerbotAI::SCENARIO_PVP_DUEL:
-        case PlayerbotAI::SCENARIO_PVP_BG:
-        case PlayerbotAI::SCENARIO_PVP_ARENA:
-        case PlayerbotAI::SCENARIO_PVP_OPENWORLD:
-            return DoNextCombatManeuverPVP(pTarget);
-        case PlayerbotAI::SCENARIO_PVE:
-        case PlayerbotAI::SCENARIO_PVE_ELITE:
-        case PlayerbotAI::SCENARIO_PVE_RAID:
-        default:
-            return DoNextCombatManeuverPVE(pTarget);
-            break;
-    }
-
-    return RETURN_NO_ACTION_ERROR;
-}
-
-CombatManeuverReturns PlayerbotShamanAI::DoNextCombatManeuverPVE(Unit* pTarget)
-{
-    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
-    if (!m_bot) return RETURN_NO_ACTION_ERROR;
-
-    uint32 spec = m_bot->GetSpec();
-
-    // Make sure healer stays put, don't even melee (aggro) if in range.
-    if (m_ai->IsHealer() && m_ai->GetCombatStyle() != PlayerbotAI::COMBAT_RANGED)
-        m_ai->SetCombatStyle(PlayerbotAI::COMBAT_RANGED);
-    else if (!m_ai->IsHealer() && m_ai->GetCombatStyle() != PlayerbotAI::COMBAT_MELEE)
-        m_ai->SetCombatStyle(PlayerbotAI::COMBAT_MELEE);
-
-    // Heal
-    if (m_ai->IsHealer())
-    {
-        if (HealPlayer(GetHealTarget()) & (RETURN_NO_ACTION_OK | RETURN_CONTINUE))
-            return RETURN_CONTINUE;
-    }
-    else
-    {
-        // Is this desirable? Debatable.
-        // TODO: In a group/raid with a healer you'd want this bot to focus on DPS (it's not specced/geared for healing either)
-        if (HealPlayer(m_bot) & RETURN_CONTINUE)
-            return RETURN_CONTINUE;
-    }
-
-    // Damage Spells
-    DropTotems();
-    CheckShields();
-    UseCooldowns();
-    switch (spec)
-    {
-        case SHAMAN_SPEC_ENHANCEMENT:
-            if (STORMSTRIKE > 0 && (m_bot->IsSpellReady(STORMSTRIKE)) && m_ai->CastSpell(STORMSTRIKE, *pTarget))
-                return RETURN_CONTINUE;
-            if (FLAME_SHOCK > 0 && (!pTarget->HasAura(FLAME_SHOCK)) && m_ai->CastSpell(FLAME_SHOCK, *pTarget))
-                return RETURN_CONTINUE;
-            if (EARTH_SHOCK > 0 && (m_bot->IsSpellReady(EARTH_SHOCK)) && m_ai->CastSpell(EARTH_SHOCK, *pTarget))
-                return RETURN_CONTINUE;
-            /*if (FOCUSED > 0 && m_ai->CastSpell(FOCUSED, *pTarget))
-                return RETURN_CONTINUE;*/
-            break;
-
-        case SHAMAN_SPEC_RESTORATION:
-        // fall through to elemental
-
-        case SHAMAN_SPEC_ELEMENTAL:
-            if (FLAME_SHOCK > 0 && (!pTarget->HasAura(FLAME_SHOCK)) && m_ai->CastSpell(FLAME_SHOCK, *pTarget))
-                return RETURN_CONTINUE;
-            if (LIGHTNING_BOLT > 0 && m_ai->CastSpell(LIGHTNING_BOLT, *pTarget))
-                return RETURN_CONTINUE;
-            /*if (PURGE > 0 && m_ai->CastSpell(PURGE, *pTarget))
-                return RETURN_CONTINUE;*/
-            /*if (WIND_SHOCK > 0 && m_ai->CastSpell(WIND_SHOCK, *pTarget))
-                return RETURN_CONTINUE;*/
-            /*if (FROST_SHOCK > 0 && !pTarget->HasAura(FROST_SHOCK, EFFECT_INDEX_0) && m_ai->CastSpell(FROST_SHOCK, *pTarget))
-                return RETURN_CONTINUE;*/
-            /*if (CHAIN_LIGHTNING > 0 && m_ai->CastSpell(CHAIN_LIGHTNING, *pTarget))
-                return RETURN_CONTINUE;*/
-            /*if (HEX > 0 && !pTarget->HasAura(HEX, EFFECT_INDEX_0) && m_ai->CastSpell(HEX))
-                return RETURN_CONTINUE;*/
-    }
-
-    return RETURN_NO_ACTION_OK;
-} // end DoNextCombatManeuver
-
-CombatManeuverReturns PlayerbotShamanAI::DoNextCombatManeuverPVP(Unit* pTarget)
-{
-    DropTotems();
-    CheckShields();
-    UseCooldowns();
-
-    Player* healTarget = (m_ai->GetScenarioType() == PlayerbotAI::SCENARIO_PVP_DUEL) ? GetHealTarget() : m_bot;
-    if (HealPlayer(healTarget) & (RETURN_NO_ACTION_OK | RETURN_CONTINUE))
-        return RETURN_CONTINUE;
-    if (m_ai->CastSpell(LIGHTNING_BOLT))
-        return RETURN_CONTINUE;
-
-    return DoNextCombatManeuverPVE(pTarget); // TODO: bad idea perhaps, but better than the alternative
-}
-
-CombatManeuverReturns PlayerbotShamanAI::HealPlayer(Player* target)
-{
-    CombatManeuverReturns r = PlayerbotClassAI::HealPlayer(target);
-    if (r != RETURN_NO_ACTION_OK)
-        return r;
-
-    if (!target->isAlive())
-    {
-        if (ANCESTRAL_SPIRIT && m_ai->CastSpell(ANCESTRAL_SPIRIT, *target))
-        {
-            std::string msg = "Resurrecting ";
-            msg += target->GetName();
-            m_bot->Say(msg, LANG_UNIVERSAL);
-            return RETURN_CONTINUE;
-        }
-        return RETURN_NO_ACTION_ERROR; // not error per se - possibly just OOM
-    }
-
-    // Remove poison on group members if orders allow bot to do so
-    if (Player* pPoisonedTarget = GetDispelTarget(DISPEL_POISON))
-    {
-        if (CURE_POISON_SHAMAN > 0 && (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_NODISPEL) == 0 && m_ai->CastSpell(CURE_POISON_SHAMAN, *pPoisonedTarget))
-            return RETURN_CONTINUE;
-    }
-
-    // Remove disease on group members if orders allow bot to do so
-    if (Player* pDiseasedTarget = GetDispelTarget(DISPEL_DISEASE))
-    {
-        if (CURE_DISEASE_SHAMAN > 0 && (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_NODISPEL) == 0 && m_ai->CastSpell(CURE_DISEASE_SHAMAN, *pDiseasedTarget))
-            return RETURN_CONTINUE;
-    }
-
-    // Everyone is healthy enough, return OK. MUST correlate to highest value below (should be last HP check)
-    if (target->GetHealthPercent() >= 80)
-        return RETURN_NO_ACTION_OK;
-
-    // Technically the best rotation is CHAIN + LHW + LHW subbing in HW for trouble (bad mana efficiency)
-    if (target->GetHealthPercent() < 30 && HEALING_WAVE > 0 && m_ai->CastSpell(HEALING_WAVE, *target))
-        return RETURN_CONTINUE;
-    if (target->GetHealthPercent() < 50 && LESSER_HEALING_WAVE > 0 && m_ai->CastSpell(LESSER_HEALING_WAVE, *target))
-        return RETURN_CONTINUE;
-    if (target->GetHealthPercent() < 80 && CHAIN_HEAL > 0 && m_ai->CastSpell(CHAIN_HEAL, *target))
-        return RETURN_CONTINUE;
-
-    return RETURN_NO_ACTION_UNKNOWN;
-} // end HealTarget
-
-void PlayerbotShamanAI::DropTotems()
-{
-    if (!m_ai)  return;
-    if (!m_bot) return;
-
-    uint32 spec = m_bot->GetSpec();
-
-    Totem* earth = m_bot->GetTotem(TOTEM_SLOT_EARTH);
-    Totem* fire = m_bot->GetTotem(TOTEM_SLOT_FIRE);
-    Totem* water = m_bot->GetTotem(TOTEM_SLOT_WATER);
-    Totem* air = m_bot->GetTotem(TOTEM_SLOT_AIR);
-
-    // Earth Totems
-    if ((earth == nullptr) || (m_bot->GetDistance(earth) > 30))
-    {
-        if (STRENGTH_OF_EARTH_TOTEM > 0 && m_ai->CastSpell(STRENGTH_OF_EARTH_TOTEM))
-            return;
-    }
-
-    // Fire Totems
-    if ((fire == nullptr) || (m_bot->GetDistance(fire) > 30))
-    {
-        if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_RESIST_FROST && FROST_RESISTANCE_TOTEM > 0 && m_ai->CastSpell(FROST_RESISTANCE_TOTEM))
-            return;
-        else if (spec == SHAMAN_SPEC_ELEMENTAL && TOTEM_OF_WRATH > 0 && m_ai->CastSpell(TOTEM_OF_WRATH))
-            return;
-        // If the spec didn't take totem of wrath, use flametongue
-        else if ((spec != SHAMAN_SPEC_ELEMENTAL || TOTEM_OF_WRATH == 0) && FLAMETONGUE_TOTEM > 0 && m_ai->CastSpell(FLAMETONGUE_TOTEM))
-            return;
-    }
-
-    // Air totems
-    if ((air == nullptr) || (m_bot->GetDistance(air) > 30))
-    {
-        if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_RESIST_NATURE && NATURE_RESISTANCE_TOTEM > 0 && m_ai->CastSpell(NATURE_RESISTANCE_TOTEM))
-            return;
-        else if (spec == SHAMAN_SPEC_ENHANCEMENT)
-        {
-            if (WIND_FURY_TOTEM > 0 /*&& !m_bot->HasAura(IMPROVED_ICY_TALONS)*/ && m_ai->CastSpell(WIND_FURY_TOTEM))
-                return;
-        }
-        else
-        {
-            if (WRATH_OF_AIR_TOTEM > 0 && m_ai->CastSpell(WRATH_OF_AIR_TOTEM))
-                return;
-        }
-    }
-
-    // Water Totems
-    if ((water == nullptr) || (m_bot->GetDistance(water) > 30))
-    {
-        if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_RESIST_FIRE && FIRE_RESISTANCE_TOTEM > 0 && m_ai->CastSpell(FIRE_RESISTANCE_TOTEM))
-            return;
-        else if (MANA_SPRING_TOTEM > 0 && m_ai->CastSpell(MANA_SPRING_TOTEM))
-            return;
-    }
-
-    /*if (EARTH_ELEMENTAL_TOTEM > 0 && m_ai->CastSpell(EARTH_ELEMENTAL_TOTEM))
-        return RETURN_CONTINUE;*/
-    /*if (EARTHBIND_TOTEM > 0 && !pTarget->HasAura(EARTHBIND_TOTEM, EFFECT_INDEX_0) && !m_bot->HasAura(STRENGTH_OF_EARTH_TOTEM, EFFECT_INDEX_0) && m_ai->CastSpell(EARTHBIND_TOTEM))
-        return RETURN_CONTINUE;*/
-    /*if (FIRE_ELEMENTAL_TOTEM > 0 && m_ai->CastSpell(FIRE_ELEMENTAL_TOTEM))
-        return RETURN_CONTINUE;*/
-    /*if (FIRE_NOVA_TOTEM > 0 && m_ai->CastSpell(FIRE_NOVA_TOTEM))
-        return RETURN_CONTINUE;*/
-    /*if (GROUNDING_TOTEM > 0 && !m_bot->HasAura(GROUNDING_TOTEM, EFFECT_INDEX_0) && !m_bot->HasAura(WRATH_OF_AIR_TOTEM, EFFECT_INDEX_0) && !m_bot->HasAura(WIND_FURY_TOTEM, EFFECT_INDEX_0) && m_ai->CastSpell(GROUNDING_TOTEM))
-        return RETURN_CONTINUE;*/
-    /*if (MAGMA_TOTEM > 0 && (!m_bot->HasAura(TOTEM_OF_WRATH, EFFECT_INDEX_0)) && m_ai->CastSpell(MAGMA_TOTEM))
-        return RETURN_CONTINUE;*/
-    /*if (SEARING_TOTEM > 0 && !pTarget->HasAura(SEARING_TOTEM, EFFECT_INDEX_0) && !m_bot->HasAura(TOTEM_OF_WRATH, EFFECT_INDEX_0) && m_ai->CastSpell(SEARING_TOTEM))
-        return RETURN_CONTINUE;*/
-    /*if (STONECLAW_TOTEM > 0 && m_ai->GetHealthPercent() < 51 && !pTarget->HasAura(STONECLAW_TOTEM, EFFECT_INDEX_0) && !pTarget->HasAura(EARTHBIND_TOTEM, EFFECT_INDEX_0) && !m_bot->HasAura(STRENGTH_OF_EARTH_TOTEM, EFFECT_INDEX_0) && m_ai->CastSpell(STONECLAW_TOTEM))
-        return RETURN_CONTINUE;*/
-    /*if (STONESKIN_TOTEM > 0 && !m_bot->HasAura(STONESKIN_TOTEM, EFFECT_INDEX_0) && !m_bot->HasAura(STRENGTH_OF_EARTH_TOTEM, EFFECT_INDEX_0) && m_ai->CastSpell(STONESKIN_TOTEM))
-        return RETURN_CONTINUE;*/
-    /*if (TREMOR_TOTEM > 0 && !m_bot->HasAura(STRENGTH_OF_EARTH_TOTEM, EFFECT_INDEX_0) && m_ai->CastSpell(TREMOR_TOTEM))
-        return RETURN_CONTINUE;*/
-}
-
-void PlayerbotShamanAI::CheckShields()
-{
-    if (!m_ai)  return;
-    if (!m_bot) return;
-
-    uint32 spec = m_bot->GetSpec();
-
-    if (spec == SHAMAN_SPEC_ENHANCEMENT && LIGHTNING_SHIELD > 0 && !m_bot->HasAura(LIGHTNING_SHIELD, EFFECT_INDEX_0))
-        m_ai->CastSpell(LIGHTNING_SHIELD, *m_bot);
-    if (EARTH_SHIELD > 0 && !GetMaster()->HasAura(EARTH_SHIELD, EFFECT_INDEX_0))
-        m_ai->CastSpell(EARTH_SHIELD, *(GetMaster()));
-}
-
-void PlayerbotShamanAI::UseCooldowns()
-{
-    if (!m_ai)  return;
-    if (!m_bot) return;
-
-    uint32 spec = m_bot->GetSpec();
-
-    if (BLOODLUST > 0 && (!GetMaster()->HasAura(BLOODLUST, EFFECT_INDEX_0)) && m_ai->CastSpell(BLOODLUST))
-        return;
-
-    switch (spec)
-    {
-        case SHAMAN_SPEC_ENHANCEMENT:
-            if (SHAMANISTIC_RAGE > 0 && m_ai->CastSpell(SHAMANISTIC_RAGE, *m_bot))
-                return;
-            break;
-
-        case SHAMAN_SPEC_ELEMENTAL:
-            break;
-
-        case SHAMAN_SPEC_RESTORATION:
-            if (MANA_TIDE_TOTEM > 0 && m_ai->GetManaPercent() < 50 && m_ai->CastSpell(MANA_TIDE_TOTEM))
-                return;
-
-        default:
-            break;
-    }
-}
-
-void PlayerbotShamanAI::DoNonCombatActions()
-{
-    if (!m_ai)   return;
-    if (!m_bot)  return;
-
-    if (!m_bot->isAlive() || m_bot->IsInDuel()) return;
-
-    uint32 spec = m_bot->GetSpec();
-
-    CheckShields();
-    /*
-           // buff myself weapon
-           if (ROCKBITER_WEAPON > 0)
-                (!m_bot->HasAura(ROCKBITER_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(WINDFURY_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(FLAMETONGUE_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(FROSTBRAND_WEAPON, EFFECT_INDEX_0) && m_ai->CastSpell(ROCKBITER_WEAPON,*m_bot) );
-           else if (WINDFURY_WEAPON > 0)
-                (!m_bot->HasAura(WINDFURY_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(FLAMETONGUE_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(FROSTBRAND_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(ROCKBITER_WEAPON, EFFECT_INDEX_0) && m_ai->CastSpell(WINDFURY_WEAPON,*m_bot) );
-           else if (FLAMETONGUE_WEAPON > 0)
-                (!m_bot->HasAura(FLAMETONGUE_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(WINDFURY_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(FROSTBRAND_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(ROCKBITER_WEAPON, EFFECT_INDEX_0) && m_ai->CastSpell(FLAMETONGUE_WEAPON,*m_bot) );
-           else if (FROSTBRAND_WEAPON > 0)
-                (!m_bot->HasAura(FROSTBRAND_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(WINDFURY_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(FLAMETONGUE_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(ROCKBITER_WEAPON, EFFECT_INDEX_0) && m_ai->CastSpell(FROSTBRAND_WEAPON,*m_bot) );
-     */
-    // Mainhand
-    Item* weapon;
-    weapon = m_bot->GetItemByPos(EQUIPMENT_SLOT_MAINHAND);
-    if (weapon && (weapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT) == 0) && spec == SHAMAN_SPEC_ELEMENTAL)
-        m_ai->CastSpell(FLAMETONGUE_WEAPON, *m_bot);
-    else if (weapon && (weapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT) == 0) && spec == SHAMAN_SPEC_ENHANCEMENT)
-        m_ai->CastSpell(WINDFURY_WEAPON, *m_bot);
-
-    //Offhand
-    weapon = m_bot->GetItemByPos(EQUIPMENT_SLOT_OFFHAND);
-    if (weapon && (weapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT) == 0) && spec == SHAMAN_SPEC_ENHANCEMENT)
-        m_ai->CastSpell(FLAMETONGUE_WEAPON, *m_bot);
-
-    // Revive
-    if (HealPlayer(GetResurrectionTarget()) & RETURN_CONTINUE)
-        return;
-
-    // Heal
-    if (m_ai->IsHealer())
-    {
-        if (HealPlayer(GetHealTarget()) & RETURN_CONTINUE)
-            return;// RETURN_CONTINUE;
-    }
-    else
-    {
-        // Is this desirable? Debatable.
-        // TODO: In a group/raid with a healer you'd want this bot to focus on DPS (it's not specced/geared for healing either)
-        if (HealPlayer(m_bot) & RETURN_CONTINUE)
-            return;// RETURN_CONTINUE;
-    }
-
-    // hp/mana check
-    if (EatDrinkBandage())
-        return;
-} // end DoNonCombatActions
-
-bool PlayerbotShamanAI::CastHoTOnTank()
-{
-    if (!m_ai) return false;
-
-    if ((PlayerbotAI::ORDERS_HEAL & m_ai->GetCombatOrder()) == 0) return false;
-
-    // Shaman: Healing Stream Totem, Earthliving Weapon
-    // None of these are cast before Pulling
-
-    return false;
-}
diff --git a/src/game/PlayerBot/AI/PlayerbotShamanAI.h b/src/game/PlayerBot/AI/PlayerbotShamanAI.h
deleted file mode 100644
index 7ed892f16..000000000
--- a/src/game/PlayerBot/AI/PlayerbotShamanAI.h
+++ /dev/null
@@ -1,223 +0,0 @@
-/*
- * This file is part of the CMaNGOS Project. See AUTHORS file for Copyright information
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _PLAYERBOTSHAMANAI_H
-#define _PLAYERBOTSHAMANAI_H
-
-#include "../Base/PlayerbotClassAI.h"
-
-enum
-{
-    SPELL_ENHANCEMENT,
-    SPELL_RESTORATION,
-    SPELL_ELEMENTAL
-};
-
-enum
-{
-    ANCESTRAL_SPIRIT_1              = 2008,
-    ASTRAL_RECALL_1                 = 556,
-    BLOODLUST_1                     = 2825,
-    CHAIN_HEAL_1                    = 1064,
-    CHAIN_LIGHTNING_1               = 421,
-    CLEANSING_TOTEM_1               = 8170,
-    CURE_POISON_SHAMAN_1            = 526,
-    CURE_DISEASE_SHAMAN_1           = 2870,
-    EARTH_ELEMENTAL_TOTEM_1         = 2062,
-    EARTH_SHIELD_1                  = 974,
-    EARTH_SHOCK_1                   = 8042,
-    EARTHBIND_TOTEM_1               = 2484,
-    ELEMENTAL_MASTERY_1             = 16166,
-    FIRE_ELEMENTAL_TOTEM_1          = 2894,
-    FIRE_NOVA_1                     = 1535,
-    FIRE_RESISTANCE_TOTEM_1         = 8184,
-    FLAME_SHOCK_1                   = 8050,
-    FLAMETONGUE_TOTEM_1             = 8227,
-    FLAMETONGUE_WEAPON_1            = 8024,
-    FROST_RESISTANCE_TOTEM_1        = 8181,
-    FROST_SHOCK_1                   = 8056,
-    FROSTBRAND_WEAPON_1             = 8033,
-    GHOST_WOLF_1                    = 2645,
-    GROUNDING_TOTEM_1               = 8177,
-    HEALING_STREAM_TOTEM_1          = 5394,
-    HEALING_WAVE_1                  = 331,
-    HEROISM_1                       = 32182,
-    LESSER_HEALING_WAVE_1           = 8004,
-    LIGHTNING_BOLT_1                = 403,
-    LIGHTNING_SHIELD_1              = 324,
-    MAGMA_TOTEM_1                   = 8190,
-    MANA_SPRING_TOTEM_1             = 5675,
-    MANA_TIDE_TOTEM_1               = 16190,
-    NATURE_RESISTANCE_TOTEM_1       = 10595,
-    PURGE_1                         = 370,
-    ROCKBITER_WEAPON_1              = 8017,
-    SEARING_TOTEM_1                 = 3599,
-    SENTRY_TOTEM_1                  = 6495,
-    SHAMANISTIC_RAGE_1              = 30823,
-    STONECLAW_TOTEM_1               = 5730,
-    STONESKIN_TOTEM_1               = 8071,
-    STORMSTRIKE_1                   = 17364,
-    STRENGTH_OF_EARTH_TOTEM_1       = 8075,
-    TOTEM_OF_WRATH_1                = 30706,
-    TOTEMIC_RECALL_1                = 36936,
-    TREMOR_TOTEM_1                  = 8143,
-    WATER_BREATHING_1               = 131,
-    WATER_WALKING_1                 = 546,
-    WINDFURY_TOTEM_1                = 8512,
-    WINDFURY_WEAPON_1               = 8232,
-    WRATH_OF_AIR_TOTEM_1            = 3738,
-
-    //Totem Buffs
-    STRENGTH_OF_EARTH_EFFECT_1      = 8076,
-    FLAMETONGUE_EFFECT_1            = 8026,
-    MAGMA_TOTEM_EFFECT_1            = 8188,
-    STONECLAW_EFFECT_1              = 5728,
-    FIRE_RESISTANCE_EFFECT_1        = 8185,
-    FROST_RESISTANCE_EFFECT_1       = 8182,
-    GROUDNING_EFFECT_1              = 8178,
-    NATURE_RESISTANCE_EFFECT_1      = 10596,
-    STONESKIN_EFFECT_1              = 8072,
-    WINDFURY_EFFECT_1               = 8515,
-    WRATH_OF_AIR_EFFECT_1           = 2895,
-    CLEANSING_TOTEM_EFFECT_1        = 8172,
-    MANA_SPRING_EFFECT_1            = 5677,
-    TREMOR_TOTEM_EFFECT_1           = 8145,
-    EARTHBIND_EFFECT_1              = 6474,
-    // FIRE_ELEMENTAL_TOTEM uses spell effect index 2
-    // SEARING_TOTEM uses spell effect index 0
-    // EARTH_ELEMENTAL_TOTEM uses spell effect indexes 1 and 2
-
-};
-//class Player;
-
-class PlayerbotShamanAI : PlayerbotClassAI
-{
-    public:
-        PlayerbotShamanAI(Player* const master, Player* const bot, PlayerbotAI* const ai);
-        virtual ~PlayerbotShamanAI();
-
-        // all combat actions go here
-        CombatManeuverReturns DoFirstCombatManeuver(Unit* pTarget);
-        CombatManeuverReturns DoNextCombatManeuver(Unit* pTarget);
-
-        // all non combat actions go here, ex buffs, heals, rezzes
-        void DoNonCombatActions();
-
-        // Utility Functions
-        bool CastHoTOnTank();
-
-    private:
-        CombatManeuverReturns DoFirstCombatManeuverPVE(Unit* pTarget);
-        CombatManeuverReturns DoNextCombatManeuverPVE(Unit* pTarget);
-        CombatManeuverReturns DoFirstCombatManeuverPVP(Unit* pTarget);
-        CombatManeuverReturns DoNextCombatManeuverPVP(Unit* pTarget);
-
-        // Heals the target based off its hps
-        CombatManeuverReturns HealPlayer(Player* target);
-        Player* GetHealTarget() { return PlayerbotClassAI::GetHealTarget(); }
-        void DropTotems();
-        void CheckShields();
-        void UseCooldowns();
-
-        // ENHANCEMENT
-        uint32 ROCKBITER_WEAPON,
-               STONESKIN_TOTEM,
-               LIGHTNING_SHIELD,
-               FLAMETONGUE_WEAPON,
-               STRENGTH_OF_EARTH_TOTEM,
-               FOCUSED,
-               FROSTBRAND_WEAPON,
-               FROST_RESISTANCE_TOTEM,
-               FLAMETONGUE_TOTEM,
-               FIRE_RESISTANCE_TOTEM,
-               WINDFURY_WEAPON,
-               GROUNDING_TOTEM,
-               NATURE_RESISTANCE_TOTEM,
-               WIND_FURY_TOTEM,
-               STORMSTRIKE,
-               SHAMANISTIC_RAGE,
-               WRATH_OF_AIR_TOTEM,
-               EARTH_ELEMENTAL_TOTEM,
-               BLOODLUST,
-               HEROISM;
-
-        // RESTORATION
-        uint32 HEALING_WAVE,
-               LESSER_HEALING_WAVE,
-               ANCESTRAL_SPIRIT,
-               TREMOR_TOTEM,
-               HEALING_STREAM_TOTEM,
-               MANA_SPRING_TOTEM,
-               CHAIN_HEAL,
-               MANA_TIDE_TOTEM,
-               EARTH_SHIELD,
-               CURE_DISEASE_SHAMAN,
-               CURE_POISON_SHAMAN;
-
-        // ELEMENTAL
-        uint32 LIGHTNING_BOLT,
-               EARTH_SHOCK,
-               STONECLAW_TOTEM,
-               FLAME_SHOCK,
-               SEARING_TOTEM,
-               PURGE,
-               FIRE_NOVA_TOTEM,
-               WIND_SHOCK,
-               FROST_SHOCK,
-               MAGMA_TOTEM,
-               CHAIN_LIGHTNING,
-               TOTEM_OF_WRATH,
-               FIRE_ELEMENTAL_TOTEM,
-               EARTHBIND_TOTEM,
-               ELEMENTAL_MASTERY;
-
-        // racial
-        uint32 ARCANE_TORRENT,
-               GIFT_OF_THE_NAARU,
-               STONEFORM,
-               ESCAPE_ARTIST,
-               PERCEPTION,
-               SHADOWMELD,
-               BLOOD_FURY,
-               WAR_STOMP,
-               BERSERKING,
-               WILL_OF_THE_FORSAKEN;
-
-        // totem buffs
-        uint32 STRENGTH_OF_EARTH_EFFECT,
-               FLAMETONGUE_EFFECT,
-               MAGMA_TOTEM_EFFECT,
-               STONECLAW_EFFECT,
-               FIRE_RESISTANCE_EFFECT,
-               FROST_RESISTANCE_EFFECT,
-               GROUDNING_EFFECT,
-               NATURE_RESISTANCE_EFFECT,
-               STONESKIN_EFFECT,
-               WINDFURY_EFFECT,
-               WRATH_OF_AIR_EFFECT,
-               CLEANSING_TOTEM_EFFECT,
-               HEALING_STREAM_EFFECT,
-               MANA_SPRING_EFFECT,
-               TREMOR_TOTEM_EFFECT,
-               TOTEM_OF_WRATH_EFFECT,
-               EARTHBIND_EFFECT;
-
-        uint32 SpellSequence, LastSpellEnhancement, LastSpellRestoration, LastSpellElemental;
-};
-
-#endif
diff --git a/src/game/PlayerBot/AI/PlayerbotWarlockAI.cpp b/src/game/PlayerBot/AI/PlayerbotWarlockAI.cpp
deleted file mode 100644
index 2c0e661be..000000000
--- a/src/game/PlayerBot/AI/PlayerbotWarlockAI.cpp
+++ /dev/null
@@ -1,781 +0,0 @@
-/*
- * This file is part of the CMaNGOS Project. See AUTHORS file for Copyright information
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "PlayerbotWarlockAI.h"
-
-class PlayerbotAI;
-PlayerbotWarlockAI::PlayerbotWarlockAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
-{
-    // DESTRUCTION
-    SHADOW_BOLT           = m_ai->initSpell(SHADOW_BOLT_1);
-    IMMOLATE              = m_ai->initSpell(IMMOLATE_1);
-    INCINERATE            = m_ai->initSpell(INCINERATE_1);
-    SEARING_PAIN          = m_ai->initSpell(SEARING_PAIN_1);
-    CONFLAGRATE           = m_ai->initSpell(CONFLAGRATE_1);
-    SHADOWFURY            = m_ai->initSpell(SHADOWFURY_1);
-    HELLFIRE              = m_ai->initSpell(HELLFIRE_1);
-    RAIN_OF_FIRE          = m_ai->initSpell(RAIN_OF_FIRE_1);
-    SOUL_FIRE             = m_ai->initSpell(SOUL_FIRE_1); // soul shard spells
-    SHADOWBURN            = m_ai->initSpell(SHADOWBURN_1);
-    // CURSE
-    CURSE_OF_WEAKNESS     = m_ai->initSpell(CURSE_OF_WEAKNESS_1);
-    CURSE_OF_THE_ELEMENTS = m_ai->initSpell(CURSE_OF_THE_ELEMENTS_1);
-    CURSE_OF_AGONY        = m_ai->initSpell(CURSE_OF_AGONY_1);
-    CURSE_OF_EXHAUSTION   = m_ai->initSpell(CURSE_OF_EXHAUSTION_1);
-    CURSE_OF_RECKLESSNESS = m_ai->initSpell(CURSE_OF_RECKLESSNESS_1);
-    CURSE_OF_SHADOW       = m_ai->initSpell(CURSE_OF_SHADOW_1);
-    CURSE_OF_TONGUES      = m_ai->initSpell(CURSE_OF_TONGUES_1);
-    CURSE_OF_DOOM         = m_ai->initSpell(CURSE_OF_DOOM_1);
-    // AFFLICTION
-    AMPLIFY_CURSE         = m_ai->initSpell(AMPLIFY_CURSE_1);
-    CORRUPTION            = m_ai->initSpell(CORRUPTION_1);
-    DRAIN_SOUL            = m_ai->initSpell(DRAIN_SOUL_1);
-    DRAIN_LIFE            = m_ai->initSpell(DRAIN_LIFE_1);
-    DRAIN_MANA            = m_ai->initSpell(DRAIN_MANA_1);
-    LIFE_TAP              = m_ai->initSpell(LIFE_TAP_1);
-    UNSTABLE_AFFLICTION   = m_ai->initSpell(UNSTABLE_AFFLICTION_1);
-    SEED_OF_CORRUPTION    = m_ai->initSpell(SEED_OF_CORRUPTION_1);
-    DARK_PACT             = m_ai->initSpell(DARK_PACT_1);
-    HOWL_OF_TERROR        = m_ai->initSpell(HOWL_OF_TERROR_1);
-    FEAR                  = m_ai->initSpell(FEAR_1);
-    SIPHON_LIFE           = m_ai->initSpell(SIPHON_LIFE_1);
-    // DEMONOLOGY
-    BANISH                = m_ai->initSpell(BANISH_1);
-    ENSLAVE_DEMON         = m_ai->initSpell(ENSLAVE_DEMON_1);
-    DEMON_SKIN            = m_ai->initSpell(DEMON_SKIN_1);
-    DEMON_ARMOR           = m_ai->initSpell(DEMON_ARMOR_1);
-    FEL_ARMOR             = m_ai->initSpell(FEL_ARMOR_1);
-    SHADOW_WARD           = m_ai->initSpell(SHADOW_WARD_1);
-    SOULSHATTER           = m_ai->initSpell(SOULSHATTER_1);
-    SOUL_LINK             = m_ai->initSpell(SOUL_LINK_1);
-    SOUL_LINK_AURA        = 25228; // dummy aura applied, after spell SOUL_LINK
-    HEALTH_FUNNEL         = m_ai->initSpell(HEALTH_FUNNEL_1);
-    DETECT_INVISIBILITY   = m_ai->initSpell(DETECT_INVISIBILITY_1);
-    CREATE_FIRESTONE      = m_ai->initSpell(CREATE_FIRESTONE_1);
-    CREATE_HEALTHSTONE    = m_ai->initSpell(CREATE_HEALTHSTONE_1);
-    CREATE_SOULSTONE      = m_ai->initSpell(CREATE_SOULSTONE_1);
-    CREATE_SPELLSTONE     = m_ai->initSpell(CREATE_SPELLSTONE_1);
-    // demon summon
-    SUMMON_IMP            = m_ai->initSpell(SUMMON_IMP_1);
-    SUMMON_VOIDWALKER     = m_ai->initSpell(SUMMON_VOIDWALKER_1);
-    SUMMON_SUCCUBUS       = m_ai->initSpell(SUMMON_SUCCUBUS_1);
-    SUMMON_FELHUNTER      = m_ai->initSpell(SUMMON_FELHUNTER_1);
-    SUMMON_FELGUARD       = m_ai->initSpell(SUMMON_FELGUARD_1);
-    // demon skills should be initialized on demons
-    BLOOD_PACT            = 0; // imp skill
-    CONSUME_SHADOWS       = 0; // voidwalker skill
-    FEL_INTELLIGENCE      = 0; // felhunter skill
-    // RANGED COMBAT
-    SHOOT                 = m_ai->initSpell(SHOOT_3);
-
-    RECENTLY_BANDAGED     = 11196; // first aid check
-
-    // racial
-    ARCANE_TORRENT        = m_ai->initSpell(ARCANE_TORRENT_MANA_CLASSES); // blood elf
-    ESCAPE_ARTIST         = m_ai->initSpell(ESCAPE_ARTIST_ALL); // gnome
-    PERCEPTION            = m_ai->initSpell(PERCEPTION_ALL); // human
-    BLOOD_FURY            = m_ai->initSpell(BLOOD_FURY_WARLOCK); // orc
-    WILL_OF_THE_FORSAKEN  = m_ai->initSpell(WILL_OF_THE_FORSAKEN_ALL); // undead
-
-    m_lastDemon           = 0;
-    m_isTempImp           = false;
-    m_CurrentCurse        = 0;
-}
-
-PlayerbotWarlockAI::~PlayerbotWarlockAI() {}
-
-CombatManeuverReturns PlayerbotWarlockAI::DoFirstCombatManeuver(Unit* pTarget)
-{
-    // There are NPCs in BGs and Open World PvP, so don't filter this on PvP scenarios (of course if PvP targets anyone but tank, all bets are off anyway)
-    // Wait until the tank says so, until any non-tank gains aggro or X seconds - whichever is shortest
-    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO)
-    {
-        if (m_WaitUntil > m_ai->CurrentTime() && m_ai->GroupTankHoldsAggro())
-        {
-            return RETURN_NO_ACTION_OK; // wait it out
-        }
-        else
-        {
-            m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO);
-        }
-    }
-
-    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TEMP_WAIT_OOC)
-    {
-        if (m_WaitUntil > m_ai->CurrentTime() && m_ai->IsGroupReady())
-            return RETURN_NO_ACTION_OK; // wait it out
-        else
-            m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_OOC);
-    }
-
-    switch (m_ai->GetScenarioType())
-    {
-        case PlayerbotAI::SCENARIO_PVP_DUEL:
-        case PlayerbotAI::SCENARIO_PVP_BG:
-        case PlayerbotAI::SCENARIO_PVP_ARENA:
-        case PlayerbotAI::SCENARIO_PVP_OPENWORLD:
-            return DoFirstCombatManeuverPVP(pTarget);
-        case PlayerbotAI::SCENARIO_PVE:
-        case PlayerbotAI::SCENARIO_PVE_ELITE:
-        case PlayerbotAI::SCENARIO_PVE_RAID:
-        default:
-            return DoFirstCombatManeuverPVE(pTarget);
-            break;
-    }
-
-    return RETURN_NO_ACTION_ERROR;
-}
-
-CombatManeuverReturns PlayerbotWarlockAI::DoFirstCombatManeuverPVE(Unit* /*pTarget*/)
-{
-    m_CurrentCurse = 0;
-    return RETURN_NO_ACTION_OK;
-}
-
-CombatManeuverReturns PlayerbotWarlockAI::DoFirstCombatManeuverPVP(Unit* /*pTarget*/)
-{
-    return RETURN_NO_ACTION_OK;
-}
-
-CombatManeuverReturns PlayerbotWarlockAI::DoNextCombatManeuver(Unit* pTarget)
-{
-    // Face enemy, make sure bot is attacking
-    m_ai->FaceTarget(pTarget);
-
-    switch (m_ai->GetScenarioType())
-    {
-        case PlayerbotAI::SCENARIO_PVP_DUEL:
-        case PlayerbotAI::SCENARIO_PVP_BG:
-        case PlayerbotAI::SCENARIO_PVP_ARENA:
-        case PlayerbotAI::SCENARIO_PVP_OPENWORLD:
-            return DoNextCombatManeuverPVP(pTarget);
-        case PlayerbotAI::SCENARIO_PVE:
-        case PlayerbotAI::SCENARIO_PVE_ELITE:
-        case PlayerbotAI::SCENARIO_PVE_RAID:
-        default:
-            return DoNextCombatManeuverPVE(pTarget);
-            break;
-    }
-
-    return RETURN_NO_ACTION_ERROR;
-}
-
-CombatManeuverReturns PlayerbotWarlockAI::DoNextCombatManeuverPVE(Unit* pTarget)
-{
-    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
-    if (!m_bot) return RETURN_NO_ACTION_ERROR;
-
-    //Unit* pVictim = pTarget->getVictim();
-    bool meleeReach = m_bot->CanReachWithMeleeAttack(pTarget);
-    Pet* pet = m_bot->GetPet();
-    uint32 spec = m_bot->GetSpec();
-    uint8 shardCount = m_bot->GetItemCount(SOUL_SHARD, false, nullptr);
-
-    //If we have UA it will replace immolate in our rotation
-    uint32 FIRE = (UNSTABLE_AFFLICTION > 0 ? UNSTABLE_AFFLICTION : IMMOLATE);
-
-    // Voidwalker is near death - sacrifice it for a shield
-    if (pet && pet->GetEntry() == DEMON_VOIDWALKER && SACRIFICE && !m_bot->HasAura(SACRIFICE) && pet->GetHealthPercent() < 10)
-        m_ai->CastPetSpell(SACRIFICE);
-
-    // Use healthstone
-    if (m_ai->GetHealthPercent() < 30)
-    {
-        Item* healthStone = m_ai->FindConsumable(HEALTHSTONE_DISPLAYID);
-        if (healthStone)
-            m_ai->UseItem(healthStone);
-    }
-
-    // Voidwalker sacrifice gives shield - but you lose the pet (and it's DPS/tank) - use only as last resort for your own health!
-    if (m_ai->GetHealthPercent() < 20 && pet && pet->GetEntry() == DEMON_VOIDWALKER && SACRIFICE && !m_bot->HasAura(SACRIFICE))
-        m_ai->CastPetSpell(SACRIFICE);
-
-    if (m_ai->GetCombatStyle() != PlayerbotAI::COMBAT_RANGED && !meleeReach)
-        m_ai->SetCombatStyle(PlayerbotAI::COMBAT_RANGED);
-    // switch to melee if in melee range AND can't shoot OR have no ranged (wand) equipped
-    else if (m_ai->GetCombatStyle() != PlayerbotAI::COMBAT_MELEE
-             && meleeReach
-             && (SHOOT == 0 || !m_bot->GetWeaponForAttack(RANGED_ATTACK, true, true)))
-        m_ai->SetCombatStyle(PlayerbotAI::COMBAT_MELEE);
-
-    //Used to determine if this bot is highest on threat
-    Unit* newTarget = m_ai->FindAttacker((PlayerbotAI::ATTACKERINFOTYPE)(PlayerbotAI::AIT_VICTIMSELF | PlayerbotAI::AIT_HIGHESTTHREAT), m_bot);
-    if (newTarget && !m_ai->IsNeutralized(newTarget)) // TODO: && party has a tank
-    {
-        if (SOULSHATTER > 0 && shardCount > 0 && m_bot->IsSpellReady(SOULSHATTER))
-            if (CastSpell(SOULSHATTER, m_bot))
-                return RETURN_CONTINUE;
-
-        // Have threat, can't quickly lower it. 3 options remain: Stop attacking, lowlevel damage (wand), keep on keeping on.
-        if (newTarget->GetHealthPercent() > 25)
-        {
-            // If elite
-            if (m_ai->IsElite(newTarget))
-            {
-                // let warlock pet handle it to win some time
-                Creature* pCreature = (Creature*) newTarget;
-                if (pet)
-                {
-                    switch (pet->GetEntry())
-                    {
-                        // taunt the elite and tank it
-                        case DEMON_VOIDWALKER:
-                            if (TORMENT && m_ai->CastPetSpell(TORMENT, newTarget))
-                                return RETURN_NO_ACTION_OK;
-                        // maybe give it some love?
-                        case DEMON_SUCCUBUS:
-                            if (pCreature && pCreature->GetCreatureInfo()->CreatureType == CREATURE_TYPE_HUMANOID)
-                                if (SEDUCTION && !newTarget->HasAura(SEDUCTION) && m_ai->CastPetSpell(SEDUCTION, newTarget))
-                                    return RETURN_NO_ACTION_OK;
-                    }
-
-                }
-                // if aggroed mob is a demon or an elemental: banish it
-                if (pCreature && (pCreature->GetCreatureInfo()->CreatureType == CREATURE_TYPE_DEMON || pCreature->GetCreatureInfo()->CreatureType == CREATURE_TYPE_ELEMENTAL))
-                {
-                    if (BANISH && !newTarget->HasAura(BANISH) && CastSpell(BANISH, newTarget))
-                        return RETURN_CONTINUE;
-                }
-
-                return RETURN_NO_ACTION_OK; // do nothing and pray tank gets aggro off you
-            }
-
-            // Not an elite. You could insert FEAR here but in any PvE situation that's 90-95% likely
-            // to worsen the situation for the group. ... So please don't.
-            return CastSpell(SHOOT, pTarget);
-        }
-    }
-
-    // Create soul shard (only on non-worldboss)
-    uint8 freeSpace = m_ai->GetFreeBagSpace();
-    uint8 HPThreshold = (m_ai->IsElite(pTarget) ? 10 : 25);
-    if (!m_ai->IsElite(pTarget, true) && pTarget->GetHealthPercent() < HPThreshold && (shardCount < MAX_SHARD_COUNT && freeSpace > 0))
-    {
-        if (SHADOWBURN && m_ai->In_Reach(pTarget, SHADOWBURN) && !pTarget->HasAura(SHADOWBURN) && m_bot->IsSpellReady(SHADOWBURN) && CastSpell(SHADOWBURN, pTarget))
-            return RETURN_CONTINUE;
-
-        // Do not cast Drain Soul if Shadowburn is active on target
-        if (DRAIN_SOUL && m_ai->In_Reach(pTarget, DRAIN_SOUL) && !pTarget->HasAura(DRAIN_SOUL) && !pTarget->HasAura(SHADOWBURN) && CastSpell(DRAIN_SOUL, pTarget))
-        {
-            m_ai->SetIgnoreUpdateTime(15);
-            return RETURN_CONTINUE;
-        }
-    }
-
-    if (pet && DARK_PACT && (100 * pet->GetPower(POWER_MANA) / pet->GetMaxPower(POWER_MANA)) > 10 && m_ai->GetManaPercent() <= 20)
-        if (m_ai->CastSpell(DARK_PACT, *m_bot))
-            return RETURN_CONTINUE;
-
-    // Mana check and replenishment
-    if (LIFE_TAP && m_ai->GetManaPercent() <= 20 && m_ai->GetHealthPercent() > 50)
-        if (m_ai->CastSpell(LIFE_TAP, *m_bot))
-            return RETURN_CONTINUE;
-
-    // HP, mana and aggro checks done
-    // Curse the target
-    if (CheckCurse(pTarget))
-        return RETURN_CONTINUE;
-
-    // Damage Spells
-    if (spec)
-    {
-        switch (spec)
-        {
-            case WARLOCK_SPEC_AFFLICTION:
-                if (CORRUPTION && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_SHADOW) && m_ai->In_Reach(pTarget, CORRUPTION) && !pTarget->HasAura(CORRUPTION) && CastSpell(CORRUPTION, pTarget))
-                    return RETURN_CONTINUE;
-                if (FIRE && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_FIRE) && m_ai->In_Reach(pTarget, FIRE) && !pTarget->HasAura(FIRE) && CastSpell(FIRE, pTarget))
-                    return RETURN_CONTINUE;
-                if (SIPHON_LIFE > 0 && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_SHADOW) && m_ai->In_Reach(pTarget, SIPHON_LIFE) && !pTarget->HasAura(SIPHON_LIFE) && CastSpell(SIPHON_LIFE, pTarget))
-                    return RETURN_CONTINUE;
-                if (SHADOW_BOLT && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_SHADOW) && m_ai->In_Reach(pTarget, SHADOW_BOLT) && CastSpell(SHADOW_BOLT, pTarget))
-                    return RETURN_CONTINUE;
-                break;
-
-            case WARLOCK_SPEC_DEMONOLOGY:
-                if (pet && DEMONIC_EMPOWERMENT && m_bot->IsSpellReady(DEMONIC_EMPOWERMENT) && CastSpell(DEMONIC_EMPOWERMENT))
-                    return RETURN_CONTINUE;
-                if (CORRUPTION && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_SHADOW) && m_ai->In_Reach(pTarget, CORRUPTION) && !pTarget->HasAura(CORRUPTION) && CastSpell(CORRUPTION, pTarget))
-                    return RETURN_CONTINUE;
-                if (FIRE && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_FIRE) && m_ai->In_Reach(pTarget, FIRE) && !pTarget->HasAura(FIRE) && CastSpell(FIRE, pTarget))
-                    return RETURN_CONTINUE;
-                if (INCINERATE && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_FIRE) && m_ai->In_Reach(pTarget, INCINERATE) && pTarget->HasAura(FIRE) && CastSpell(INCINERATE, pTarget))
-                    return RETURN_CONTINUE;
-                if (SHADOW_BOLT && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_SHADOW) && m_ai->In_Reach(pTarget, SHADOW_BOLT) && CastSpell(SHADOW_BOLT, pTarget))
-                    return RETURN_CONTINUE;
-                break;
-
-            case WARLOCK_SPEC_DESTRUCTION:
-                if (SHADOWBURN && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_SHADOW) && pTarget->GetHealthPercent() < (HPThreshold / 2.0) && m_ai->In_Reach(pTarget, SHADOWBURN) && !pTarget->HasAura(SHADOWBURN) && CastSpell(SHADOWBURN, pTarget))
-                    return RETURN_CONTINUE;
-                if (CORRUPTION && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_SHADOW) && m_ai->In_Reach(pTarget, CORRUPTION) && !pTarget->HasAura(CORRUPTION) && CastSpell(CORRUPTION, pTarget))
-                    return RETURN_CONTINUE;
-                if (FIRE && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_FIRE) && m_ai->In_Reach(pTarget, FIRE) && !pTarget->HasAura(FIRE) && CastSpell(FIRE, pTarget))
-                    return RETURN_CONTINUE;
-                if (CONFLAGRATE && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_FIRE) && m_ai->In_Reach(pTarget, CONFLAGRATE) && pTarget->HasAura(FIRE) && m_bot->IsSpellReady(CONFLAGRATE) && CastSpell(CONFLAGRATE, pTarget))
-                    return RETURN_CONTINUE;
-                if (INCINERATE && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_FIRE) && m_ai->In_Reach(pTarget, INCINERATE) && pTarget->HasAura(FIRE) && CastSpell(INCINERATE, pTarget))
-                    return RETURN_CONTINUE;
-                if (SHADOW_BOLT && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_SHADOW) && m_ai->In_Reach(pTarget, SHADOW_BOLT) && CastSpell(SHADOW_BOLT, pTarget))
-                    return RETURN_CONTINUE;
-                break;
-        }
-
-        // Shadow bolt is common to all specs
-        if (SHADOW_BOLT && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_SHADOW) && m_ai->In_Reach(pTarget, SHADOW_BOLT) && CastSpell(SHADOW_BOLT, pTarget))
-            return RETURN_CONTINUE;
-
-        // Default: shoot with wand
-        return CastSpell(SHOOT, pTarget);
-
-        return RETURN_NO_ACTION_OK;
-
-        //if (DRAIN_LIFE && LastSpellAffliction < 4 && !pTarget->HasAura(DRAIN_SOUL) && !pTarget->HasAura(DRAIN_LIFE) && !pTarget->HasAura(DRAIN_MANA) && m_ai->GetHealthPercent() <= 70)
-        //    m_ai->CastSpell(DRAIN_LIFE, *pTarget);
-        //    //m_ai->SetIgnoreUpdateTime(5);
-        //else if (SEED_OF_CORRUPTION && !pTarget->HasAura(SEED_OF_CORRUPTION) && LastSpellAffliction < 7)
-        //    m_ai->CastSpell(SEED_OF_CORRUPTION, *pTarget);
-        //else if (HOWL_OF_TERROR && !pTarget->HasAura(HOWL_OF_TERROR) && m_ai->GetAttackerCount() > 3 && LastSpellAffliction < 8)
-        //    m_ai->CastSpell(HOWL_OF_TERROR, *pTarget);
-        //    m_ai->TellMaster("casting howl of terror!");
-        //else if (FEAR && !pTarget->HasAura(FEAR) && pVictim == m_bot && m_ai->GetAttackerCount() >= 2 && LastSpellAffliction < 9)
-        //    m_ai->CastSpell(FEAR, *pTarget);
-        //    //m_ai->TellMaster("casting fear!");
-        //    //m_ai->SetIgnoreUpdateTime(1.5);
-        //if (SHADOWFURY && LastSpellDestruction < 1 && !pTarget->HasAura(SHADOWFURY))
-        //    m_ai->CastSpell(SHADOWFURY, *pTarget);
-        //else if (RAIN_OF_FIRE && LastSpellDestruction < 3 && m_ai->GetAttackerCount() >= 3)
-        //    m_ai->CastSpell(RAIN_OF_FIRE, *pTarget);
-        //    //m_ai->TellMaster("casting rain of fire!");
-        //    //m_ai->SetIgnoreUpdateTime(8);
-        //else if (SEARING_PAIN && LastSpellDestruction < 8)
-        //    m_ai->CastSpell(SEARING_PAIN, *pTarget);
-        //else if (SOUL_FIRE && LastSpellDestruction < 9)
-        //    m_ai->CastSpell(SOUL_FIRE, *pTarget);
-        //    //m_ai->SetIgnoreUpdateTime(6);
-        //else if (HELLFIRE && LastSpellDestruction < 12 && !m_bot->HasAura(HELLFIRE) && m_ai->GetAttackerCount() >= 5 && m_ai->GetHealthPercent() >= 50)
-        //    m_ai->CastSpell(HELLFIRE);
-        //    m_ai->TellMaster("casting hellfire!");
-        //    //m_ai->SetIgnoreUpdateTime(15);
-    }
-
-    // No spec due to low level OR no spell found yet
-    if (CORRUPTION && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_SHADOW) && m_ai->In_Reach(pTarget, CORRUPTION) && !pTarget->HasAura(CORRUPTION) && CastSpell(CORRUPTION, pTarget))
-        return RETURN_CONTINUE;
-    if (FIRE && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_FIRE) && m_ai->In_Reach(pTarget, FIRE) && !pTarget->HasAura(FIRE) && CastSpell(FIRE, pTarget))
-        return RETURN_CONTINUE;
-    if (SHADOW_BOLT && !m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_SHADOW) && m_ai->In_Reach(pTarget, SHADOW_BOLT))
-        return CastSpell(SHADOW_BOLT, pTarget);
-
-    // Default: shoot with wand
-    return CastSpell(SHOOT, pTarget);
-
-    return RETURN_NO_ACTION_OK;
-} // end DoNextCombatManeuver
-
-CombatManeuverReturns PlayerbotWarlockAI::DoNextCombatManeuverPVP(Unit* pTarget)
-{
-    if (FEAR && m_ai->In_Reach(pTarget, FEAR) && m_ai->CastSpell(FEAR, *pTarget))
-        return RETURN_CONTINUE;
-    if (SHADOW_BOLT && m_ai->In_Reach(pTarget, SHADOW_BOLT) && m_ai->CastSpell(SHADOW_BOLT))
-        return RETURN_CONTINUE;
-
-    return DoNextCombatManeuverPVE(pTarget); // TODO: bad idea perhaps, but better than the alternative
-}
-
-// Decision tree for putting a curse on the current target
-bool PlayerbotWarlockAI::CheckCurse(Unit* pTarget)
-{
-    // Target is immune to shadow, no need to apply a curse
-    if (m_ai->IsImmuneToSchool(pTarget, SPELL_SCHOOL_MASK_SHADOW))
-        return false;
-
-    Creature* pCreature = (Creature*) pTarget;
-    uint32 CurseToCast = 0;
-
-    // Prevent low health humanoid from fleeing or fleeing too fast
-    // Curse of Exhaustion first to avoid increasing damage output on tank
-    if (pCreature && pCreature->GetCreatureInfo()->CreatureType == CREATURE_TYPE_HUMANOID && pTarget->GetHealthPercent() < 20 && !pCreature->IsWorldBoss())
-    {
-        if (CURSE_OF_EXHAUSTION && m_ai->In_Reach(pTarget, CURSE_OF_EXHAUSTION) && !pTarget->HasAura(CURSE_OF_EXHAUSTION))
-        {
-            if (AMPLIFY_CURSE && m_bot->IsSpellReady(AMPLIFY_CURSE))
-                CastSpell(AMPLIFY_CURSE, m_bot);
-
-            if (CastSpell(CURSE_OF_EXHAUSTION, pTarget))
-            {
-                m_CurrentCurse = CURSE_OF_EXHAUSTION;
-                return true;
-            }
-        }
-        else if (CURSE_OF_RECKLESSNESS && m_ai->In_Reach(pTarget, CURSE_OF_RECKLESSNESS) && !pTarget->HasAura(CURSE_OF_RECKLESSNESS) && !pTarget->HasAura(CURSE_OF_EXHAUSTION) && CastSpell(CURSE_OF_RECKLESSNESS, pTarget))
-        {
-            m_CurrentCurse = CURSE_OF_RECKLESSNESS;
-            return true;
-        }
-    }
-
-    // If bot already put a curse and curse is still active on target: no need to go further
-    if (m_CurrentCurse > 0 && pTarget->HasAura(m_CurrentCurse))
-        return false;
-
-    // No curse or effect worn off: choose again which curse to use
-
-    // Target is a boss
-    if (pCreature && pCreature->IsWorldBoss())
-    {
-        if (m_bot->GetGroup())
-        {
-            uint8 mages = 0;
-            uint8 warlocks = 1;
-            Group::MemberSlotList const& groupSlot = m_bot->GetGroup()->GetMemberSlots();
-            for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
-            {
-                Player* groupMember = sObjectMgr.GetPlayer(itr->guid);
-                if (!groupMember || !groupMember->isAlive())
-                    continue;
-                switch (groupMember->getClass())
-                {
-                    case CLASS_WARLOCK:
-                        warlocks++;
-                        continue;
-                    case CLASS_MAGE:
-                        mages++;
-                        continue;
-                }
-            }
-            if (warlocks > 1 && warlocks > mages)
-                CurseToCast = CURSE_OF_SHADOW;
-            else if (mages > warlocks)
-                CurseToCast = CURSE_OF_THE_ELEMENTS;
-            else
-                CurseToCast = CURSE_OF_AGONY;
-        }
-        // If target is not elite, no need to put a curse useful
-        // in the long run: go for direct damage
-    }
-    else if (!m_ai->IsElite(pTarget))
-        CurseToCast = CURSE_OF_AGONY;
-    // Enemy elite mages have low health but can cast dangerous spells: group safety before bot DPS
-    else if (pCreature && pCreature->GetCreatureInfo()->UnitClass == 8)
-        CurseToCast = CURSE_OF_TONGUES;
-    // Default case: Curse of Agony
-    else
-        CurseToCast = CURSE_OF_AGONY;
-
-    // Try to curse the target with the selected curse
-    if (CurseToCast && m_ai->In_Reach(pTarget, CurseToCast) && !pTarget->HasAura(CurseToCast))
-    {
-        if (CurseToCast == CURSE_OF_AGONY)
-            if (AMPLIFY_CURSE && m_bot->IsSpellReady(AMPLIFY_CURSE))
-                CastSpell(AMPLIFY_CURSE, m_bot);
-
-        if (CastSpell(CurseToCast, pTarget))
-        {
-            m_CurrentCurse = CurseToCast;
-            return true;
-        }
-    }
-    // else: go for Curse of Agony
-    else if (CURSE_OF_AGONY && m_ai->In_Reach(pTarget, CURSE_OF_AGONY) && !pTarget->HasAura(CURSE_OF_AGONY))
-    {
-        if (AMPLIFY_CURSE && m_bot->IsSpellReady(AMPLIFY_CURSE))
-            CastSpell(AMPLIFY_CURSE, m_bot);
-
-        if (CastSpell(CURSE_OF_AGONY, pTarget))
-        {
-            m_CurrentCurse = CURSE_OF_AGONY;
-            return true;
-        }
-    }
-    // else: go for Curse of Weakness
-    else if (CURSE_OF_WEAKNESS && !pTarget->HasAura(CURSE_OF_WEAKNESS) && !pTarget->HasAura(CURSE_OF_AGONY))
-    {
-        if (AMPLIFY_CURSE && m_bot->IsSpellReady(AMPLIFY_CURSE))
-            CastSpell(AMPLIFY_CURSE, m_bot);
-
-        if (CastSpell(CURSE_OF_WEAKNESS, pTarget))
-        {
-            m_CurrentCurse = CURSE_OF_WEAKNESS;
-            return true;
-        }
-    }
-    return false;
-}
-
-void PlayerbotWarlockAI::CheckDemon()
-{
-    uint32 spec = m_bot->GetSpec();
-    uint8 shardCount = m_bot->GetItemCount(SOUL_SHARD, false, nullptr);
-    Pet* pet = m_bot->GetPet();
-    uint32 demonOfChoice;
-
-    // If pet other than imp is active: return
-    if (pet && pet->GetEntry() != DEMON_IMP)
-        return;
-
-    // Assign demon of choice based on spec
-    if (spec == WARLOCK_SPEC_AFFLICTION)
-        demonOfChoice = DEMON_FELHUNTER;
-    else if (spec == WARLOCK_SPEC_DEMONOLOGY)
-        demonOfChoice = (DEMON_FELGUARD > 0 ? DEMON_FELGUARD : DEMON_SUCCUBUS);
-    else    // Destruction spec or no spec found
-        demonOfChoice = DEMON_IMP;
-
-    // Summon demon
-    if (!pet || m_isTempImp)
-    {
-        uint32 summonSpellId;
-        if (demonOfChoice != DEMON_IMP && shardCount > 0)
-        {
-            switch (demonOfChoice)
-            {
-                case DEMON_VOIDWALKER:
-                    summonSpellId = SUMMON_VOIDWALKER;
-                    break;
-
-                case DEMON_FELGUARD:
-                    summonSpellId = SUMMON_FELGUARD;
-                    break;
-
-                case DEMON_FELHUNTER:
-                    summonSpellId = SUMMON_FELHUNTER;
-                    break;
-
-                case DEMON_SUCCUBUS:
-                    summonSpellId = SUMMON_SUCCUBUS;
-                    break;
-
-                default:
-                    summonSpellId = 0;
-            }
-
-            if (summonSpellId && m_ai->CastSpell(summonSpellId))
-            {
-                //m_ai->TellMaster("Summoning favorite demon...");
-                m_isTempImp = false;
-                return;
-            }
-        }
-
-        if (!pet && SUMMON_IMP && m_ai->CastSpell(SUMMON_IMP))
-        {
-            if (demonOfChoice != DEMON_IMP)
-                m_isTempImp = true;
-            else
-                m_isTempImp = false;
-
-            //m_ai->TellMaster("Summoning Imp...");
-            return;
-        }
-    }
-
-    return;
-}
-
-void PlayerbotWarlockAI::DoNonCombatActions()
-{
-    if (!m_ai)  return;
-    if (!m_bot) return;
-
-    //uint32 spec = m_bot->GetSpec();
-    Pet* pet = m_bot->GetPet();
-
-    // Initialize pet spells
-    if (pet && pet->GetEntry() != m_lastDemon)
-    {
-        switch (pet->GetEntry())
-        {
-            case DEMON_IMP:
-                BLOOD_PACT       = m_ai->initPetSpell(BLOOD_PACT_ICON);
-                FIREBOLT         = m_ai->initPetSpell(FIREBOLT_ICON);
-                FIRE_SHIELD      = m_ai->initPetSpell(FIRE_SHIELD_ICON);
-                break;
-
-            case DEMON_VOIDWALKER:
-                CONSUME_SHADOWS  = m_ai->initPetSpell(CONSUME_SHADOWS_ICON);
-                SACRIFICE        = m_ai->initPetSpell(SACRIFICE_ICON);
-                SUFFERING        = m_ai->initPetSpell(SUFFERING_ICON);
-                TORMENT          = m_ai->initPetSpell(TORMENT_ICON);
-                break;
-
-            case DEMON_SUCCUBUS:
-                LASH_OF_PAIN     = m_ai->initPetSpell(LASH_OF_PAIN_ICON);
-                SEDUCTION        = m_ai->initPetSpell(SEDUCTION_ICON);
-                SOOTHING_KISS    = m_ai->initPetSpell(SOOTHING_KISS_ICON);
-                break;
-
-            case DEMON_FELHUNTER:
-                DEVOUR_MAGIC     = m_ai->initPetSpell(DEVOUR_MAGIC_ICON);
-                FEL_INTELLIGENCE = m_ai->initPetSpell(FEL_INTELLIGENCE_ICON);
-                SHADOW_BITE      = m_ai->initPetSpell(SHADOW_BITE_ICON);
-                SPELL_LOCK       = m_ai->initPetSpell(SPELL_LOCK_ICON);
-                break;
-
-            case DEMON_FELGUARD:
-                ANGUISH          = m_ai->initPetSpell(ANGUISH_ICON);
-                CLEAVE           = m_ai->initPetSpell(CLEAVE_ICON);
-                INTERCEPT        = m_ai->initPetSpell(INTERCEPT_ICON);
-                break;
-        }
-
-        m_lastDemon = pet->GetEntry();
-    }
-
-    // Destroy extra soul shards
-    uint8 shardCount = m_bot->GetItemCount(SOUL_SHARD, false, nullptr);
-    uint8 freeSpace = m_ai->GetFreeBagSpace();
-    if (shardCount > MAX_SHARD_COUNT || (freeSpace == 0 && shardCount > 1))
-        m_bot->DestroyItemCount(SOUL_SHARD, shardCount > MAX_SHARD_COUNT ? shardCount - MAX_SHARD_COUNT : 1, true, false);
-
-    // buff myself DEMON_SKIN, DEMON_ARMOR, FEL_ARMOR - Strongest one available is chosen
-    if (FEL_ARMOR)
-    {
-        if (m_ai->SelfBuff(FEL_ARMOR))
-            return;
-    }
-    else if (DEMON_ARMOR)
-    {
-        if (m_ai->SelfBuff(DEMON_ARMOR))
-            return;
-    }
-    else if (DEMON_SKIN)
-        if (m_ai->SelfBuff(DEMON_SKIN))
-            return;
-
-    // healthstone creation
-    if (CREATE_HEALTHSTONE && shardCount > 0)
-    {
-        Item* const healthStone = m_ai->FindConsumable(HEALTHSTONE_DISPLAYID);
-        if (!healthStone && m_ai->CastSpell(CREATE_HEALTHSTONE))
-            return;
-    }
-
-    // soulstone creation and use
-    if (CREATE_SOULSTONE)
-    {
-        Item* soulStone = m_ai->FindConsumable(SOULSTONE_DISPLAYID);
-        if (!soulStone)
-        {
-            if (shardCount > 0 && m_bot->IsSpellReady(CREATE_SOULSTONE) && m_ai->CastSpell(CREATE_SOULSTONE))
-                return;
-        }
-        else
-        {
-            uint32 soulStoneSpell = soulStone->GetProto()->Spells[0].SpellId;
-            Player* master = GetMaster();
-            if (!master->HasAura(soulStoneSpell) && m_bot->IsSpellReady(soulStoneSpell))
-            {
-                // TODO: first choice: healer. Second choice: anyone else with revive spell. Third choice: self or master.
-                m_ai->UseItem(soulStone, master);
-                return;
-            }
-        }
-    }
-
-    // hp/mana check
-    if (pet && DARK_PACT && (100 * pet->GetPower(POWER_MANA) / pet->GetMaxPower(POWER_MANA)) > 40 && m_ai->GetManaPercent() <= 60)
-        if (m_ai->CastSpell(DARK_PACT, *m_bot))
-            return;
-
-    if (LIFE_TAP && m_ai->GetManaPercent() <= 80 && m_ai->GetHealthPercent() > 50)
-        if (m_ai->CastSpell(LIFE_TAP, *m_bot))
-            return;
-
-    // Do not waste time/soul shards to create spellstone or firestone
-    // if two-handed weapon (staff) or off-hand item are already equiped
-    // Spellstone creation and use (Spellstone dominates firestone completely as I understand it)
-    Item* const weapon = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
-    Item* const offweapon = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
-    if (weapon && !offweapon && weapon->GetProto()->SubClass != ITEM_SUBCLASS_WEAPON_STAFF && weapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT) == 0)
-    {
-        Item* const stone = m_ai->FindConsumable(SPELLSTONE_DISPLAYID);
-        Item* const stone2 = m_ai->FindConsumable(FIRESTONE_DISPLAYID);
-        uint8 spellstone_count = m_bot->GetItemCount(SPELLSTONE, false, nullptr);
-        if (spellstone_count == 0)
-            spellstone_count = m_bot->GetItemCount(GREATER_SPELLSTONE, false, nullptr);
-        if (spellstone_count == 0)
-            spellstone_count = m_bot->GetItemCount(MAJOR_SPELLSTONE, false, nullptr);
-        uint8 firestone_count = m_bot->GetItemCount(LESSER_FIRESTONE, false, nullptr);
-        if (firestone_count == 0)
-            firestone_count = m_bot->GetItemCount(FIRESTONE, false, nullptr);
-        if (firestone_count == 0)
-            firestone_count = m_bot->GetItemCount(GREATER_FIRESTONE, false, nullptr);
-        if (firestone_count == 0)
-            firestone_count = m_bot->GetItemCount(MAJOR_FIRESTONE, false, nullptr);
-        if (spellstone_count == 0 && firestone_count == 0)
-        {
-            if (CREATE_SPELLSTONE && shardCount > 0 && m_ai->CastSpell(CREATE_SPELLSTONE))
-                return;
-            else if (CREATE_SPELLSTONE == 0 && CREATE_FIRESTONE > 0 && shardCount > 0 && m_ai->CastSpell(CREATE_FIRESTONE))
-                return;
-        }
-        else if (stone)
-        {
-            m_ai->UseItem(stone, EQUIPMENT_SLOT_OFFHAND);
-            return;
-        }
-        else
-        {
-            m_ai->UseItem(stone2, EQUIPMENT_SLOT_OFFHAND);
-            return;
-        }
-    }
-
-    if (EatDrinkBandage())
-        return;
-
-    //Heal Voidwalker
-    if (pet && pet->GetEntry() == DEMON_VOIDWALKER && CONSUME_SHADOWS && pet->GetHealthPercent() < 75 && !pet->HasAura(CONSUME_SHADOWS))
-        m_ai->CastPetSpell(CONSUME_SHADOWS);
-
-    CheckDemon();
-
-    // Soul link demon
-    if (pet && SOUL_LINK && !m_bot->HasAura(SOUL_LINK_AURA) && m_ai->CastSpell(SOUL_LINK, *m_bot))
-        return;
-
-    // Check demon buffs
-    if (pet && pet->GetEntry() == DEMON_IMP && BLOOD_PACT && !m_bot->HasAura(BLOOD_PACT) && m_ai->CastPetSpell(BLOOD_PACT))
-        return;
-
-    if (pet && pet->GetEntry() == DEMON_FELHUNTER && FEL_INTELLIGENCE && !m_bot->HasAura(FEL_INTELLIGENCE) && m_ai->CastPetSpell(FEL_INTELLIGENCE))
-        return;
-} // end DoNonCombatActions
-
-// Return to UpdateAI the spellId usable to neutralize a target with creaturetype
-uint32 PlayerbotWarlockAI::Neutralize(uint8 creatureType)
-{
-    if (!m_bot)         return 0;
-    if (!m_ai)          return 0;
-    if (!creatureType)  return 0;
-
-    // TODO: add a way to handle spell cast by pet like Seduction
-    if (creatureType != CREATURE_TYPE_DEMON && creatureType != CREATURE_TYPE_ELEMENTAL)
-    {
-        m_ai->TellMaster("I can't banish that target.");
-        return 0;
-    }
-
-    if (BANISH)
-        return BANISH;
-    else
-        return 0;
-
-    return 0;
-}
diff --git a/src/game/PlayerBot/AI/PlayerbotWarlockAI.h b/src/game/PlayerBot/AI/PlayerbotWarlockAI.h
deleted file mode 100644
index bcf0b6eb6..000000000
--- a/src/game/PlayerBot/AI/PlayerbotWarlockAI.h
+++ /dev/null
@@ -1,276 +0,0 @@
-/*
- * This file is part of the CMaNGOS Project. See AUTHORS file for Copyright information
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _PlayerbotWarlockAI_H
-#define _PlayerbotWarlockAI_H
-
-#include "../Base/PlayerbotClassAI.h"
-
-#define SOUL_SHARD 6265
-#define SPELLSTONE 5522
-#define GREATER_SPELLSTONE 13602
-#define MAJOR_SPELLSTONE 13603
-#define LESSER_FIRESTONE 1254
-#define FIRESTONE 13699
-#define GREATER_FIRESTONE 13700
-#define MAJOR_FIRESTONE 13701
-#define MAX_SHARD_COUNT 15 // Maximum soul shard count bot should keep
-
-enum
-{
-    SPELL_CURSES,
-    SPELL_AFFLICTION,
-    SPELL_DESTRUCTION,
-    SPELL_DEMONOLOGY
-};
-
-enum StoneDisplayId
-{
-    FIRESTONE_DISPLAYID   = 24380,
-    SPELLSTONE_DISPLAYID  = 21610,
-    SOULSTONE_DISPLAYID   = 6009,
-    HEALTHSTONE_DISPLAYID = 8026
-};
-
-enum DemonEntry
-{
-    DEMON_IMP        = 416,
-    DEMON_VOIDWALKER = 1860,
-    DEMON_SUCCUBUS   = 1863,
-    DEMON_FELHUNTER  = 417,
-    DEMON_FELGUARD   = 17252
-};
-
-enum DemonSpellIconIds
-{
-    // Imp
-    BLOOD_PACT_ICON       = 541,
-    FIREBOLT_ICON         = 18,
-    FIRE_SHIELD_ICON      = 16,
-    // Felguard
-    ANGUISH_ICON          = 173,
-    CLEAVE_ICON           = 277,
-    INTERCEPT_ICON        = 516,
-    // Felhunter
-    DEVOUR_MAGIC_ICON     = 47,
-    FEL_INTELLIGENCE_ICON = 1940,
-    SHADOW_BITE_ICON      = 2027,
-    SPELL_LOCK_ICON       = 77,
-    // Succubus
-    LASH_OF_PAIN_ICON     = 596,
-    SEDUCTION_ICON        = 48,
-    SOOTHING_KISS_ICON    = 694,
-    // Voidwalker
-    CONSUME_SHADOWS_ICON  = 207,
-    SACRIFICE_ICON        = 693,
-    SUFFERING_ICON        = 9,
-    TORMENT_ICON          = 173
-};
-
-enum WarlockSpells
-{
-    AMPLIFY_CURSE_1                 = 18288,
-    BANISH_1                        = 710,
-    CONFLAGRATE_1                   = 17962,
-    CORRUPTION_1                    = 172,
-    CREATE_FIRESTONE_1              = 6366,
-    CREATE_HEALTHSTONE_1            = 6201,
-    CREATE_SOULSTONE_1              = 693,
-    CREATE_SPELLSTONE_1             = 2362,
-    CURSE_OF_AGONY_1                = 980,
-    CURSE_OF_DOOM_1                 = 603,
-    CURSE_OF_EXHAUSTION_1           = 18223,
-    CURSE_OF_RECKLESSNESS_1         = 704,
-    CURSE_OF_SHADOW_1               = 17862,
-    CURSE_OF_THE_ELEMENTS_1         = 1490,
-    CURSE_OF_TONGUES_1              = 1714,
-    CURSE_OF_WEAKNESS_1             = 702,
-    DARK_PACT_1                     = 18220,
-    DEATH_COIL_WARLOCK_1            = 6789,
-    DEMON_ARMOR_1                   = 706,
-    DEMON_SKIN_1                    = 687,
-    DETECT_INVISIBILITY_1           = 132,
-    DRAIN_LIFE_1                    = 689,
-    DRAIN_MANA_1                    = 5138,
-    DRAIN_SOUL_1                    = 1120,
-    ENSLAVE_DEMON_1                 = 1098,
-    EYE_OF_KILROGG_1                = 126,
-    FEAR_1                          = 5782,
-    FEL_ARMOR_1                     = 28176,
-    FEL_DOMINATION_1                = 18708,
-    HEALTH_FUNNEL_1                 = 755,
-    HELLFIRE_1                      = 1949,
-    HOWL_OF_TERROR_1                = 5484,
-    IMMOLATE_1                      = 348,
-    INCINERATE_1                    = 29722,
-    INFERNO_1                       = 1122,
-    LIFE_TAP_1                      = 1454,
-    RAIN_OF_FIRE_1                  = 5740,
-    RITUAL_OF_DOOM_1                = 18540,
-    RITUAL_OF_SOULS_1               = 29893,
-    RITUAL_OF_SUMMONING_1           = 698,
-    SEARING_PAIN_1                  = 5676,
-    SEED_OF_CORRUPTION_1            = 27243,
-    SENSE_DEMONS_1                  = 5500,
-    SHADOW_BOLT_1                   = 686,
-    SHADOW_WARD_1                   = 6229,
-    SHADOWBURN_1                    = 17877,
-    SHADOWFURY_1                    = 30283,
-    SHOOT_3                         = 5019,
-    SIPHON_LIFE_1                   = 18265,
-    SOUL_FIRE_1                     = 6353,
-    SOUL_LINK_1                     = 19028,
-    SOULSHATTER_1                   = 29858,
-    SUMMON_FELGUARD_1               = 30146,
-    SUMMON_FELHUNTER_1              = 691,
-    SUMMON_IMP_1                    = 688,
-    SUMMON_SUCCUBUS_1               = 712,
-    SUMMON_VOIDWALKER_1             = 697,
-    UNENDING_BREATH_1               = 5697,
-    UNSTABLE_AFFLICTION_1           = 30108
-};
-
-//class Player;
-class PlayerbotWarlockAI : PlayerbotClassAI
-{
-    public:
-        PlayerbotWarlockAI(Player* const master, Player* const bot, PlayerbotAI* const ai);
-        virtual ~PlayerbotWarlockAI();
-
-        // all combat actions go here
-        CombatManeuverReturns DoFirstCombatManeuver(Unit* pTarget);
-        CombatManeuverReturns DoNextCombatManeuver(Unit* pTarget);
-        uint32 Neutralize(uint8 creatureType);
-
-        // all non combat actions go here, ex buffs, heals, rezzes
-        void DoNonCombatActions();
-
-        // buff a specific player, usually a real PC who is not in group
-        //void BuffPlayer(Player *target);
-
-    private:
-        CombatManeuverReturns DoFirstCombatManeuverPVE(Unit* pTarget);
-        CombatManeuverReturns DoNextCombatManeuverPVE(Unit* pTarget);
-        CombatManeuverReturns DoFirstCombatManeuverPVP(Unit* pTarget);
-        CombatManeuverReturns DoNextCombatManeuverPVP(Unit* pTarget);
-
-        CombatManeuverReturns CastSpell(uint32 nextAction, Unit* pTarget = nullptr) { return CastSpellWand(nextAction, pTarget, SHOOT); }
-
-        bool CheckCurse(Unit* pTarget);
-        void CheckDemon();
-
-        // CURSES
-        uint32 CURSE_OF_WEAKNESS,
-               CURSE_OF_AGONY,
-               CURSE_OF_EXHAUSTION,
-               CURSE_OF_RECKLESSNESS,
-               CURSE_OF_SHADOW,
-               CURSE_OF_TONGUES,
-               CURSE_OF_THE_ELEMENTS,
-               CURSE_OF_DOOM;
-        // ranged
-        uint32 SHOOT;
-
-        // AFFLICTION
-        uint32 AMPLIFY_CURSE,
-               CORRUPTION,
-               DRAIN_SOUL,
-               DRAIN_LIFE,
-               DRAIN_MANA,
-               LIFE_TAP,
-               UNSTABLE_AFFLICTION,
-               SEED_OF_CORRUPTION,
-               DARK_PACT,
-               HOWL_OF_TERROR,
-               FEAR,
-               SIPHON_LIFE;
-
-        // DESTRUCTION
-        uint32 SHADOW_BOLT,
-               IMMOLATE,
-               INCINERATE,
-               SEARING_PAIN,
-               CONFLAGRATE,
-               SOUL_FIRE,
-               SHADOWFURY,
-               HELLFIRE,
-               RAIN_OF_FIRE,
-               SHADOWBURN;
-
-        // DEMONOLOGY
-        uint32 BANISH,
-               DEMON_SKIN,
-               DEMON_ARMOR,
-               DEMONIC_EMPOWERMENT,
-               SHADOW_WARD,
-               FEL_ARMOR,
-               SOULSHATTER,
-               ENSLAVE_DEMON,
-               SOUL_LINK,
-               SOUL_LINK_AURA,
-               HEALTH_FUNNEL,
-               DETECT_INVISIBILITY,
-               CREATE_FIRESTONE,
-               CREATE_SOULSTONE,
-               CREATE_HEALTHSTONE,
-               CREATE_SPELLSTONE;
-
-        // DEMON SUMMON
-        uint32 SUMMON_IMP,
-               SUMMON_VOIDWALKER,
-               SUMMON_SUCCUBUS,
-               SUMMON_FELHUNTER,
-               SUMMON_FELGUARD;
-
-        // DEMON SKILLS
-        uint32 BLOOD_PACT,
-               FIREBOLT,
-               FIRE_SHIELD,
-               ANGUISH,
-               INTERCEPT,
-               DEVOUR_MAGIC,
-               FEL_INTELLIGENCE,
-               SHADOW_BITE,
-               SPELL_LOCK,
-               LASH_OF_PAIN,
-               SEDUCTION,
-               SOOTHING_KISS,
-               CONSUME_SHADOWS,
-               SACRIFICE,
-               SUFFERING,
-               CLEAVE,
-               TORMENT;
-
-        // racial
-        uint32 ARCANE_TORRENT,
-               GIFT_OF_THE_NAARU,
-               STONEFORM,
-               ESCAPE_ARTIST,
-               PERCEPTION,
-               SHADOWMELD,
-               BLOOD_FURY,
-               WAR_STOMP,
-               BERSERKING,
-               WILL_OF_THE_FORSAKEN;
-
-        uint32 m_lastDemon;      // Last demon entry used for spell initialization
-        bool m_isTempImp;        // True if imp summoned temporarily until soul shard acquired for demon of choice.
-        uint32 m_CurrentCurse;   // Curse currently active on bot's target
-};
-
-#endif
diff --git a/src/game/PlayerBot/AI/PlayerbotWarriorAI.cpp b/src/game/PlayerBot/AI/PlayerbotWarriorAI.cpp
deleted file mode 100644
index db4a77f4a..000000000
--- a/src/game/PlayerBot/AI/PlayerbotWarriorAI.cpp
+++ /dev/null
@@ -1,635 +0,0 @@
-/*
- * This file is part of the CMaNGOS Project. See AUTHORS file for Copyright information
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "PlayerbotWarriorAI.h"
-#include "../Base/PlayerbotMgr.h"
-
-class PlayerbotAI;
-PlayerbotWarriorAI::PlayerbotWarriorAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
-{
-    AUTO_SHOT               = m_ai->initSpell(AUTO_SHOT_2); // GENERAL
-
-    BATTLE_STANCE           = m_ai->initSpell(BATTLE_STANCE_1); //ARMS
-    CHARGE                  = m_ai->initSpell(CHARGE_1); //ARMS
-    OVERPOWER               = m_ai->initSpell(OVERPOWER_1); // ARMS
-    HEROIC_STRIKE           = m_ai->initSpell(HEROIC_STRIKE_1); //ARMS
-    REND                    = m_ai->initSpell(REND_1); //ARMS
-    THUNDER_CLAP            = m_ai->initSpell(THUNDER_CLAP_1);  //ARMS
-    HAMSTRING               = m_ai->initSpell(HAMSTRING_1);  //ARMS
-    MOCKING_BLOW            = m_ai->initSpell(MOCKING_BLOW_1);  //ARMS
-    RETALIATION             = m_ai->initSpell(RETALIATION_1);  //ARMS
-    SWEEPING_STRIKES        = m_ai->initSpell(SWEEPING_STRIKES_1); //ARMS
-    MORTAL_STRIKE           = m_ai->initSpell(MORTAL_STRIKE_1);  //ARMS
-    BLOODRAGE               = m_ai->initSpell(BLOODRAGE_1); //PROTECTION
-    DEFENSIVE_STANCE        = m_ai->initSpell(DEFENSIVE_STANCE_1); //PROTECTION
-    DEVASTATE               = m_ai->initSpell(DEVASTATE_1); //PROTECTION
-    SUNDER_ARMOR            = m_ai->initSpell(SUNDER_ARMOR_1); //PROTECTION
-    TAUNT                   = m_ai->initSpell(TAUNT_1); //PROTECTION
-    SHIELD_BASH             = m_ai->initSpell(SHIELD_BASH_1); //PROTECTION
-    REVENGE                 = m_ai->initSpell(REVENGE_1); //PROTECTION
-    SHIELD_BLOCK            = m_ai->initSpell(SHIELD_BLOCK_1); //PROTECTION
-    DISARM                  = m_ai->initSpell(DISARM_1); //PROTECTION
-    SHIELD_WALL             = m_ai->initSpell(SHIELD_WALL_1); //PROTECTION
-    SHIELD_SLAM             = m_ai->initSpell(SHIELD_SLAM_1); //PROTECTION
-    DEVASTATE               = m_ai->initSpell(DEVASTATE_1); //PROTECTION
-    SHOCKWAVE               = m_ai->initSpell(SHOCKWAVE_1); //PROTECTION
-    CONCUSSION_BLOW         = m_ai->initSpell(CONCUSSION_BLOW_1); //PROTECTION
-    SPELL_REFLECTION        = m_ai->initSpell(SPELL_REFLECTION_1); //PROTECTION
-    LAST_STAND              = m_ai->initSpell(LAST_STAND_1); //PROTECTION
-    BATTLE_SHOUT            = m_ai->initSpell(BATTLE_SHOUT_1); //FURY
-    DEMORALIZING_SHOUT      = m_ai->initSpell(DEMORALIZING_SHOUT_1); //FURY
-    CLEAVE                  = m_ai->initSpell(CLEAVE_1); //FURY
-    INTIMIDATING_SHOUT      = m_ai->initSpell(INTIMIDATING_SHOUT_1); //FURY
-    EXECUTE                 = m_ai->initSpell(EXECUTE_1); //FURY
-    CHALLENGING_SHOUT       = m_ai->initSpell(CHALLENGING_SHOUT_1); //FURY
-    SLAM                    = m_ai->initSpell(SLAM_1); //FURY
-    BERSERKER_STANCE        = m_ai->initSpell(BERSERKER_STANCE_1); //FURY
-    INTERCEPT               = m_ai->initSpell(INTERCEPT_1); //FURY
-    DEATH_WISH              = m_ai->initSpell(DEATH_WISH_1); //FURY
-    BERSERKER_RAGE          = m_ai->initSpell(BERSERKER_RAGE_1); //FURY
-    WHIRLWIND               = m_ai->initSpell(WHIRLWIND_1); //FURY
-    PUMMEL                  = m_ai->initSpell(PUMMEL_1); //FURY
-    BLOODTHIRST             = m_ai->initSpell(BLOODTHIRST_1); //FURY
-    RECKLESSNESS            = m_ai->initSpell(RECKLESSNESS_1); //FURY
-    RAMPAGE                 = 0; // passive
-    COMMANDING_SHOUT        = m_ai->initSpell(COMMANDING_SHOUT_1); //FURY
-    PIERCING_HOWL           = m_ai->initSpell(PIERCING_HOWL_1); //FURY
-
-    RECENTLY_BANDAGED       = 11196; // first aid check
-
-    // racial
-    GIFT_OF_THE_NAARU       = m_ai->initSpell(GIFT_OF_THE_NAARU_ALL); // draenei
-    STONEFORM               = m_ai->initSpell(STONEFORM_ALL); // dwarf
-    ESCAPE_ARTIST           = m_ai->initSpell(ESCAPE_ARTIST_ALL); // gnome
-    PERCEPTION              = m_ai->initSpell(PERCEPTION_ALL); // human
-    SHADOWMELD              = m_ai->initSpell(SHADOWMELD_ALL); // night elf
-    BLOOD_FURY              = m_ai->initSpell(BLOOD_FURY_MELEE_CLASSES); // orc
-    WAR_STOMP               = m_ai->initSpell(WAR_STOMP_ALL); // tauren
-    BERSERKING              = m_ai->initSpell(BERSERKING_ALL); // troll
-    WILL_OF_THE_FORSAKEN    = m_ai->initSpell(WILL_OF_THE_FORSAKEN_ALL); // undead
-
-    //Procs
-}
-PlayerbotWarriorAI::~PlayerbotWarriorAI() {}
-
-CombatManeuverReturns PlayerbotWarriorAI::DoFirstCombatManeuver(Unit* pTarget)
-{
-    // There are NPCs in BGs and Open World PvP, so don't filter this on PvP scenarios (of course if PvP targets anyone but tank, all bets are off anyway)
-    // Wait until the tank says so, until any non-tank gains aggro or X seconds - whichever is shortest
-    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO)
-    {
-        if (m_WaitUntil > m_ai->CurrentTime() && m_ai->GroupTankHoldsAggro())
-        {
-            if (PlayerbotAI::ORDERS_TANK & m_ai->GetCombatOrder())
-            {
-                if (m_bot->GetDistance(pTarget, true, DIST_CALC_COMBAT_REACH_WITH_MELEE) <= ATTACK_DISTANCE)
-                {
-                    // Set everyone's UpdateAI() waiting to 2 seconds
-                    m_ai->SetGroupIgnoreUpdateTime(2);
-                    // Clear their TEMP_WAIT_TANKAGGRO flag
-                    m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO);
-                    // Start attacking, force target on current target
-                    m_ai->Attack(m_ai->GetCurrentTarget());
-
-                    // While everyone else is waiting 2 second, we need to build up aggro, so don't return
-                }
-                else
-                {
-                    // TODO: add check if target is ranged
-                    return RETURN_NO_ACTION_OK; // wait for target to get nearer
-                }
-            }
-            else
-                return RETURN_NO_ACTION_OK; // wait it out
-        }
-        else
-        {
-            m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_TANKAGGRO);
-        }
-    }
-
-    if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TEMP_WAIT_OOC)
-    {
-        if (m_WaitUntil > m_ai->CurrentTime() && m_ai->IsGroupReady())
-            return RETURN_NO_ACTION_OK; // wait it out
-        else
-            m_ai->ClearGroupCombatOrder(PlayerbotAI::ORDERS_TEMP_WAIT_OOC);
-    }
-
-    switch (m_ai->GetScenarioType())
-    {
-        case PlayerbotAI::SCENARIO_PVP_DUEL:
-        case PlayerbotAI::SCENARIO_PVP_BG:
-        case PlayerbotAI::SCENARIO_PVP_ARENA:
-        case PlayerbotAI::SCENARIO_PVP_OPENWORLD:
-            return DoFirstCombatManeuverPVP(pTarget);
-        case PlayerbotAI::SCENARIO_PVE:
-        case PlayerbotAI::SCENARIO_PVE_ELITE:
-        case PlayerbotAI::SCENARIO_PVE_RAID:
-        default:
-            return DoFirstCombatManeuverPVE(pTarget);
-            break;
-    }
-
-    return RETURN_NO_ACTION_ERROR;
-}
-
-CombatManeuverReturns PlayerbotWarriorAI::DoFirstCombatManeuverPVE(Unit* pTarget)
-{
-    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
-    if (!m_bot) return RETURN_NO_ACTION_ERROR;
-
-    float fTargetDist = m_bot->GetDistance(pTarget, true, DIST_CALC_COMBAT_REACH_WITH_MELEE);
-
-    // Get bot spec. If bot has tank orders, force spec to protection
-    uint32 spec = ((m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TANK) ? WARRIOR_SPEC_PROTECTION : m_bot->GetSpec());
-
-    if (BERSERKER_STANCE && spec == WARRIOR_SPEC_FURY && (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_ASSIST))
-    {
-        if (!m_bot->HasAura(BERSERKER_STANCE, EFFECT_INDEX_0) && m_ai->CastSpell(BERSERKER_STANCE))
-            return RETURN_CONTINUE;
-        if (BLOODRAGE > 0 && m_bot->HasAura(BERSERKER_STANCE, EFFECT_INDEX_0) && m_ai->GetRageAmount() <= 10)
-            return m_ai->CastSpell(BLOODRAGE) ? RETURN_FINISHED_FIRST_MOVES : RETURN_NO_ACTION_ERROR;
-        if (INTERCEPT > 0 && m_bot->HasAura(BERSERKER_STANCE, EFFECT_INDEX_0))
-        {
-            if (fTargetDist < 8.0f)
-                return RETURN_NO_ACTION_OK;
-            else if (fTargetDist > 25.0f)
-                return RETURN_CONTINUE; // wait to come into range
-            else if (INTERCEPT > 0 && m_ai->CastSpell(INTERCEPT, *pTarget))
-            {
-                float x, y, z;
-                pTarget->GetContactPoint(m_bot, x, y, z, 3.666666f);
-                m_bot->Relocate(x, y, z);
-                return RETURN_FINISHED_FIRST_MOVES;
-            }
-        }
-    }
-    else if (BATTLE_STANCE && (spec == WARRIOR_SPEC_ARMS || (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_ASSIST)))
-    {
-        if (!m_bot->HasAura(BATTLE_STANCE, EFFECT_INDEX_0) && m_ai->CastSpell(BATTLE_STANCE))
-            return RETURN_CONTINUE;
-        if (CHARGE > 0 && m_bot->HasAura(BATTLE_STANCE, EFFECT_INDEX_0))
-        {
-            if (fTargetDist < 8.0f)
-                return RETURN_NO_ACTION_OK;
-            if (fTargetDist > 25.0f)
-                return RETURN_CONTINUE; // wait to come into range
-            else if (CHARGE > 0 && m_ai->CastSpell(CHARGE, *pTarget))
-            {
-                float x, y, z;
-                pTarget->GetContactPoint(m_bot, x, y, z, 3.666666f);
-                m_bot->Relocate(x, y, z);
-                return RETURN_FINISHED_FIRST_MOVES;
-            }
-        }
-    }
-    else if (DEFENSIVE_STANCE && spec == WARRIOR_SPEC_PROTECTION)
-    {
-        if (!m_bot->HasAura(DEFENSIVE_STANCE, EFFECT_INDEX_0) && m_ai->CastSpell(DEFENSIVE_STANCE))
-            return RETURN_CONTINUE;
-        else if (TAUNT > 0 && m_bot->HasAura(DEFENSIVE_STANCE, EFFECT_INDEX_0) && m_ai->CastSpell(TAUNT, *pTarget))
-            return RETURN_FINISHED_FIRST_MOVES;
-    }
-
-    return RETURN_NO_ACTION_OK;
-}
-
-// TODO: blatant copy of PVE for now, please PVP-port it
-CombatManeuverReturns PlayerbotWarriorAI::DoFirstCombatManeuverPVP(Unit* pTarget)
-{
-    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
-    if (!m_bot) return RETURN_NO_ACTION_ERROR;
-
-    float fTargetDist = m_bot->GetDistance(pTarget, true, DIST_CALC_COMBAT_REACH_WITH_MELEE);
-
-    if (DEFENSIVE_STANCE && (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TANK))
-    {
-        if (!m_bot->HasAura(DEFENSIVE_STANCE, EFFECT_INDEX_0) && m_ai->CastSpell(DEFENSIVE_STANCE))
-            return RETURN_CONTINUE;
-        else if (TAUNT > 0 && m_bot->HasAura(DEFENSIVE_STANCE, EFFECT_INDEX_0) && m_ai->CastSpell(TAUNT, *pTarget))
-            return RETURN_FINISHED_FIRST_MOVES;
-    }
-
-    if (BERSERKER_STANCE)
-    {
-        if (!m_bot->HasAura(BERSERKER_STANCE, EFFECT_INDEX_0) && m_ai->CastSpell(BERSERKER_STANCE))
-            return RETURN_CONTINUE;
-        if (BLOODRAGE > 0 && m_bot->HasAura(BERSERKER_STANCE, EFFECT_INDEX_0) && m_ai->GetRageAmount() <= 10)
-            return m_ai->CastSpell(BLOODRAGE) ? RETURN_FINISHED_FIRST_MOVES : RETURN_NO_ACTION_ERROR;
-        if (INTERCEPT > 0 && m_bot->HasAura(BERSERKER_STANCE, EFFECT_INDEX_0))
-        {
-            if (fTargetDist < 8.0f)
-                return RETURN_NO_ACTION_OK;
-            else if (fTargetDist > 25.0f)
-                return RETURN_CONTINUE; // wait to come into range
-            else if (INTERCEPT > 0 && m_ai->CastSpell(INTERCEPT, *pTarget))
-            {
-                float x, y, z;
-                pTarget->GetContactPoint(m_bot, x, y, z, 3.666666f);
-                m_bot->Relocate(x, y, z);
-                return RETURN_FINISHED_FIRST_MOVES;
-            }
-        }
-    }
-
-    if (BATTLE_STANCE)
-    {
-        if (!m_bot->HasAura(BATTLE_STANCE, EFFECT_INDEX_0) && m_ai->CastSpell(BATTLE_STANCE))
-            return RETURN_CONTINUE;
-        if (CHARGE > 0 && m_bot->HasAura(BATTLE_STANCE, EFFECT_INDEX_0))
-        {
-            if (fTargetDist < 8.0f)
-                return RETURN_NO_ACTION_OK;
-            if (fTargetDist > 25.0f)
-                return RETURN_CONTINUE; // wait to come into range
-            else if (CHARGE > 0 && m_ai->CastSpell(CHARGE, *pTarget))
-            {
-                float x, y, z;
-                pTarget->GetContactPoint(m_bot, x, y, z, 3.666666f);
-                m_bot->Relocate(x, y, z);
-                return RETURN_FINISHED_FIRST_MOVES;
-            }
-        }
-    }
-
-    return RETURN_NO_ACTION_OK;
-}
-
-CombatManeuverReturns PlayerbotWarriorAI::DoNextCombatManeuver(Unit* pTarget)
-{
-    // Face enemy, make sure bot is attacking
-    m_ai->FaceTarget(pTarget);
-
-    switch (m_ai->GetScenarioType())
-    {
-        case PlayerbotAI::SCENARIO_PVP_DUEL:
-        case PlayerbotAI::SCENARIO_PVP_BG:
-        case PlayerbotAI::SCENARIO_PVP_ARENA:
-        case PlayerbotAI::SCENARIO_PVP_OPENWORLD:
-            return DoNextCombatManeuverPVP(pTarget);
-        case PlayerbotAI::SCENARIO_PVE:
-        case PlayerbotAI::SCENARIO_PVE_ELITE:
-        case PlayerbotAI::SCENARIO_PVE_RAID:
-        default:
-            return DoNextCombatManeuverPVE(pTarget);
-            break;
-    }
-
-    return RETURN_NO_ACTION_ERROR;
-}
-
-CombatManeuverReturns PlayerbotWarriorAI::DoNextCombatManeuverPVE(Unit* pTarget)
-{
-    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
-    if (!m_bot) return RETURN_NO_ACTION_ERROR;
-
-    //float fTargetDist = m_bot->GetCombatDistance(pTarget, true);
-
-    //If we have devastate it will replace SA in our rotation
-    uint32 SUNDER = (DEVASTATE > 0 ? DEVASTATE : SUNDER_ARMOR);
-
-    //Used to determine if this bot is highest on threat
-    Unit* newTarget = m_ai->FindAttacker((PlayerbotAI::ATTACKERINFOTYPE)(PlayerbotAI::AIT_VICTIMSELF | PlayerbotAI::AIT_HIGHESTTHREAT), m_bot);
-    Unit* pVictim = pTarget->getVictim();
-
-    // do shouts, berserker rage, etc...
-    if (BERSERKER_RAGE > 0 && !m_bot->HasAura(BERSERKER_RAGE, EFFECT_INDEX_0))
-        m_ai->CastSpell(BERSERKER_RAGE);
-    else if (BLOODRAGE > 0 && m_ai->GetRageAmount() <= 10)
-        m_ai->CastSpell(BLOODRAGE);
-
-    Creature* pCreature = (Creature*) pTarget;
-
-    // Prevent low health humanoid from fleeing with Hamstring
-    if (pCreature && (m_bot->HasAura(BATTLE_STANCE, EFFECT_INDEX_0) || m_bot->HasAura(BERSERKER_STANCE, EFFECT_INDEX_0)) && pCreature->GetCreatureInfo()->CreatureType == CREATURE_TYPE_HUMANOID && pTarget->GetHealthPercent() < 20 && !pCreature->IsWorldBoss())
-    {
-        if (HAMSTRING > 0 && !pTarget->HasAura(HAMSTRING, EFFECT_INDEX_0) && m_ai->CastSpell(HAMSTRING, *pTarget))
-            return RETURN_CONTINUE;
-    }
-
-    CheckShouts();
-
-    // Get bot spec. If bot has tank orders, force spec to protection
-    uint32 spec = ((m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TANK) ? WARRIOR_SPEC_PROTECTION : m_bot->GetSpec());
-
-    if (spec == WARRIOR_SPEC_FURY && (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_ASSIST))
-    {
-        // Try to interrupt spell if target is casting one
-        if (pTarget->IsNonMeleeSpellCasted(true))
-        {
-            if (PUMMEL > 0 && m_bot->IsSpellReady(PUMMEL) && m_ai->CastSpell(PUMMEL, *pTarget))
-                return RETURN_CONTINUE;
-        }
-
-        if (DEATH_WISH > 0 && !m_bot->HasAura(DEATH_WISH, EFFECT_INDEX_0) && m_bot->IsSpellReady(DEATH_WISH) && m_ai->CastSpell(DEATH_WISH, *m_bot))
-            return RETURN_CONTINUE;
-        if (EXECUTE > 0 && pTarget->GetHealthPercent() < 20 && m_ai->CastSpell(EXECUTE, *pTarget))
-            return RETURN_CONTINUE;
-        if (BLOODTHIRST > 0 && m_bot->IsSpellReady(BLOODTHIRST) && m_ai->CastSpell(BLOODTHIRST, *pTarget))
-            return RETURN_CONTINUE;
-        if (WHIRLWIND > 0 && m_bot->IsSpellReady(WHIRLWIND) && m_ai->CastSpell(WHIRLWIND, *pTarget))
-            return RETURN_CONTINUE;
-        if (SLAM > 0 && m_ai->CastSpell(SLAM, *pTarget))
-            return RETURN_CONTINUE;
-        if (HEROIC_STRIKE > 0 && m_ai->CastSpell(HEROIC_STRIKE, *pTarget))
-            return RETURN_CONTINUE;
-    }
-    else if (spec == WARRIOR_SPEC_ARMS || (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_ASSIST))
-    {
-        // Try to interrupt spell if target is casting one
-        if (pTarget->IsNonMeleeSpellCasted(true))
-        {
-            if (SHIELD_BASH > 0 && m_ai->CastSpell(SHIELD_BASH, *pTarget))
-                return RETURN_CONTINUE;
-        }
-
-        // If bot's target is also attacking the bot, use retaliation for extra attacks
-        if (RETALIATION > 0 && pVictim == m_bot && m_ai->GetAttackerCount() >= 2 && m_bot->IsSpellReady(RETALIATION) && !m_bot->HasAura(RETALIATION, EFFECT_INDEX_0) && m_ai->CastSpell(RETALIATION, *m_bot))
-            return RETURN_CONTINUE;
-
-        if (EXECUTE > 0 && pTarget->GetHealthPercent() < 20 && m_ai->CastSpell(EXECUTE, *pTarget))
-            return RETURN_CONTINUE;
-        if (REND > 0 && !pTarget->HasAura(REND, EFFECT_INDEX_0) && m_ai->CastSpell(REND, *pTarget))
-            return RETURN_CONTINUE;
-        if (MORTAL_STRIKE > 0 && m_bot->IsSpellReady(MORTAL_STRIKE) && m_ai->CastSpell(MORTAL_STRIKE, *pTarget))
-            return RETURN_CONTINUE;
-        if (OVERPOWER > 0 && m_bot->IsSpellReady(OVERPOWER))
-        {
-            uint8 base = pTarget->RollMeleeOutcomeAgainst(m_bot, BASE_ATTACK, SPELL_SCHOOL_MASK_NORMAL);
-            uint8 off = pTarget->RollMeleeOutcomeAgainst(m_bot, OFF_ATTACK, SPELL_SCHOOL_MASK_NORMAL);
-            if (base == MELEE_HIT_DODGE || off == MELEE_HIT_DODGE)
-            {
-                if (m_bot->IsSpellReady(OVERPOWER) && m_ai->CastSpell(OVERPOWER, *pTarget))
-                    return RETURN_CONTINUE;
-            }
-        }
-        if (THUNDER_CLAP > 0 && !pTarget->HasAura(THUNDER_CLAP) && m_ai->CastSpell(THUNDER_CLAP, *pTarget))
-            return RETURN_CONTINUE;
-        if (HEROIC_STRIKE > 0 && m_ai->CastSpell(HEROIC_STRIKE, *pTarget))
-            return RETURN_CONTINUE;
-        if (SLAM > 0 && m_ai->CastSpell(SLAM, *pTarget))
-            return RETURN_CONTINUE;
-    }
-    else if (spec == WARRIOR_SPEC_PROTECTION)
-    {
-        // First check: is bot's target targeting bot?
-        if (!newTarget)
-        {
-            // Cast taunt on bot current target if the mob is targeting someone else
-            if (m_ai->GetCombatOrder() & PlayerbotAI::ORDERS_TANK && TAUNT > 0 && m_bot->IsSpellReady(TAUNT) && m_ai->CastSpell(TAUNT, *pTarget))
-                return RETURN_CONTINUE;
-        }
-
-        // If tank is on the verge of dying but "I DON'T WANT TO DIE !!! :'-(("
-        // TODO: should behaviour (or treshold) be different between elite and normal mobs? We don't want bots to burn such precious cooldown needlessly
-        if (m_bot->GetHealthPercent() < 10)
-        {
-            // Cast Last Stand first because it has lower cooldown
-            if (LAST_STAND > 0 && !m_bot->HasAura(LAST_STAND, EFFECT_INDEX_0) && m_ai->CastSpell(LAST_STAND, *m_bot))
-            {
-                m_ai->TellMaster("I'm using LAST STAND");
-                return RETURN_CONTINUE;
-            }
-
-            // Cast Shield Wall only if Last Stand is on cooldown and not active
-            if (SHIELD_WALL > 0 && (!m_bot->IsSpellReady(LAST_STAND) || LAST_STAND == 0) && !m_bot->HasAura(LAST_STAND, EFFECT_INDEX_0) && !m_bot->HasAura(SHIELD_WALL, EFFECT_INDEX_0) && m_ai->CastSpell(SHIELD_WALL, *m_bot))
-            {
-                m_ai->TellMaster("I'm using SHIELD WALL");
-                return RETURN_CONTINUE;
-            }
-        }
-
-        // Try to interrupt spell if target is casting one
-        if (pTarget->IsNonMeleeSpellCasted(true))
-        {
-            if (SHIELD_BASH > 0 && m_ai->CastSpell(SHIELD_BASH, *pTarget))
-                return RETURN_CONTINUE;
-            if (PUMMEL > 0 && m_ai->CastSpell(PUMMEL, *pTarget))
-                return RETURN_CONTINUE;
-            if (SPELL_REFLECTION > 0 && !m_bot->HasAura(SPELL_REFLECTION, EFFECT_INDEX_0) && m_ai->CastSpell(SPELL_REFLECTION, *m_bot))
-                return RETURN_CONTINUE;
-        }
-
-        if (REVENGE > 0 && m_bot->IsSpellReady(REVENGE))
-        {
-            uint8 base = pTarget->RollMeleeOutcomeAgainst(m_bot, BASE_ATTACK, SPELL_SCHOOL_MASK_NORMAL);
-            uint8 off = pTarget->RollMeleeOutcomeAgainst(m_bot, OFF_ATTACK, SPELL_SCHOOL_MASK_NORMAL);
-            if (base == MELEE_HIT_PARRY || base == MELEE_HIT_DODGE || base == MELEE_HIT_BLOCK || off == MELEE_HIT_PARRY || off == MELEE_HIT_DODGE || off == MELEE_HIT_BLOCK)
-                if (m_ai->CastSpell(REVENGE, *pTarget))
-                    return RETURN_CONTINUE;
-        }
-        if (REND > 0 && !pTarget->HasAura(REND, EFFECT_INDEX_0) && m_ai->CastSpell(REND, *pTarget))
-            return RETURN_CONTINUE;
-        //Do not waste rage applying Sunder Armor if it is already stacked 5 times
-        if (SUNDER_ARMOR > 0)
-        {
-            if (!pTarget->HasAura(SUNDER_ARMOR) && m_ai->CastSpell(SUNDER_ARMOR, *pTarget))   // no stacks: cast it
-                return RETURN_CONTINUE;
-            else
-            {
-                SpellAuraHolder* holder = pTarget->GetSpellAuraHolder(SUNDER_ARMOR);
-                if (holder && (holder->GetStackAmount() < 5) && m_ai->CastSpell(SUNDER_ARMOR, *pTarget))
-                    return RETURN_CONTINUE;
-            }
-        }
-        if (DEMORALIZING_SHOUT > 0 && !pTarget->HasAura(DEMORALIZING_SHOUT, EFFECT_INDEX_0) && m_ai->CastSpell(DEMORALIZING_SHOUT, *pTarget))
-            return RETURN_CONTINUE;
-        // TODO: only cast disarm if target has equipment?
-        if (DISARM > 0 && !pTarget->HasAura(DISARM, EFFECT_INDEX_0) && m_ai->CastSpell(DISARM, *pTarget))
-            return RETURN_CONTINUE;
-        // check that target is dangerous (elite) before casting shield block: preserve bot cooldowns
-        if (SHIELD_BLOCK > 0 && m_ai->IsElite(pTarget) && !m_bot->HasAura(SHIELD_BLOCK, EFFECT_INDEX_0) && m_ai->CastSpell(SHIELD_BLOCK, *m_bot))
-            return RETURN_CONTINUE;
-        if (CONCUSSION_BLOW > 0 && m_bot->IsSpellReady(CONCUSSION_BLOW) && m_ai->CastSpell(CONCUSSION_BLOW, *pTarget))
-            return RETURN_CONTINUE;
-        if (SHOCKWAVE > 0 && m_bot->IsSpellReady(SHOCKWAVE) && m_ai->CastSpell(SHOCKWAVE, *pTarget))
-            return RETURN_CONTINUE;
-        if (SHIELD_SLAM > 0 && m_bot->IsSpellReady(SHIELD_SLAM) && m_ai->CastSpell(SHIELD_SLAM, *pTarget))
-            return RETURN_CONTINUE;
-        if (HEROIC_STRIKE > 0 && m_ai->CastSpell(HEROIC_STRIKE, *pTarget))
-            return RETURN_CONTINUE;
-    }
-
-    /*    case WarriorBattle:
-            if (SWEEPING_STRIKES > 0 && m_ai->GetAttackerCount() >= 2 && !m_bot->HasAura(SWEEPING_STRIKES, EFFECT_INDEX_0) && m_ai->CastSpell(SWEEPING_STRIKES, *m_bot))
-                return RETURN_CONTINUE;
-            if (INTIMIDATING_SHOUT > 0 && m_ai->GetAttackerCount() > 5 && m_ai->CastSpell(INTIMIDATING_SHOUT, *pTarget))
-                return RETURN_CONTINUE;
-            if (CHALLENGING_SHOUT > 0 && pVictim != m_bot && m_ai->GetHealthPercent() > 25 && !pTarget->HasAura(MOCKING_BLOW, EFFECT_INDEX_0) && !pTarget->HasAura(CHALLENGING_SHOUT, EFFECT_INDEX_0) && m_ai->CastSpell(CHALLENGING_SHOUT, *pTarget))
-                return RETURN_CONTINUE;
-            if (CLEAVE > 0 && m_ai->CastSpell(CLEAVE, *pTarget))
-                return RETURN_CONTINUE;
-            if (PIERCING_HOWL > 0 && && m_ai->GetAttackerCount() >= 3 && !pTarget->HasAura(WAR_STOMP, EFFECT_INDEX_0) && !pTarget->HasAura(PIERCING_HOWL, EFFECT_INDEX_0) && !pTarget->HasAura(SHOCKWAVE, EFFECT_INDEX_0) && !pTarget->HasAura(CONCUSSION_BLOW, EFFECT_INDEX_0) && m_ai->CastSpell(PIERCING_HOWL, *pTarget))
-                return RETURN_CONTINUE;
-            if (MOCKING_BLOW > 0 && pVictim != m_bot && m_ai->GetHealthPercent() > 25 && !pTarget->HasAura(MOCKING_BLOW, EFFECT_INDEX_0) && !pTarget->HasAura(CHALLENGING_SHOUT, EFFECT_INDEX_0) && m_ai->CastSpell(MOCKING_BLOW, *pTarget))
-                return RETURN_CONTINUE;
-            if (m_bot->getRace() == RACE_TAUREN && !pTarget->HasAura(WAR_STOMP, EFFECT_INDEX_0) && !pTarget->HasAura(PIERCING_HOWL, EFFECT_INDEX_0) && !pTarget->HasAura(SHOCKWAVE, EFFECT_INDEX_0) && !pTarget->HasAura(CONCUSSION_BLOW, EFFECT_INDEX_0) && m_ai->CastSpell(WAR_STOMP, *pTarget))
-                return RETURN_CONTINUE;
-            if (m_bot->getRace() == RACE_UNDEAD && m_bot->HasAuraType(SPELL_AURA_MOD_FEAR) || m_bot->HasAuraType(SPELL_AURA_MOD_CHARM) && m_ai->CastSpell(WILL_OF_THE_FORSAKEN, *m_bot))
-                return RETURN_CONTINUE;
-            if (m_bot->getRace() == RACE_DWARF && m_bot->HasAuraState(AURA_STATE_DEADLY_POISON) && m_ai->CastSpell(STONEFORM, *m_bot))
-                return RETURN_CONTINUE;
-            if (m_bot->getRace() == RACE_GNOME && m_bot->hasUnitState(UNIT_STAT_STUNNED) || m_bot->HasAuraType(SPELL_AURA_MOD_DECREASE_SPEED) && m_ai->CastSpell(ESCAPE_ARTIST, *m_bot))
-                return RETURN_CONTINUE;
-            if (m_bot->getRace() == RACE_ORC && !m_bot->HasAura(BLOOD_FURY, EFFECT_INDEX_0) && m_ai->CastSpell(BLOOD_FURY, *m_bot))
-                return RETURN_CONTINUE;
-            if (m_bot->getRace() == RACE_TROLL && !m_bot->HasAura(BERSERKING, EFFECT_INDEX_0) && m_ai->CastSpell(BERSERKING, *m_bot))
-                return RETURN_CONTINUE;
-            if (m_bot->getRace() == RACE_DRAENEI && m_ai->GetHealthPercent() < 25 && !m_bot->HasAura(GIFT_OF_THE_NAARU, EFFECT_INDEX_0) && m_ai->CastSpell(GIFT_OF_THE_NAARU, *m_bot))
-                return RETURN_CONTINUE;
-            break;
-
-        case WarriorDefensive:
-            if (DISARM > 0 && !pTarget->HasAura(DISARM, EFFECT_INDEX_0) && m_ai->CastSpell(DISARM, *pTarget))
-                return RETURN_CONTINUE;
-            if (SHIELD_BLOCK > 0 && !m_bot->HasAura(SHIELD_BLOCK, EFFECT_INDEX_0) && m_ai->CastSpell(SHIELD_BLOCK, *m_bot))
-                return RETURN_CONTINUE;
-            if (SHIELD_WALL > 0 && !m_bot->HasAura(SHIELD_WALL, EFFECT_INDEX_0) && m_ai->CastSpell(SHIELD_WALL, *m_bot))
-                return RETURN_CONTINUE;
-            break;*/
-
-    return RETURN_NO_ACTION_OK;
-}
-
-CombatManeuverReturns PlayerbotWarriorAI::DoNextCombatManeuverPVP(Unit* pTarget)
-{
-    if (m_ai->CastSpell(HEROIC_STRIKE))
-        return RETURN_CONTINUE;
-
-    return DoNextCombatManeuverPVE(pTarget); // TODO: bad idea perhaps, but better than the alternative
-}
-
-//Buff and rebuff shouts
-void PlayerbotWarriorAI::CheckShouts()
-{
-    if (!m_ai)  return;
-    if (!m_bot) return;
-
-    if (m_bot->GetSpec() == WARRIOR_SPEC_PROTECTION && COMMANDING_SHOUT > 0)
-    {
-        if (!m_bot->HasAura(COMMANDING_SHOUT, EFFECT_INDEX_0) && m_ai->CastSpell(COMMANDING_SHOUT))
-            return;
-    }
-    else // Not prot, or prot but no Commanding Shout yet
-    {
-        if (!m_bot->HasAura(BATTLE_SHOUT, EFFECT_INDEX_0) && m_ai->CastSpell(BATTLE_SHOUT))
-            return;
-    }
-}
-
-void PlayerbotWarriorAI::DoNonCombatActions()
-{
-    if (!m_ai)  return;
-    if (!m_bot) return;
-
-    uint32 spec = m_bot->GetSpec();
-
-    //Stance Check
-    if (spec == WARRIOR_SPEC_ARMS && !m_bot->HasAura(BATTLE_STANCE, EFFECT_INDEX_0))
-        m_ai->CastSpell(BATTLE_STANCE);
-    else if (spec == WARRIOR_SPEC_FURY && !m_bot->HasAura(BERSERKER_STANCE, EFFECT_INDEX_0))
-        m_ai->CastSpell(BERSERKER_STANCE);
-    else if (spec == WARRIOR_SPEC_PROTECTION && !m_bot->HasAura(DEFENSIVE_STANCE, EFFECT_INDEX_0))
-        m_ai->CastSpell(DEFENSIVE_STANCE);
-
-    // hp check
-    if (EatDrinkBandage(false))
-        return;
-
-    // Search and apply stones to weapons
-    // Mainhand ...
-    Item* stone, * weapon;
-    weapon = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
-    if (weapon && weapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT) == 0)
-    {
-        stone = m_ai->FindStoneFor(weapon);
-        if (stone)
-        {
-            m_ai->UseItem(stone, EQUIPMENT_SLOT_MAINHAND);
-            m_ai->SetIgnoreUpdateTime(5);
-        }
-    }
-    //... and offhand (we add a check to avoid trying to apply stone if the warrior is wielding a shield)
-    weapon = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
-    if (weapon && (weapon->GetProto()->InventoryType == INVTYPE_WEAPONOFFHAND || weapon->GetProto()->InventoryType == INVTYPE_WEAPONMAINHAND)
-            && weapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT) == 0)
-    {
-        stone = m_ai->FindStoneFor(weapon);
-        if (stone)
-        {
-            m_ai->UseItem(stone, EQUIPMENT_SLOT_OFFHAND);
-            m_ai->SetIgnoreUpdateTime(5);
-        }
-    }
-
-    // Nothing else to do, Night Elves will cast Shadowmeld to reduce their aggro versus patrols or nearby mobs
-    if (SHADOWMELD && !m_bot->HasAura(SHADOWMELD, EFFECT_INDEX_0) && m_ai->CastSpell(SHADOWMELD, *m_bot))
-        return;
-} // end DoNonCombatActions
-
-// Match up with "Pull()" below
-bool PlayerbotWarriorAI::CanPull()
-{
-    if (!m_bot) return false;
-    if (!m_ai) return false;
-
-    if (m_bot->GetUInt32Value(PLAYER_AMMO_ID)) // Having ammo equipped means a weapon is equipped as well. Probably. [TODO: does this work with throwing knives? Can a playerbot 'cheat' ammo into the slot without a proper weapon?]
-    {
-        // Can't do this, CanPull CANNOT check for anything that requires a target
-        //if (!m_ai->IsInRange(m_ai->GetCurrentTarget(), AUTO_SHOT))
-        //{
-        //    m_ai->TellMaster("I'm out of range.");
-        //    return false;
-        //}
-        return true;
-    }
-
-    return false;
-}
-
-// Match up with "CanPull()" above
-bool PlayerbotWarriorAI::Pull()
-{
-    if (!m_bot) return false;
-    if (!m_ai)  return false;
-
-    if (m_bot->GetDistance(m_ai->GetCurrentTarget(), true, DIST_CALC_COMBAT_REACH_WITH_MELEE) > ATTACK_DISTANCE)
-    {
-        if (!m_ai->In_Range(m_ai->GetCurrentTarget(), AUTO_SHOT))
-        {
-            m_ai->TellMaster("I'm out of range.");
-            return false;
-        }
-
-        // activate auto shot: Reworked to account for AUTO_SHOT being a triggered spell
-        if (AUTO_SHOT && m_ai->GetCurrentSpellId() != AUTO_SHOT)
-        {
-            m_ai->FaceTarget(m_ai->GetCurrentTarget());
-            m_bot->CastSpell(m_ai->GetCurrentTarget(), AUTO_SHOT, TRIGGERED_OLD_TRIGGERED);
-            return true;
-        }
-    }
-    else // target is in melee range
-    {
-        m_ai->Attack(m_ai->GetCurrentTarget());
-        return true;
-    }
-
-    return false;
-}
diff --git a/src/game/PlayerBot/AI/PlayerbotWarriorAI.h b/src/game/PlayerBot/AI/PlayerbotWarriorAI.h
deleted file mode 100644
index acff19866..000000000
--- a/src/game/PlayerBot/AI/PlayerbotWarriorAI.h
+++ /dev/null
@@ -1,182 +0,0 @@
-/*
- * This file is part of the CMaNGOS Project. See AUTHORS file for Copyright information
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _PlayerbotWarriorAI_H
-#define _PlayerbotWarriorAI_H
-
-#include "../Base/PlayerbotClassAI.h"
-
-enum
-{
-    WarriorSpellPreventing,
-    WarriorBattle,
-    WarriorDefensive,
-    WarriorBerserker
-};
-
-enum WarriorSpells
-{
-    AUTO_SHOT_2                     = 75,
-    BATTLE_SHOUT_1                  = 6673,
-    BATTLE_STANCE_1                 = 2457,
-    BERSERKER_RAGE_1                = 18499,
-    BERSERKER_STANCE_1              = 2458,
-    BLOODRAGE_1                     = 2687,
-    BLOODTHIRST_1                   = 23881,
-    CHALLENGING_SHOUT_1             = 1161,
-    CHARGE_1                        = 100,
-    CLEAVE_1                        = 845,
-    COMMANDING_SHOUT_1              = 469,
-    CONCUSSION_BLOW_1               = 12809,
-    DEATH_WISH_1                    = 12292,
-    DEFENSIVE_STANCE_1              = 71,
-    DEMORALIZING_SHOUT_1            = 1160,
-    DEVASTATE_1                     = 20243,
-    DISARM_1                        = 676,
-    EXECUTE_1                       = 5308,
-    HAMSTRING_1                     = 1715,
-    HEROIC_STRIKE_1                 = 78,
-    INTERCEPT_1                     = 20252,
-    INTERVENE_1                     = 3411,
-    INTIMIDATING_SHOUT_1            = 5246,
-    LAST_STAND_1                    = 12975,
-    MOCKING_BLOW_1                  = 694,
-    MORTAL_STRIKE_1                 = 12294,
-    OVERPOWER_1                     = 7384,
-    PIERCING_HOWL_1                 = 12323,
-    PUMMEL_1                        = 6552,
-    RECKLESSNESS_1                  = 1719,
-    REND_1                          = 772,
-    RETALIATION_1                   = 20230,
-    REVENGE_1                       = 6572,
-    SHIELD_BASH_1                   = 72,
-    SHIELD_BLOCK_1                  = 2565,
-    SHIELD_SLAM_1                   = 23922,
-    SHIELD_WALL_1                   = 871,
-    SHOCKWAVE_1                     = 46968,
-    SLAM_1                          = 1464,
-    SPELL_REFLECTION_1              = 23920,
-    SUNDER_ARMOR_1                  = 7386,
-    SWEEPING_STRIKES_1              = 12328,
-    TAUNT_1                         = 355,
-    THUNDER_CLAP_1                  = 6343,
-    VICTORY_RUSH_1                  = 34428,
-    WHIRLWIND_1                     = 1680,
-
-    //Procs
-};
-
-//class Player;
-
-class PlayerbotWarriorAI : PlayerbotClassAI
-{
-    public:
-        PlayerbotWarriorAI(Player* const master, Player* const bot, PlayerbotAI* const ai);
-        virtual ~PlayerbotWarriorAI();
-
-        // all combat actions go here
-        CombatManeuverReturns DoFirstCombatManeuver(Unit* pTarget);
-        CombatManeuverReturns DoNextCombatManeuver(Unit* pTarget);
-        bool Pull();
-
-        // all non combat actions go here, ex buffs, heals, rezzes
-        void DoNonCombatActions();
-
-        //Buff/rebuff shouts
-        void CheckShouts();
-
-        // Utility Functions
-        bool CanPull();
-
-    private:
-        CombatManeuverReturns DoFirstCombatManeuverPVE(Unit* pTarget);
-        CombatManeuverReturns DoNextCombatManeuverPVE(Unit* pTarget);
-        CombatManeuverReturns DoFirstCombatManeuverPVP(Unit* pTarget);
-        CombatManeuverReturns DoNextCombatManeuverPVP(Unit* pTarget);
-
-        // ARMS
-        uint32 BATTLE_STANCE,
-               CHARGE,
-               HEROIC_STRIKE,
-               REND,
-               THUNDER_CLAP,
-               HAMSTRING,
-               MOCKING_BLOW,
-               RETALIATION,
-               SWEEPING_STRIKES,
-               MORTAL_STRIKE,
-               TASTE_FOR_BLOOD,
-               SUDDEN_DEATH;
-
-        // PROTECTION
-        uint32 DEFENSIVE_STANCE,
-               BLOODRAGE,
-               SUNDER_ARMOR,
-               TAUNT,
-               SHIELD_BASH,
-               REVENGE,
-               SHIELD_BLOCK,
-               DISARM,
-               SHIELD_WALL,
-               SHIELD_SLAM,
-               DEVASTATE,
-               SHOCKWAVE,
-               CONCUSSION_BLOW,
-               SPELL_REFLECTION,
-               LAST_STAND;
-
-        // FURY
-        uint32 BERSERKER_STANCE,
-               BATTLE_SHOUT,
-               DEMORALIZING_SHOUT,
-               OVERPOWER,
-               CLEAVE,
-               INTIMIDATING_SHOUT,
-               EXECUTE,
-               CHALLENGING_SHOUT,
-               SLAM,
-               INTERCEPT,
-               DEATH_WISH,
-               BERSERKER_RAGE,
-               WHIRLWIND,
-               PUMMEL,
-               BLOODTHIRST,
-               RECKLESSNESS,
-               RAMPAGE,
-               COMMANDING_SHOUT,
-               PIERCING_HOWL;
-
-        // racial
-        uint32 ARCANE_TORRENT,
-               GIFT_OF_THE_NAARU,
-               STONEFORM,
-               ESCAPE_ARTIST,
-               PERCEPTION,
-               SHADOWMELD,
-               BLOOD_FURY,
-               WAR_STOMP,
-               BERSERKING,
-               WILL_OF_THE_FORSAKEN;
-
-        // general
-        uint32 AUTO_SHOT;
-
-        uint32 SpellSequence;
-};
-
-#endif
diff --git a/src/game/PlayerBot/Base/PlayerbotAI.cpp b/src/game/PlayerBot/Base/PlayerbotAI.cpp
deleted file mode 100644
index 7b00d44b9..000000000
--- a/src/game/PlayerBot/Base/PlayerbotAI.cpp
+++ /dev/null
@@ -1,11460 +0,0 @@
-/*
- * This file is part of the CMaNGOS Project. See AUTHORS file for Copyright information
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include <stdarg.h>
-#include "Common.h"
-#include "Log.h"
-#include "WorldPacket.h"
-#include "Database/DatabaseEnv.h"
-#include "PlayerbotAI.h"
-#include "PlayerbotMgr.h"
-#include "ProgressBar.h"
-
-#include "../../AuctionHouse/AuctionHouseMgr.h"
-#include "../../Chat/Chat.h"
-#include "../../Entities/GossipDef.h"
-#include "../../Entities/ItemPrototype.h"
-#include "../../Entities/Player.h"
-#include "../../Entities/Unit.h"
-#include "../../Globals/SharedDefines.h"
-#include "../../Globals/ObjectMgr.h"
-
-#include "../../Grids/GridNotifiers.h"
-#include "../../Grids/GridNotifiersImpl.h"
-#include "../../Grids/CellImpl.h"
-#include "../../Guilds/Guild.h"
-#include "../../Guilds/GuildMgr.h"
-#include "../../Loot/LootMgr.h"
-#include "../../Mails/Mail.h"
-#include "../../MotionGenerators/MotionMaster.h"
-#include "../../Spells/Spell.h"
-#include "../../Spells/SpellAuras.h"
-#include "../../Spells/SpellMgr.h"
-#include "../../Tools/Language.h"
-#include "../../World/World.h"
-
-#include "../AI/PlayerbotDruidAI.h"
-#include "../AI/PlayerbotHunterAI.h"
-#include "../AI/PlayerbotMageAI.h"
-#include "../AI/PlayerbotPaladinAI.h"
-#include "../AI/PlayerbotPriestAI.h"
-#include "../AI/PlayerbotRogueAI.h"
-#include "../AI/PlayerbotShamanAI.h"
-#include "../AI/PlayerbotWarlockAI.h"
-#include "../AI/PlayerbotWarriorAI.h"
-
-#include <iomanip>
-#include <iostream>
-
-// returns a float in range of..
-float rand_float(float low, float high)
-{
-    return (rand() / (static_cast<float>(RAND_MAX) + 1.0)) * (high - low) + low;
-}
-
-enum NPCFlags VENDOR_MASK = (enum NPCFlags)(UNIT_NPC_FLAG_VENDOR
-                            | UNIT_NPC_FLAG_VENDOR_AMMO
-                            | UNIT_NPC_FLAG_VENDOR_FOOD
-                            | UNIT_NPC_FLAG_VENDOR_POISON
-                            | UNIT_NPC_FLAG_VENDOR_REAGENT);
-
-// ChatHandler already implements some useful commands the master can call on bots
-// These commands are protected inside the ChatHandler class so this class provides access to the commands
-// we'd like to call on our bots
-class PlayerbotChatHandler : protected ChatHandler
-{
-    public:
-        explicit PlayerbotChatHandler(Player* pMasterPlayer) : ChatHandler(pMasterPlayer) {}
-        bool revive(Player& botPlayer) { return HandleReviveCommand((char*) botPlayer.GetName()); }
-        bool teleport(Player& botPlayer) { return HandleNamegoCommand((char*) botPlayer.GetName()); }
-        void sysmessage(const char* str) { SendSysMessage(str); }
-        bool dropQuest(char* str) { return HandleQuestRemoveCommand(str); }
-};
-
-PlayerbotAI::PlayerbotAI(PlayerbotMgr* const mgr, Player* const bot) :
-    m_mgr(mgr), m_bot(bot), m_classAI(0), m_ignoreAIUpdatesUntilTime(CurrentTime()),
-    m_combatOrder(ORDERS_NONE), m_ScenarioType(SCENARIO_PVE),
-    m_TimeDoneEating(0), m_TimeDoneDrinking(0),
-    m_CurrentlyCastingSpellId(0), m_CraftSpellId(0), m_spellIdCommand(0),
-    m_targetGuidCommand(ObjectGuid()),
-    m_taxiMaster(ObjectGuid()),
-    m_AutoEquipToggle(false),
-    m_bDebugCommandChat(false)
-{
-    // set bot state
-    m_botState = BOTSTATE_NORMAL;
-
-    // reset some pointers
-    m_targetChanged = false;
-    m_targetType = TARGET_NORMAL;
-    m_targetCombat = 0;
-    m_targetAssist = 0;
-    m_targetProtect = 0;
-
-    // set collection options
-    m_collectionFlags = 0;
-    m_collectDist = m_mgr->m_confCollectDistance;
-    if (m_mgr->m_confCollectCombat)
-        SetCollectFlag(COLLECT_FLAG_COMBAT);
-    if (m_mgr->m_confCollectQuest)
-        SetCollectFlag(COLLECT_FLAG_QUEST);
-    if (m_mgr->m_confCollectProfession)
-        SetCollectFlag(COLLECT_FLAG_PROFESSION);
-    if (m_mgr->m_confCollectLoot)
-        SetCollectFlag(COLLECT_FLAG_LOOT);
-    if (m_mgr->m_confCollectSkin && m_bot->HasSkill(SKILL_SKINNING))
-        SetCollectFlag(COLLECT_FLAG_SKIN);
-    if (m_mgr->m_confCollectObjects)
-        SetCollectFlag(COLLECT_FLAG_NEAROBJECT);
-
-    // set needed item list
-    SetQuestNeedItems();
-    SetQuestNeedCreatures();
-
-    // start following master (will also teleport bot to master)
-    m_FollowAutoGo = FOLLOWAUTOGO_OFF; //turn on bot auto follow distance can be turned off by player
-    DistOverRide = 0; //set initial adjustable follow settings
-    IsUpOrDown = 0;
-    gTempDist = 0.5f;
-    gTempDist2 = 1.0f;
-    SetMovementOrder(MOVEMENT_FOLLOW, GetMaster());
-    BotDataRestore();
-    m_DelayAttackInit = CurrentTime();
-
-    // get class specific ai
-    ReloadAI();
-}
-
-PlayerbotAI::~PlayerbotAI()
-{
-    if (m_classAI) delete m_classAI;
-}
-
-Player* PlayerbotAI::GetMaster() const
-{
-    return m_mgr->GetMaster();
-}
-
-bool PlayerbotAI::CanReachWithSpellAttack(Unit* target)
-{
-    bool inrange = false;
-    float dist = m_bot->GetDistance(target, true, DIST_CALC_COMBAT_REACH_WITH_MELEE);
-
-    for (SpellRanges::iterator itr = m_spellRangeMap.begin(); itr != m_spellRangeMap.end(); ++itr)
-    {
-        uint32 spellId = itr->first;
-
-        // ignore positive spells
-        if (IsPositiveSpell(spellId))
-            continue;
-
-        // ignore active auras
-        if (target->HasAura(spellId, EFFECT_INDEX_0))
-            continue;
-
-        const SpellEntry* spellInfo = sSpellTemplate.LookupEntry<SpellEntry>(spellId);
-        if (!spellInfo)
-            continue;
-
-        // ignore non-ranged spells
-        if (!spellInfo->HasAttribute(SPELL_ATTR_RANGED))
-            continue;
-
-        float maxrange = itr->second;
-
-        // DEBUG_LOG("[%s] spell (%s) : dist (%f) < maxrange (%f)",m_bot->GetName(), spellInfo->SpellName[0], dist, maxrange);
-
-        if (dist < maxrange)
-        {
-            inrange = true;
-            break;
-        }
-    }
-    return inrange;
-}
-
-bool PlayerbotAI::In_Reach(Unit* Target, uint32 spellId)
-{
-    if (!Target)
-        return false;
-
-    float range = 0;
-    float dist = m_bot->GetDistance(Target, true, DIST_CALC_COMBAT_REACH_WITH_MELEE);
-    SpellRanges::iterator it;
-    it = m_spellRangeMap.find(spellId);
-    (it != m_spellRangeMap.end()) ? range = it->second : range = 0;
-
-    // DEBUG_LOG("spell (%u) : range (%f)", spellId, range);
-
-    if (dist > range)
-        return false;
-
-    return true;
-}
-
-// finds spell ID for matching substring args
-// in priority of full text match, spells not taking reagents, and highest rank
-uint32 PlayerbotAI::getSpellId(const char* args, bool master) const
-{
-    if (!*args)
-        return 0;
-
-    std::string namepart = args;
-    std::wstring wnamepart;
-
-    if (!Utf8toWStr(namepart, wnamepart))
-        return 0;
-
-    // converting string that we try to find to lower case
-    wstrToLower(wnamepart);
-
-    int loc = 0;
-    if (master)
-        loc = GetMaster()->GetSession()->GetSessionDbcLocale();
-    else
-        loc = m_bot->GetSession()->GetSessionDbcLocale();
-
-    uint32 foundSpellId = 0;
-    bool foundExactMatch = false;
-    bool foundMatchUsesNoReagents = false;
-
-    for (PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
-    {
-        uint32 spellId = itr->first;
-
-        if (itr->second.state == PLAYERSPELL_REMOVED || itr->second.disabled || IsPassiveSpell(spellId))
-            continue;
-
-        const SpellEntry* pSpellInfo = sSpellTemplate.LookupEntry<SpellEntry>(spellId);
-        if (!pSpellInfo)
-            continue;
-
-        const std::string name = pSpellInfo->SpellName[loc];
-        if (name.empty() || !Utf8FitTo(name, wnamepart))
-            continue;
-
-        bool isExactMatch = (name.length() == wnamepart.length()) ? true : false;
-        bool usesNoReagents = (pSpellInfo->Reagent[0] <= 0) ? true : false;
-
-        // if we already found a spell
-        bool useThisSpell = true;
-        if (foundSpellId > 0)
-        {
-            if (isExactMatch && !foundExactMatch) {}
-            else if (usesNoReagents && !foundMatchUsesNoReagents) {}
-            else if (spellId > foundSpellId) {}
-            else
-                useThisSpell = false;
-        }
-        if (useThisSpell)
-        {
-            foundSpellId = spellId;
-            foundExactMatch = isExactMatch;
-            foundMatchUsesNoReagents = usesNoReagents;
-        }
-    }
-
-    return foundSpellId;
-}
-
-
-uint32 PlayerbotAI::getPetSpellId(const char* args) const
-{
-    if (!*args)
-        return 0;
-
-    Pet* pet = m_bot->GetPet();
-    if (!pet)
-        return 0;
-
-    std::string namepart = args;
-    std::wstring wnamepart;
-
-    if (!Utf8toWStr(namepart, wnamepart))
-        return 0;
-
-    // converting string that we try to find to lower case
-    wstrToLower(wnamepart);
-
-    int loc = GetMaster()->GetSession()->GetSessionDbcLocale();
-
-    uint32 foundSpellId = 0;
-    bool foundExactMatch = false;
-    bool foundMatchUsesNoReagents = false;
-
-    for (PetSpellMap::iterator itr = pet->m_spells.begin(); itr != pet->m_spells.end(); ++itr)
-    {
-        uint32 spellId = itr->first;
-
-        if (itr->second.state == PETSPELL_REMOVED || IsPassiveSpell(spellId))
-            continue;
-
-        const SpellEntry* pSpellInfo = sSpellTemplate.LookupEntry<SpellEntry>(spellId);
-        if (!pSpellInfo)
-            continue;
-
-        const std::string name = pSpellInfo->SpellName[loc];
-        if (name.empty() || !Utf8FitTo(name, wnamepart))
-            continue;
-
-        bool isExactMatch = (name.length() == wnamepart.length()) ? true : false;
-        bool usesNoReagents = (pSpellInfo->Reagent[0] <= 0) ? true : false;
-
-        // if we already found a spell
-        bool useThisSpell = true;
-        if (foundSpellId > 0)
-        {
-            if (isExactMatch && !foundExactMatch) {}
-            else if (usesNoReagents && !foundMatchUsesNoReagents) {}
-            else if (spellId > foundSpellId) {}
-            else
-                useThisSpell = false;
-        }
-        if (useThisSpell)
-        {
-            foundSpellId = spellId;
-            foundExactMatch = isExactMatch;
-            foundMatchUsesNoReagents = usesNoReagents;
-        }
-    }
-
-    return foundSpellId;
-}
-
-
-uint32 PlayerbotAI::initSpell(uint32 spellId)
-{
-    // Check if bot knows this spell
-    if (!m_bot->HasSpell(spellId))
-        return 0;
-
-    uint32 next = 0;
-    SpellChainMapNext const& nextMap = sSpellMgr.GetSpellChainNext();
-    for (SpellChainMapNext::const_iterator itr = nextMap.lower_bound(spellId); itr != nextMap.upper_bound(spellId); ++itr)
-    {
-        SpellChainNode const* node = sSpellMgr.GetSpellChainNode(itr->second);
-        // If next spell is a requirement for this one then skip it
-        if (node->req == spellId)
-            continue;
-        if (node->prev == spellId)
-        {
-            next = initSpell(itr->second);
-            break;
-        }
-    }
-    if (next == 0)
-    {
-        const SpellEntry* const pSpellInfo = sSpellTemplate.LookupEntry<SpellEntry>(spellId);
-        if (!pSpellInfo)
-            return spellId;
-
-        DEBUG_LOG("[PlayerbotAI]: initSpell - Playerbot spell init: %s is %u", pSpellInfo->SpellName[0], spellId);
-
-        // Add spell to spellrange map
-        Spell* spell = new Spell(m_bot, pSpellInfo, false);
-        SpellRangeEntry const* srange = sSpellRangeStore.LookupEntry(pSpellInfo->rangeIndex);
-        float range = GetSpellMaxRange(srange);
-        if (Player* modOwner = m_bot->GetSpellModOwner())
-            modOwner->ApplySpellMod(pSpellInfo->Id, SPELLMOD_RANGE, range, spell);
-        m_spellRangeMap.insert(std::pair<uint32, float>(spellId, range));
-        delete spell;
-    }
-    return (next == 0) ? spellId : next;
-}
-
-
-// Pet spells do not form chains like player spells.
-// One of the options to initialize a spell is to use spell icon id
-uint32 PlayerbotAI::initPetSpell(uint32 spellIconId)
-{
-    Pet* pet = m_bot->GetPet();
-
-    if (!pet)
-        return 0;
-
-    for (PetSpellMap::iterator itr = pet->m_spells.begin(); itr != pet->m_spells.end(); ++itr)
-    {
-        const uint32 spellId = itr->first;
-
-        if (itr->second.state == PETSPELL_REMOVED || IsPassiveSpell(spellId))
-            continue;
-
-        const SpellEntry* const pSpellInfo = sSpellTemplate.LookupEntry<SpellEntry>(spellId);
-        if (!pSpellInfo)
-            continue;
-
-        if (pSpellInfo->SpellIconID == spellIconId)
-            return spellId;
-    }
-
-    // Nothing found
-    return 0;
-}
-
-/*
-* Send list of the equipment in bot's inventory not currently equipped.
-* This is called when the master is inspecting the bot.
-*/
-void PlayerbotAI::SendNotEquipList(Player& /*player*/)
-{
-    // find all unequipped items and put them in
-    // a vector of dynamically created lists where the vector index is from 0-18
-    // and the list contains Item* that can be equipped to that slot
-    // Note: each dynamically created list in the vector must be deleted at end
-    // so NO EARLY RETURNS!
-    // see enum EquipmentSlots in Player.h to see what equipment slot each index in vector
-    // is assigned to. (The first is EQUIPMENT_SLOT_HEAD=0, and last is EQUIPMENT_SLOT_TABARD=18)
-    std::list<Item*>* equip[19];
-    for (uint8 i = 0; i < 19; ++i)
-        equip[i] = nullptr;
-
-    // list out items in main backpack
-    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
-    {
-        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
-        if (!pItem)
-            continue;
-
-        uint16 dest;
-        InventoryResult msg = m_bot->CanEquipItem(NULL_SLOT, dest, pItem, !pItem->IsBag());
-        if (msg != EQUIP_ERR_OK)
-            continue;
-
-        // the dest looks like it includes the old loc in the 8 higher bits
-        // so casting it to a uint8 strips them
-        int8 equipSlot = uint8(dest);
-        if (!(equipSlot >= 0 && equipSlot < 19))
-            continue;
-
-        // create a list if one doesn't already exist
-        if (equip[equipSlot] == nullptr)
-            equip[equipSlot] = new std::list<Item*>;
-
-        std::list<Item*>* itemListForEqSlot = equip[equipSlot];
-        itemListForEqSlot->push_back(pItem);
-    }
-
-    // list out items in other removable backpacks
-    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
-    {
-        const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
-        if (pBag)
-            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
-            {
-                Item* const pItem = m_bot->GetItemByPos(bag, slot);
-                if (!pItem)
-                    continue;
-
-                uint16 dest;
-                InventoryResult msg = m_bot->CanEquipItem(NULL_SLOT, dest, pItem, !pItem->IsBag());
-                if (msg != EQUIP_ERR_OK)
-                    continue;
-
-                int8 equipSlot = uint8(dest);
-                if (!(equipSlot >= 0 && equipSlot < 19))
-                    continue;
-
-                // create a list if one doesn't already exist
-                if (equip[equipSlot] == nullptr)
-                    equip[equipSlot] = new std::list<Item*>;
-
-                std::list<Item*>* itemListForEqSlot = equip[equipSlot];
-                itemListForEqSlot->push_back(pItem);
-            }
-    }
-
-    TellMaster("Here's all the items in my inventory that I can equip.");
-    ChatHandler ch(GetMaster());
-
-    const std::string descr[] = { "head", "neck", "shoulders", "body", "chest",
-                                  "waist", "legs", "feet", "wrists", "hands", "finger1", "finger2",
-                                  "trinket1", "trinket2", "back", "mainhand", "offhand", "ranged",
-                                  "tabard"
-                                };
-
-    // now send client all items that can be equipped by slot
-    for (uint8 equipSlot = 0; equipSlot < 19; ++equipSlot)
-    {
-        if (equip[equipSlot] == nullptr)
-            continue;
-        std::list<Item*>* itemListForEqSlot = equip[equipSlot];
-        std::ostringstream out;
-        out << descr[equipSlot] << ": ";
-        for (std::list<Item*>::iterator it = itemListForEqSlot->begin(); it != itemListForEqSlot->end(); ++it)
-            if ((*it))
-                MakeItemLink((*it), out, true);
-        ch.SendSysMessage(out.str().c_str());
-
-        delete itemListForEqSlot; // delete list of Item*
-    }
-}
-
-void PlayerbotAI::FollowAutoReset()
-{
-    if (m_FollowAutoGo != FOLLOWAUTOGO_OFF)
-    {
-        m_FollowAutoGo = FOLLOWAUTOGO_RESET;
-        SetMovementOrder(MOVEMENT_FOLLOW, GetMaster());
-        WorldObject* distTarget = m_followTarget;
-        for (uint8 i = 0; i < 1; ++i)
-        {
-            if (m_bot->GetDistance(distTarget) < 3.0f)
-                i = 1;
-            else
-                i = 0;
-        }
-    }
-}
-
-void PlayerbotAI::AutoUpgradeEquipment() // test for autoequip
-{
-    if (!m_AutoEquipToggle)
-        return;
-
-    ChatHandler ch(GetMaster());
-    std::ostringstream out;
-    std::ostringstream msg;
-
-    // Find equippable items in main backpack one at a time
-    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
-    {
-        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
-
-        if (!pItem)
-            continue;
-
-        uint32 spellId = 0;
-
-        for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
-        {
-            if (pItem->GetProto()->Spells[i].SpellId > 0)
-            {
-                spellId = pItem->GetProto()->Spells[i].SpellId;
-                break;
-            }
-        }
-
-        if (pItem->GetProto()->Flags & ITEM_FLAG_HAS_LOOT && spellId == 0)
-        {
-            std::string oops = "Oh... Look! Theres something inside!!!";
-            m_bot->Say(oops, LANG_UNIVERSAL);
-            UseItem(pItem);
-            continue;
-        }
-
-        if (uint32 questid = pItem->GetProto()->StartQuest)
-        {
-            Quest const* qInfo = sObjectMgr.GetQuestTemplate(questid);
-            if (m_bot->GetQuestStatus(questid) == QUEST_STATUS_COMPLETE)
-                continue;
-            else if (!m_bot->CanTakeQuest(qInfo, false))
-            {
-                std::string oops = "Great, more junk... Can I get rid of this please?";
-                m_bot->Say(oops, LANG_UNIVERSAL);
-                continue;
-            }
-
-            UseItem(pItem);
-        }
-
-        uint16 equipSlot;
-        InventoryResult msg = m_bot->CanEquipItem(NULL_SLOT, equipSlot, pItem, !pItem->IsBag());
-        if (msg != EQUIP_ERR_OK)
-            continue;
-
-        // do we have anything equipped of this type?
-        Item* const pItem2 = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, (uint8)equipSlot);
-        if (!pItem2) // no item to compare to see if has stats useful for this bots class/style so check for stats and equip if possible
-        {
-            ItemPrototype const* pProto2 = pItem->GetProto();
-            if (ItemStatsCount(pProto2) > 0)
-            {
-                if (!ItemStatComparison(pProto2, pProto2))
-                    continue;
-            }
-            EquipItem(pItem); // no item equipped so equip new one and go to next item.
-            continue;
-        }
-
-        // we have an equippable item, so lets send it to the comparison function to see if it's better than we have on
-        AutoEquipComparison(pItem, pItem2); // pItem is new item, pItem2 is equipped item.
-    }
-
-    // list out items in other removable backpacks
-    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
-    {
-        const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
-        if (pBag)
-            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
-            {
-                Item* const pItem = m_bot->GetItemByPos(bag, slot);
-                if (!pItem)
-                    continue;
-
-                uint16 dest;
-                InventoryResult msg = m_bot->CanEquipItem(NULL_SLOT, dest, pItem, !pItem->IsBag());
-                if (msg != EQUIP_ERR_OK)
-                    continue;
-
-                uint8 equipSlot = uint8(dest);
-                Item* const pItem2 = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, equipSlot); // do we have anything equipped of this type?
-                if (!pItem2)
-                {
-                    ItemPrototype const* pProto2 = pItem->GetProto();
-                    if (ItemStatsCount(pProto2) > 0)
-                    {
-                        if (!ItemStatComparison(pProto2, pProto2))
-                            continue;
-                    }
-
-                    EquipItem(pItem); //no item equipped so equip new one if useable stats and go to next item.
-                    continue;
-                }
-
-                // we have an equippable item but something else is equipped so lets send it to the comparison function to see if it's better than we have on
-                AutoEquipComparison(pItem, pItem2); //pItem is new item, pItem2 is equipped item.
-            }
-    }
-}
-
-uint32 PlayerbotAI::ItemStatsCount(ItemPrototype const* proto)
-{
-    uint32 count = 0;
-
-    for (int i = 0; i < MAX_ITEM_PROTO_STATS; ++i)
-        if (proto && (proto->ItemStat[i].ItemStatType || proto->ItemStat[i].ItemStatValue))
-            count++;
-
-    return count;
-}
-
-float PlayerbotAI::getItemDPS(ItemPrototype const* proto) const
-{
-    if (proto->Delay == 0)
-        return 0;
-    float temp = 0;
-    for (int i = 0; i < MAX_ITEM_PROTO_DAMAGES; ++i)
-        temp += proto->Damage[i].DamageMin + proto->Damage[i].DamageMax;
-    return temp * 500 / proto->Delay;
-}
-
-void PlayerbotAI::AutoEquipComparison(Item* pItem, Item* pItem2)
-{
-    const static uint32 item_armor_skills[MAX_ITEM_SUBCLASS_ARMOR] =
-    {
-        0, SKILL_CLOTH, SKILL_LEATHER, SKILL_MAIL, SKILL_PLATE_MAIL, 0, SKILL_SHIELD, 0, 0, 0
-    };
-    ItemPrototype const* pProto = pItem2->GetProto(); // equipped item if any
-    ItemPrototype const* pProto2 = pItem->GetProto(); // new item to compare
-    // DEBUG_LOG("Item Class (%s)",(pProto->Class == ITEM_CLASS_WEAPON ? "Weapon" : "Not Weapon"));
-    switch (pProto->Class)
-    {
-        case ITEM_CLASS_WEAPON:
-        {
-            // DEBUG_LOG("Current Item DPS (%f) Equippable Item DPS (%f)",getItemDPS(pProto),getItemDPS(pProto2));
-            // m_bot->GetSkillValue(pProto->RequiredSkill) < m_bot->GetSkillValue(pProto2->RequiredSkill)
-            if (getItemDPS(pProto) < getItemDPS(pProto2))   // if new item has a better DPS
-            {
-                EquipItem(pItem);
-                pProto = pProto2; // ensure that the item with the highest DPS is equipped
-            }
-            break;
-        }
-        case ITEM_CLASS_ARMOR:
-        {
-            // now in case they are same itemlevel, but one is better than the other..
-            if (pProto->ItemLevel == pProto2->ItemLevel && pProto->Quality < pProto2->Quality && pProto->Armor <= pProto2->Armor &&
-                    m_bot->HasSkill(item_armor_skills[pProto2->SubClass]) && !m_bot->HasSkill(item_armor_skills[pProto2->SubClass + 1])) // itemlevel + armour + armour class
-            {
-                // First check to see if this item has stats, and if the bot REALLY wants to lose its old item
-                if (ItemStatsCount(pProto2) > 0)
-                {
-                    if (!ItemStatComparison(pProto, pProto2))
-                        return; // stats on equipped item are better, OR stats are not useful for this bots class/style
-                }
-                EquipItem(pItem);
-                break;
-            }
-            if (pProto->ItemLevel <= pProto2->ItemLevel && pProto->Quality < pProto2->Quality && pProto->Armor > pProto2->Armor &&
-                    m_bot->HasSkill(item_armor_skills[pProto2->SubClass]) && !m_bot->HasSkill(item_armor_skills[pProto2->SubClass + 1])) // itemlevel + armour + armour class
-            {
-                // First check to see if this item has stats, and if the bot REALLY wants to lose its old item
-                if (ItemStatsCount(pProto2) > 0)
-                {
-                    if (!ItemStatComparison(pProto, pProto2))
-                        return; // stats on equipped item are better, OR stats are not useful for this bots class/style
-                }
-                EquipItem(pItem);
-                break;
-            }
-            if (pProto->ItemLevel <= pProto2->ItemLevel && pProto->Armor <= pProto2->Armor && m_bot->HasSkill(item_armor_skills[pProto2->SubClass]) &&
-                    !m_bot->HasSkill(item_armor_skills[pProto2->SubClass + 1])) // itemlevel + armour + armour class
-            {
-                // First check to see if this item has stats, and if the bot REALLY wants to lose its old item
-                if (ItemStatsCount(pProto2) > 0)
-                {
-                    if (!ItemStatComparison(pProto, pProto2))
-                        return; // stats on equipped item are better, OR stats are not useful for this bots class/style
-                }
-                EquipItem(pItem);
-                break;
-            }
-        }
-    }
-}
-
-bool PlayerbotAI::ItemStatComparison(const ItemPrototype* pProto, const ItemPrototype* pProto2)
-{
-    uint8 isclass = 0; // 1= caster 2 = hybrid 3 = melee
-    uint8 ishybrid = 0;
-    uint8 olditemscore = 0;
-    uint8 newitemscore = 0;
-    // get class and style to make it easier to compare later
-    switch (m_bot->getClass())
-    {
-        case CLASS_PRIEST:
-        case CLASS_MAGE:
-        case CLASS_WARLOCK:
-            isclass = 1;
-            break;
-
-        case CLASS_PALADIN:
-        case CLASS_SHAMAN:
-        case CLASS_DRUID:
-            isclass = 2;
-            ishybrid = 1;
-            break;
-
-        case CLASS_WARRIOR:
-        case CLASS_ROGUE:
-            isclass = 3; // melee
-            break;
-
-        case CLASS_HUNTER:
-            isclass = 2;
-            ishybrid = 2;
-            break;
-    }
-
-    for (int i = 0; i < MAX_ITEM_PROTO_STATS; ++i) // item can only have 10 stats. We check each stat slot available for stat and type.
-    {
-        uint32 itemmod = pProto->ItemStat[i].ItemStatType; // equipped item stats if any
-        uint32 itemmod2 = pProto2->ItemStat[i].ItemStatType; // newitem stats
-        if (!itemmod) // if no stat type in this slot, continue to next slot
-        {
-            if (!itemmod2)
-                continue;
-        }
-        // caster stats
-        if (itemmod == ITEM_MOD_MANA || itemmod == ITEM_MOD_INTELLECT || itemmod == ITEM_MOD_SPIRIT || itemmod == ITEM_MOD_HIT_SPELL_RATING ||
-                itemmod == ITEM_MOD_CRIT_SPELL_RATING || itemmod == ITEM_MOD_HASTE_SPELL_RATING ||
-                itemmod2 == ITEM_MOD_MANA || itemmod2 == ITEM_MOD_INTELLECT || itemmod2 == ITEM_MOD_SPIRIT || itemmod2 == ITEM_MOD_HIT_SPELL_RATING ||
-                itemmod2 == ITEM_MOD_CRIT_SPELL_RATING || itemmod2 == ITEM_MOD_HASTE_SPELL_RATING)
-        {
-            switch (isclass) // 1 caster, 2 hybrid, 3 melee
-            {
-                case 1:
-                {
-                    uint32 itemmodval = pProto->ItemStat[i].ItemStatValue; // equipped item stats if any
-                    uint32 itemmodval2 = pProto2->ItemStat[i].ItemStatValue;  // newitem stats
-                    if (itemmod == itemmod2) //same stat type
-                    {
-                        if (pProto == pProto2) // same item
-                        {
-                            if (olditemscore > 0)
-                                olditemscore = (olditemscore - 1);
-                            newitemscore = (newitemscore + 1);
-                        }
-                        if (itemmodval < itemmodval2) // which one has the most
-                        {
-                            if (olditemscore > 0)
-                                olditemscore = (olditemscore - 1);
-                            newitemscore = (newitemscore + 1);
-                        }
-                        else if (itemmodval > itemmodval2)
-                        {
-                            if (newitemscore > 0)
-                                newitemscore = (newitemscore - 1);
-                            olditemscore = (olditemscore + 1);
-                        }
-                    }
-                    else
-                    {
-                        if (itemmod > 0)
-                            olditemscore = (olditemscore + 1);
-                        if (itemmod2 > 0)
-                            newitemscore = (newitemscore + 1);
-                    }
-                    break;
-                }
-                case 2:
-                {
-                    uint32 itemmodval = pProto->ItemStat[i].ItemStatValue; // equipped item stats if any
-                    uint32 itemmodval2 = pProto2->ItemStat[i].ItemStatValue;  // newitem stats
-                    if (ishybrid != 2) //not a hunter
-                    {
-                        if (itemmod == itemmod2) //same stat type
-                        {
-                            if (pProto == pProto2) // same item
-                            {
-                                if (olditemscore > 0)
-                                    olditemscore = (olditemscore - 1);
-                                newitemscore = (newitemscore + 1);
-                            }
-                            if (itemmodval < itemmodval2) // which one has the most
-                            {
-                                if (olditemscore > 0)
-                                    olditemscore = (olditemscore - 1);
-                                newitemscore = (newitemscore + 1);
-                            }
-                            else if (itemmodval > itemmodval2)
-                            {
-                                if (newitemscore > 0)
-                                    newitemscore = (newitemscore - 1);
-                                olditemscore = (olditemscore + 1);
-                            }
-                        }
-                        else
-                        {
-                            if (itemmod > 0)
-                                olditemscore = (olditemscore + 1);
-                            if (itemmod2 > 0)
-                                newitemscore = (newitemscore + 1);
-                        }
-                    }
-                    else //is a hunter
-                    {
-                        if (itemmod > 0)
-                        {
-                            if (olditemscore > 0) //we dont want any negative returns
-                                olditemscore = (olditemscore - 1);
-                        }
-                        if (itemmod2 > 0)
-                        {
-                            if (newitemscore > 0) //we dont want any negative returns
-                                newitemscore = (newitemscore - 1);
-                        }
-                    }
-                    break;
-                }  // pure melee need nothing from this list.
-                case 3:
-                {
-                    if (itemmod > 0)
-                    {
-                        if (olditemscore > 0) //we dont want any negative returns
-                            olditemscore = (olditemscore - 1);
-                    }
-                    if (itemmod2 > 0)
-                    {
-                        if (newitemscore > 0) //we dont want any negative returns
-                            newitemscore = (newitemscore - 1);
-                    }
-                    break;
-                }
-                default:
-                    break;
-            }
-        }
-        // melee only stats (warrior/rogue) or stats that only apply to melee style combat
-        if (itemmod == ITEM_MOD_HEALTH || itemmod == ITEM_MOD_AGILITY || itemmod == ITEM_MOD_STRENGTH ||
-                itemmod == ITEM_MOD_DEFENSE_SKILL_RATING || itemmod == ITEM_MOD_DODGE_RATING || itemmod == ITEM_MOD_PARRY_RATING ||
-                itemmod == ITEM_MOD_BLOCK_RATING || itemmod == ITEM_MOD_HIT_MELEE_RATING || itemmod == ITEM_MOD_CRIT_MELEE_RATING ||
-                itemmod == ITEM_MOD_HIT_TAKEN_MELEE_RATING || itemmod == ITEM_MOD_HIT_TAKEN_RANGED_RATING || itemmod == ITEM_MOD_HIT_TAKEN_SPELL_RATING ||
-                itemmod == ITEM_MOD_CRIT_TAKEN_MELEE_RATING || itemmod == ITEM_MOD_CRIT_TAKEN_RANGED_RATING ||
-                itemmod == ITEM_MOD_CRIT_TAKEN_SPELL_RATING || itemmod == ITEM_MOD_HASTE_MELEE_RATING ||
-                itemmod == ITEM_MOD_HIT_TAKEN_RATING || itemmod == ITEM_MOD_CRIT_TAKEN_RATING ||
-                itemmod2 == ITEM_MOD_HEALTH || itemmod2 == ITEM_MOD_AGILITY || itemmod2 == ITEM_MOD_STRENGTH ||
-                itemmod2 == ITEM_MOD_DEFENSE_SKILL_RATING || itemmod2 == ITEM_MOD_DODGE_RATING || itemmod2 == ITEM_MOD_PARRY_RATING ||
-                itemmod2 == ITEM_MOD_BLOCK_RATING || itemmod2 == ITEM_MOD_HIT_MELEE_RATING || itemmod2 == ITEM_MOD_CRIT_MELEE_RATING ||
-                itemmod2 == ITEM_MOD_HIT_TAKEN_MELEE_RATING || itemmod2 == ITEM_MOD_HIT_TAKEN_RANGED_RATING || itemmod2 == ITEM_MOD_HIT_TAKEN_SPELL_RATING ||
-                itemmod2 == ITEM_MOD_CRIT_TAKEN_MELEE_RATING || itemmod2 == ITEM_MOD_CRIT_TAKEN_RANGED_RATING ||
-                itemmod2 == ITEM_MOD_CRIT_TAKEN_SPELL_RATING || itemmod2 == ITEM_MOD_HASTE_MELEE_RATING ||
-                itemmod2 == ITEM_MOD_HIT_TAKEN_RATING || itemmod2 == ITEM_MOD_CRIT_TAKEN_RATING)
-        {
-            switch (isclass) // 1 caster, 2 hybrid, 3 melee
-            {
-                case 1:
-                {
-                    if (itemmod > 0)
-                    {
-                        if (olditemscore > 0) //we dont want any negative returns
-                            olditemscore = (olditemscore - 1);
-                    }
-                    if (itemmod2 > 0)
-                    {
-                        if (newitemscore > 0) //we dont want any negative returns
-                            newitemscore = (newitemscore - 1);
-                    }
-                    break;
-                }
-                case 2:
-                {
-                    uint32 itemmodval = pProto->ItemStat[i].ItemStatValue; // equipped item stats if any
-                    uint32 itemmodval2 = pProto2->ItemStat[i].ItemStatValue;  // newitem stats
-                    if (itemmod == itemmod2) //same stat type
-                    {
-                        if (pProto == pProto2) // same item
-                        {
-                            if (olditemscore > 0)
-                                olditemscore = (olditemscore - 1);
-                            newitemscore = (newitemscore + 1);
-                        }
-                        if (itemmodval < itemmodval2) // which one has the most
-                        {
-                            if (olditemscore > 0)
-                                olditemscore = (olditemscore - 1);
-                            newitemscore = (newitemscore + 1);
-                        }
-                        else if (itemmodval > itemmodval2)
-                        {
-                            if (newitemscore > 0)
-                                newitemscore = (newitemscore - 1);
-                            olditemscore = (olditemscore + 1);
-                        }
-                    }
-                    else
-                    {
-                        if (itemmod > 0)
-                            olditemscore = (olditemscore + 1);
-                        if (itemmod2 > 0)
-                            newitemscore = (newitemscore + 1);
-                    }
-                    break;
-                }
-                case 3:
-                {
-                    uint32 itemmodval = pProto->ItemStat[i].ItemStatValue; // equipped item stats if any
-                    uint32 itemmodval2 = pProto2->ItemStat[i].ItemStatValue;  // newitem stats
-                    if (itemmod == itemmod2) //same stat type
-                    {
-                        if (pProto == pProto2) // same item
-                        {
-                            if (olditemscore > 0)
-                                olditemscore = (olditemscore - 1);
-                            newitemscore = (newitemscore + 1);
-                        }
-                        if (itemmodval < itemmodval2) // which one has the most
-                        {
-                            if (olditemscore > 0)
-                                olditemscore = (olditemscore - 1);
-                            newitemscore = (newitemscore + 1);
-                        }
-                        else if (itemmodval > itemmodval2)
-                        {
-                            if (newitemscore > 0)
-                                newitemscore = (newitemscore - 1);
-                            olditemscore = (olditemscore + 1);
-                        }
-                    }
-                    else
-                    {
-                        if (itemmod > 0)
-                            olditemscore = (olditemscore + 1);
-                        if (itemmod2 > 0)
-                            newitemscore = (newitemscore + 1);
-                    }
-                    break;
-                }
-                default:
-                    break;
-            }
-        }
-        // stats which aren't strictly caster or melee (hybrid perhaps or style dependant)
-        if (itemmod == ITEM_MOD_HIT_RATING || itemmod == ITEM_MOD_CRIT_RATING || itemmod == ITEM_MOD_RESILIENCE_RATING ||
-                itemmod == ITEM_MOD_HASTE_RATING || itemmod == ITEM_MOD_EXPERTISE_RATING || itemmod == ITEM_MOD_STAMINA ||
-                itemmod2 == ITEM_MOD_HIT_RATING || itemmod2 == ITEM_MOD_CRIT_RATING || itemmod2 == ITEM_MOD_RESILIENCE_RATING ||
-                itemmod2 == ITEM_MOD_HASTE_RATING || itemmod2 == ITEM_MOD_EXPERTISE_RATING || itemmod2 == ITEM_MOD_STAMINA)
-        {
-            switch (isclass) // 1 caster, 2 hybrid, 3 melee
-            {
-                case 1:
-                {
-                    uint32 itemmodval = pProto->ItemStat[i].ItemStatValue; // equipped item stats if any
-                    uint32 itemmodval2 = pProto2->ItemStat[i].ItemStatValue;  // newitem stats
-                    if (itemmod == itemmod2) //same stat type
-                    {
-                        if (pProto == pProto2) // same item
-                        {
-                            if (olditemscore > 0)
-                                olditemscore = (olditemscore - 1);
-                            newitemscore = (newitemscore + 1);
-                        }
-                        if (itemmodval < itemmodval2) // which one has the most
-                        {
-                            if (olditemscore > 0)
-                                olditemscore = (olditemscore - 1);
-                            newitemscore = (newitemscore + 1);
-                        }
-                        else if (itemmodval > itemmodval2)
-                        {
-                            if (newitemscore > 0)
-                                newitemscore = (newitemscore - 1);
-                            olditemscore = (olditemscore + 1);
-                        }
-                    }
-                    else
-                    {
-                        if (itemmod > 0)
-                            olditemscore = (olditemscore + 1);
-                        if (itemmod2 > 0)
-                            newitemscore = (newitemscore + 1);
-                    }
-                    break;
-                }
-                case 2:
-                {
-                    uint32 itemmodval = pProto->ItemStat[i].ItemStatValue; // equipped item stats if any
-                    uint32 itemmodval2 = pProto2->ItemStat[i].ItemStatValue;  // newitem stats
-                    if (itemmod == itemmod2) //same stat type
-                    {
-                        if (pProto == pProto2) // same item
-                        {
-                            if (olditemscore > 0)
-                                olditemscore = (olditemscore - 1);
-                            newitemscore = (newitemscore + 1);
-                        }
-                        if (itemmodval < itemmodval2) // which one has the most
-                        {
-                            if (olditemscore > 0)
-                                olditemscore = (olditemscore - 1);
-                            newitemscore = (newitemscore + 1);
-                        }
-                        else if (itemmodval > itemmodval2)
-                        {
-                            if (newitemscore > 0)
-                                newitemscore = (newitemscore - 1);
-                            olditemscore = (olditemscore + 1);
-                        }
-                    }
-                    else
-                    {
-                        if (itemmod > 0)
-                            olditemscore = (olditemscore + 1);
-                        if (itemmod2 > 0)
-                            newitemscore = (newitemscore + 1);
-                    }
-                    break;
-                }
-                case 3:
-                {
-                    uint32 itemmodval = pProto->ItemStat[i].ItemStatValue; // equipped item stats if any
-                    uint32 itemmodval2 = pProto2->ItemStat[i].ItemStatValue;  // newitem stats
-                    if (itemmod == itemmod2) //same stat type
-                    {
-                        if (pProto == pProto2) // same item
-                        {
-                            if (olditemscore > 0)
-                                olditemscore = (olditemscore - 1);
-                            newitemscore = (newitemscore + 1);
-                        }
-                        if (itemmodval < itemmodval2) // which one has the most
-                        {
-                            if (olditemscore > 0)
-                                olditemscore = (olditemscore - 1);
-                            newitemscore = (newitemscore + 1);
-                        }
-                        else if (itemmodval > itemmodval2)
-                        {
-                            if (newitemscore > 0)
-                                newitemscore = (newitemscore - 1);
-                            olditemscore = (olditemscore + 1);
-                        }
-                    }
-                    else
-                    {
-                        if (itemmod > 0)
-                            olditemscore = (olditemscore + 1);
-                        if (itemmod2 > 0)
-                            newitemscore = (newitemscore + 1);
-                    }
-                    break;
-                }
-                default:
-                    break;
-            }
-        }
-        // stats relating to ranged only
-        if (itemmod == ITEM_MOD_HIT_RANGED_RATING || itemmod == ITEM_MOD_CRIT_RANGED_RATING || itemmod == ITEM_MOD_HASTE_RANGED_RATING ||
-                itemmod2 == ITEM_MOD_HIT_RANGED_RATING || itemmod2 == ITEM_MOD_CRIT_RANGED_RATING || itemmod2 == ITEM_MOD_HASTE_RANGED_RATING)
-        {
-            switch (isclass) // 1 caster, 2 hybrid, 3 melee
-            {
-                case 1:
-                {
-                    if (itemmod > 0)
-                    {
-                        if (olditemscore > 0) //we dont want any negative returns
-                            olditemscore = (olditemscore - 1);
-                    }
-                    if (itemmod2 > 0)
-                    {
-                        if (newitemscore > 0) //we dont want any negative returns
-                            newitemscore = (newitemscore - 1);
-                    }
-                    break;
-                }
-                case 2:
-                {
-                    if (ishybrid != 2) //not a hunter
-                    {
-                        if (itemmod > 0)
-                        {
-                            if (olditemscore > 0) //we dont want any negative returns
-                                olditemscore = (olditemscore - 1);
-                        }
-                        if (itemmod2 > 0)
-                        {
-                            if (newitemscore > 0) //we dont want any negative returns
-                                newitemscore = (newitemscore - 1);
-                        }
-                    }
-                    else //is a hunter
-                    {
-                        uint32 itemmodval = pProto->ItemStat[i].ItemStatValue; // equipped item stats if any
-                        uint32 itemmodval2 = pProto2->ItemStat[i].ItemStatValue;  // newitem stats
-                        if (itemmod == itemmod2) //same stat type
-                        {
-                            if (pProto == pProto2) // same item
-                            {
-                                if (olditemscore > 0)
-                                    olditemscore = (olditemscore - 1);
-                                newitemscore = (newitemscore + 1);
-                            }
-                            if (itemmodval < itemmodval2) // which one has the most
-                            {
-                                if (olditemscore > 0)
-                                    olditemscore = (olditemscore - 1);
-                                newitemscore = (newitemscore + 1);
-                            }
-                            else if (itemmodval > itemmodval2)
-                            {
-                                if (newitemscore > 0)
-                                    newitemscore = (newitemscore - 1);
-                                olditemscore = (olditemscore + 1);
-                            }
-                        }
-                        else
-                        {
-                            if (itemmod > 0)
-                                olditemscore = (olditemscore + 1);
-                            if (itemmod2 > 0)
-                                newitemscore = (newitemscore + 1);
-                        }
-                    }
-                    break;
-                }
-                case 3:
-                {
-                    if (itemmod > 0)
-                    {
-                        if (olditemscore > 0) //we dont want any negative returns
-                            olditemscore = (olditemscore - 1);
-                    }
-                    if (itemmod2 > 0)
-                    {
-                        if (newitemscore > 0) //we dont want any negative returns
-                            newitemscore = (newitemscore - 1);
-                    }
-                    break;
-                }
-                default:
-                    break;
-            }
-        }
-    }
-    if (olditemscore <= newitemscore)
-        return true;
-    else
-        return false;
-}
-
-void PlayerbotAI::SendQuestNeedList()
-{
-    std::ostringstream out;
-
-    for (BotNeedItem::iterator itr = m_needItemList.begin(); itr != m_needItemList.end(); ++itr)
-    {
-        ItemPrototype const* pItemProto = sObjectMgr.GetItemPrototype(itr->first);
-        if (pItemProto)
-        {
-            std::string itemName = pItemProto->Name1;
-            ItemLocalization(itemName, pItemProto->ItemId);
-
-            out << " " << itr->second << "x|cffffffff|Hitem:" << pItemProto->ItemId
-                << ":0:0:0:0:0:0:0" << "|h[" << itemName
-                << "]|h|r";
-        }
-    }
-
-    for (BotNeedItem::iterator itr = m_needCreatureOrGOList.begin(); itr != m_needCreatureOrGOList.end(); ++itr)
-    {
-        CreatureInfo const* cInfo = ObjectMgr::GetCreatureTemplate(itr->first);
-        if (cInfo)
-        {
-            std::string creatureName = cInfo->Name;
-            CreatureLocalization(creatureName, cInfo->Entry);
-            out << " " << itr->second << "x|cFFFFFF00|Hcreature_entry:" << itr->first << "|h[" << creatureName << "]|h|r";
-        }
-
-        if (m_bot->HasQuestForGO(itr->first))
-        {
-            GameObjectInfo const* gInfo = ObjectMgr::GetGameObjectInfo(itr->first);
-            if (gInfo)
-            {
-                std::string gameobjectName = gInfo->name;
-                GameObjectLocalization(gameobjectName, gInfo->id);
-                out << " " << itr->second << "x|cFFFFFF00|Hgameobject_entry:" << itr->first << "|h[" << gameobjectName << "]|h|r";
-            }
-        }
-    }
-
-    TellMaster("Here's a list of all things needed for quests:");
-    if (!out.str().empty())
-        TellMaster(out.str().c_str());
-}
-
-bool PlayerbotAI::IsItemUseful(uint32 itemid)
-{
-    const static uint32 item_weapon_skills[MAX_ITEM_SUBCLASS_WEAPON] =
-    {
-        SKILL_AXES,     SKILL_2H_AXES,  SKILL_BOWS,          SKILL_GUNS,      SKILL_MACES,
-        SKILL_2H_MACES, SKILL_POLEARMS, SKILL_SWORDS,        SKILL_2H_SWORDS, 0,
-        SKILL_STAVES,   0,              0,                   SKILL_UNARMED,   0,
-        SKILL_DAGGERS,  SKILL_THROWN,   SKILL_ASSASSINATION, SKILL_CROSSBOWS, SKILL_WANDS,
-        SKILL_FISHING
-    };
-
-    const static uint32 item_armor_skills[MAX_ITEM_SUBCLASS_ARMOR] =
-    {
-        0, SKILL_CLOTH, SKILL_LEATHER, SKILL_MAIL, SKILL_PLATE_MAIL, 0, SKILL_SHIELD, 0, 0, 0
-    };
-
-    ItemPrototype const* pProto = ObjectMgr::GetItemPrototype(itemid);
-    if (!pProto || pProto->Quality < ITEM_QUALITY_NORMAL)
-        return false;
-
-    // do we already have the max allowed of item if more than zero?
-    if (pProto->MaxCount > 0 && m_bot->HasItemCount(itemid, pProto->MaxCount, true))
-        return false;
-
-    // quest related items
-    if (pProto->StartQuest > 0 && HasCollectFlag(COLLECT_FLAG_QUEST))
-        return true;
-
-    switch (pProto->Class)
-    {
-        case ITEM_CLASS_WEAPON:
-            if (pProto->SubClass >= MAX_ITEM_SUBCLASS_WEAPON)
-                return false;
-            else
-                return m_bot->HasSkill(item_weapon_skills[pProto->SubClass]);
-            break;
-        case ITEM_CLASS_ARMOR:
-            if (pProto->SubClass >= MAX_ITEM_SUBCLASS_ARMOR)
-                return false;
-            else
-                return (m_bot->HasSkill(item_armor_skills[pProto->SubClass]) && !m_bot->HasSkill(item_armor_skills[pProto->SubClass + 1]));
-            break;
-        case ITEM_CLASS_QUEST:
-            if (!HasCollectFlag(COLLECT_FLAG_QUEST))
-                break;
-        case ITEM_CLASS_KEY:
-            return true;
-        case ITEM_CLASS_GEM:
-            if (m_bot->HasSkill(SKILL_BLACKSMITHING) ||
-                    m_bot->HasSkill(SKILL_ENGINEERING) ||
-                    m_bot->HasSkill(SKILL_JEWELCRAFTING))
-                return true;
-            break;
-        case ITEM_CLASS_TRADE_GOODS:
-            if (!HasCollectFlag(COLLECT_FLAG_PROFESSION))
-                break;
-
-            switch (pProto->SubClass)
-            {
-                case ITEM_SUBCLASS_PARTS:
-                case ITEM_SUBCLASS_EXPLOSIVES:
-                case ITEM_SUBCLASS_DEVICES:
-                    if (m_bot->HasSkill(SKILL_ENGINEERING))
-                        return true;
-                    break;
-                case ITEM_SUBCLASS_JEWELCRAFTING:
-                    if (m_bot->HasSkill(SKILL_JEWELCRAFTING))
-                        return true;
-                    break;
-                case ITEM_SUBCLASS_CLOTH:
-                    if (m_bot->HasSkill(SKILL_TAILORING))
-                        return true;
-                    break;
-                case ITEM_SUBCLASS_LEATHER:
-                    if (m_bot->HasSkill(SKILL_LEATHERWORKING))
-                        return true;
-                    break;
-                case ITEM_SUBCLASS_METAL_STONE:
-                    if (m_bot->HasSkill(SKILL_BLACKSMITHING) ||
-                            m_bot->HasSkill(SKILL_ENGINEERING) ||
-                            m_bot->HasSkill(SKILL_MINING))
-                        return true;
-                    break;
-                case ITEM_SUBCLASS_MEAT:
-                    if (m_bot->HasSkill(SKILL_COOKING))
-                        return true;
-                    break;
-                case ITEM_SUBCLASS_HERB:
-                    if (m_bot->HasSkill(SKILL_HERBALISM) ||
-                            m_bot->HasSkill(SKILL_ALCHEMY))
-                        return true;
-                    break;
-                case ITEM_SUBCLASS_ELEMENTAL:
-                    return true;    // pretty much every profession uses these a bit
-                case ITEM_SUBCLASS_ENCHANTING:
-                    if (m_bot->HasSkill(SKILL_ENCHANTING))
-                        return true;
-                    break;
-                default:
-                    break;
-            }
-            break;
-        case ITEM_CLASS_RECIPE:
-        {
-            if (!HasCollectFlag(COLLECT_FLAG_PROFESSION))
-                break;
-
-            // skip recipes that we have
-            if (m_bot->HasSpell(pProto->Spells[2].SpellId))
-                break;
-
-            switch (pProto->SubClass)
-            {
-                case ITEM_SUBCLASS_LEATHERWORKING_PATTERN:
-                    if (m_bot->HasSkill(SKILL_LEATHERWORKING))
-                        return true;
-                    break;
-                case ITEM_SUBCLASS_TAILORING_PATTERN:
-                    if (m_bot->HasSkill(SKILL_TAILORING))
-                        return true;
-                    break;
-                case ITEM_SUBCLASS_ENGINEERING_SCHEMATIC:
-                    if (m_bot->HasSkill(SKILL_ENGINEERING))
-                        return true;
-                    break;
-                case ITEM_SUBCLASS_BLACKSMITHING:
-                    if (m_bot->HasSkill(SKILL_BLACKSMITHING))
-                        return true;
-                    break;
-                case ITEM_SUBCLASS_COOKING_RECIPE:
-                    if (m_bot->HasSkill(SKILL_COOKING))
-                        return true;
-                    break;
-                case ITEM_SUBCLASS_ALCHEMY_RECIPE:
-                    if (m_bot->HasSkill(SKILL_ALCHEMY))
-                        return true;
-                    break;
-                case ITEM_SUBCLASS_FIRST_AID_MANUAL:
-                    if (m_bot->HasSkill(SKILL_FIRST_AID))
-                        return true;
-                    break;
-                case ITEM_SUBCLASS_ENCHANTING_FORMULA:
-                    if (m_bot->HasSkill(SKILL_ENCHANTING))
-                        return true;
-                    break;
-                case ITEM_SUBCLASS_FISHING_MANUAL:
-                    if (m_bot->HasSkill(SKILL_FISHING))
-                        return true;
-                    break;
-                case ITEM_SUBCLASS_JEWELCRAFTING_RECIPE:
-                    if (m_bot->HasSkill(SKILL_JEWELCRAFTING))
-                        return true;
-                    break;
-                default:
-                    break;
-            }
-        }
-        default:
-            break;
-    }
-    return false;
-}
-
-void PlayerbotAI::ReloadAI()
-{
-    switch (m_bot->getClass())
-    {
-        case CLASS_PRIEST:
-            if (m_classAI) delete m_classAI;
-            m_combatStyle = COMBAT_RANGED;
-            m_classAI = (PlayerbotClassAI*) new PlayerbotPriestAI(GetMaster(), m_bot, this);
-            break;
-        case CLASS_MAGE:
-            if (m_classAI) delete m_classAI;
-            m_combatStyle = COMBAT_RANGED;
-            m_classAI = (PlayerbotClassAI*) new PlayerbotMageAI(GetMaster(), m_bot, this);
-            break;
-        case CLASS_WARLOCK:
-            if (m_classAI) delete m_classAI;
-            m_combatStyle = COMBAT_RANGED;
-            m_classAI = (PlayerbotClassAI*) new PlayerbotWarlockAI(GetMaster(), m_bot, this);
-            break;
-        case CLASS_WARRIOR:
-            if (m_classAI) delete m_classAI;
-            m_combatStyle = COMBAT_MELEE;
-            m_classAI = (PlayerbotClassAI*) new PlayerbotWarriorAI(GetMaster(), m_bot, this);
-            break;
-        case CLASS_SHAMAN:
-            if (m_classAI) delete m_classAI;
-            if (m_bot->GetSpec() == SHAMAN_SPEC_ENHANCEMENT)
-            {
-                m_combatStyle = COMBAT_MELEE;
-            }
-            else
-                m_combatStyle = COMBAT_RANGED;            m_classAI = (PlayerbotClassAI*) new PlayerbotShamanAI(GetMaster(), m_bot, this);
-            break;
-        case CLASS_PALADIN:
-            if (m_classAI) delete m_classAI;
-            m_combatStyle = COMBAT_MELEE;
-            m_classAI = (PlayerbotClassAI*) new PlayerbotPaladinAI(GetMaster(), m_bot, this);
-            break;
-        case CLASS_ROGUE:
-            if (m_classAI) delete m_classAI;
-            m_combatStyle = COMBAT_MELEE;
-            m_classAI = (PlayerbotClassAI*) new PlayerbotRogueAI(GetMaster(), m_bot, this);
-            break;
-        case CLASS_DRUID:
-            if (m_classAI) delete m_classAI;
-            if (m_bot->GetSpec() == DRUID_SPEC_FERAL)
-            {
-                m_combatStyle = COMBAT_MELEE;
-            }
-            else
-                m_combatStyle = COMBAT_RANGED;
-            m_classAI = (PlayerbotClassAI*) new PlayerbotDruidAI(GetMaster(), m_bot, this);
-            break;
-        case CLASS_HUNTER:
-            if (m_classAI) delete m_classAI;
-            m_combatStyle = COMBAT_RANGED;
-            m_classAI = (PlayerbotClassAI*) new PlayerbotHunterAI(GetMaster(), m_bot, this);
-            break;
-    }
-
-    HERB_GATHERING      = initSpell(HERB_GATHERING_1);
-    MINING              = initSpell(MINING_1);
-    SKINNING            = initSpell(SKINNING_1);
-}
-
-void PlayerbotAI::SendOrders(Player& /*player*/)
-{
-    std::ostringstream out;
-
-    if (!m_combatOrder)
-        out << "Got no combat orders!";
-    else if (m_combatOrder & ORDERS_TANK)
-        out << "I TANK";
-    else if (m_combatOrder & ORDERS_ASSIST)
-        out << "I ASSIST " << (m_targetAssist ? m_targetAssist->GetName() : "unknown");
-    else if (m_combatOrder & ORDERS_HEAL)
-        out << "I HEAL and DISPEL";
-    else if (m_combatOrder & ORDERS_NODISPEL)
-        out << "I HEAL and WON'T DISPEL";
-    else if (m_combatOrder & ORDERS_PASSIVE)
-        out << "I'm PASSIVE";
-    if ((m_combatOrder & ORDERS_PRIMARY) && (m_combatOrder & (ORDERS_PROTECT | ORDERS_RESIST)))
-    {
-        out << " and ";
-        if (m_combatOrder & ORDERS_PROTECT)
-            out << "I PROTECT " << (m_targetProtect ? m_targetProtect->GetName() : "unknown");
-        if (m_combatOrder & ORDERS_RESIST)
-        {
-            if (m_combatOrder & ORDERS_RESIST_FIRE)
-                out << "I RESIST FIRE";
-            if (m_combatOrder & ORDERS_RESIST_NATURE)
-                out << "I RESIST NATURE";
-            if (m_combatOrder & ORDERS_RESIST_FROST)
-                out << "I RESIST FROST";
-            if (m_combatOrder & ORDERS_RESIST_SHADOW)
-                out << "I RESIST SHADOW";
-        }
-    }
-    out << ".";
-
-    if (m_mgr->m_confDebugWhisper)
-    {
-        out << " " << (IsInCombat() ? "I'm in COMBAT! " : "Not in combat. ");
-        out << "Current state is ";
-        if (m_botState == BOTSTATE_NORMAL)
-            out << "NORMAL";
-        else if (m_botState == BOTSTATE_COMBAT)
-            out << "COMBAT";
-        else if (m_botState == BOTSTATE_TAME)
-            out << "TAMING";
-        else if (m_botState == BOTSTATE_DEAD)
-            out << "DEAD";
-        else if (m_botState == BOTSTATE_DEADRELEASED)
-            out << "RELEASED";
-        else if (m_botState == BOTSTATE_LOOTING)
-            out << "LOOTING";
-        else if (m_botState == BOTSTATE_FLYING)
-            out << "FLYING";
-        out << ". Movement order is ";
-        if (m_movementOrder == MOVEMENT_NONE)
-            out << "NONE";
-        else if (m_movementOrder == MOVEMENT_FOLLOW)
-            out << "FOLLOW " << (m_followTarget ? m_followTarget->GetName() : "unknown");
-        else if (m_movementOrder == MOVEMENT_STAY)
-            out << "STAY";
-        out << ". Got " << m_attackerInfo.size() << " attacker(s) in list.";
-        out << " Next action in " << m_ignoreAIUpdatesUntilTime - CurrentTime() << "sec.";
-    }
-
-    TellMaster(out.str().c_str());
-    if (m_DelayAttack)
-        TellMaster("My combat delay is '%u'", m_DelayAttack);
-}
-
-// handle outgoing packets the server would send to the client
-void PlayerbotAI::HandleBotOutgoingPacket(const WorldPacket& packet)
-{
-    switch (packet.GetOpcode())
-    {
-        case SMSG_DUEL_WINNER:
-        {
-            m_bot->HandleEmoteCommand(EMOTE_ONESHOT_APPLAUD);
-            return;
-        }
-        case SMSG_DUEL_COMPLETE:
-        {
-            SetIgnoreUpdateTime(4);
-            m_ScenarioType = SCENARIO_PVE;
-            ReloadAI();
-            m_bot->GetMotionMaster()->Clear(true);
-            return;
-        }
-        case SMSG_DUEL_OUTOFBOUNDS:
-        {
-            m_bot->HandleEmoteCommand(EMOTE_ONESHOT_CHICKEN);
-            return;
-        }
-        case SMSG_DUEL_REQUESTED:
-        {
-            SetIgnoreUpdateTime(0);
-            WorldPacket p(packet);
-            ObjectGuid flagGuid;
-            p >> flagGuid;
-            ObjectGuid playerGuid;
-            p >> playerGuid;
-            Player* const pPlayer = ObjectAccessor::FindPlayer(playerGuid);
-            if (canObeyCommandFrom(*pPlayer))
-            {
-                m_bot->GetMotionMaster()->Clear(true);
-                std::unique_ptr<WorldPacket> packet(new WorldPacket(CMSG_DUEL_ACCEPTED, 8));
-                *packet << flagGuid;
-                m_bot->GetSession()->QueuePacket(std::move(packet)); // queue the packet to get around race condition
-
-                // follow target in casting range
-                float angle = rand_float(0, M_PI_F);
-                float dist = rand_float(4, 10);
-
-                m_bot->GetMotionMaster()->Clear(true);
-                m_bot->GetMotionMaster()->MoveFollow(pPlayer, dist, angle);
-
-                m_bot->SetSelectionGuid(ObjectGuid(playerGuid));
-                SetIgnoreUpdateTime(4);
-                m_ScenarioType = SCENARIO_PVP_DUEL;
-            }
-            return;
-        }
-
-        case SMSG_PET_TAME_FAILURE:
-        {
-            // DEBUG_LOG("SMSG_PET_TAME_FAILURE");
-            WorldPacket p(packet);
-            uint8 reason;
-            p >> reason;
-
-            switch (reason)
-            {
-                case PETTAME_INVALIDCREATURE:           // = 1,
-                    DEBUG_LOG("Invalid Creature");
-                    break;
-                case PETTAME_TOOMANY:                   // = 2,
-                    DEBUG_LOG("Too many Creature");
-                    break;
-                case PETTAME_CREATUREALREADYOWNED:      // = 3,
-                    DEBUG_LOG("Creature already owned");
-                    break;
-                case PETTAME_NOTTAMEABLE:               // = 4,
-                    DEBUG_LOG("Creature not tameable");
-                    break;
-                case PETTAME_ANOTHERSUMMONACTIVE:       // = 5,
-                    DEBUG_LOG("Another summon active");
-                    break;
-                case PETTAME_UNITSCANTTAME:             // = 6,
-                    DEBUG_LOG("Unit cant tame");
-                    break;
-                case PETTAME_NOPETAVAILABLE:            // = 7,    // not used in taming
-                    DEBUG_LOG("No pet available");
-                    break;
-                case PETTAME_INTERNALERROR:             // = 8,
-                    DEBUG_LOG("Internal error");
-                    break;
-                case PETTAME_TOOHIGHLEVEL:              // = 9,
-                    DEBUG_LOG("Creature level too high");
-                    break;
-                case PETTAME_DEAD:                      // = 10,   // not used in taming
-                    DEBUG_LOG("Creature dead");
-                    break;
-                case PETTAME_NOTDEAD:                   // = 11,   // not used in taming
-                    DEBUG_LOG("Creature not dead");
-                    break;
-                case PETTAME_UNKNOWNERROR:              // = 13
-                    DEBUG_LOG("Unknown error");
-                    break;
-            }
-            return;
-        }
-
-        case SMSG_BUY_FAILED:
-        {
-            WorldPacket p(packet); // 8+4+4+1
-            ObjectGuid vendorguid;
-            p >> vendorguid;
-            uint32 itemid;
-            p >> itemid;
-            uint8 msg;
-            p >> msg; // error msg
-            p.resize(13);
-
-            switch (msg)
-            {
-                case BUY_ERR_CANT_FIND_ITEM:
-                    break;
-                case BUY_ERR_ITEM_ALREADY_SOLD:
-                    break;
-                case BUY_ERR_NOT_ENOUGHT_MONEY:
-                {
-                    Announce(CANT_AFFORD);
-                    break;
-                }
-                case BUY_ERR_SELLER_DONT_LIKE_YOU:
-                    break;
-                case BUY_ERR_DISTANCE_TOO_FAR:
-                    break;
-                case BUY_ERR_ITEM_SOLD_OUT:
-                    break;
-                case BUY_ERR_CANT_CARRY_MORE:
-                {
-                    Announce(INVENTORY_FULL);
-                    break;
-                }
-                case BUY_ERR_RANK_REQUIRE:
-                    break;
-                case BUY_ERR_REPUTATION_REQUIRE:
-                    break;
-            }
-            return;
-        }
-
-        case SMSG_AUCTION_COMMAND_RESULT:
-        {
-            uint32 auctionId, Action, ErrorCode;
-            std::string action[3] = {"Creating", "Cancelling", "Bidding"};
-            std::ostringstream out;
-
-            WorldPacket p(packet);
-            p >> auctionId;
-            p >> Action;
-            p >> ErrorCode;
-            p.resize(12);
-
-            switch (ErrorCode)
-            {
-                case AUCTION_OK:
-                {
-                    out << "|cff1eff00|h" << action[Action] << " was successful|h|r";
-                    break;
-                }
-                case AUCTION_ERR_INVENTORY:
-                {
-                    out << "|cffff0000|h Item cannot be auctioned|h|r";
-                    break;
-                }
-                case AUCTION_ERR_DATABASE:
-                {
-                    out << "|cffff0000|hWhile" << action[Action] << ", an internal error occured|h|r";
-                    break;
-                }
-                case AUCTION_ERR_NOT_ENOUGH_MONEY:
-                {
-                    out << "|cffff0000|hWhile " << action[Action] << ", I didn't have enough money|h|r";
-                    break;
-                }
-                case AUCTION_ERR_ITEM_NOT_FOUND:
-                {
-                    out << "|cffff0000|hItem was not found!|h|r";
-                    break;
-                }
-                case AUCTION_ERR_BID_OWN:
-                {
-                    out << "|cffff0000|hI cannot bid on my own auctions!|h|r";
-                    break;
-                }
-                default:
-                    out << "|cffff0000|hAuction Error code (" << ErrorCode << ")|h|r";
-            }
-            TellMaster(out.str().c_str());
-            return;
-        }
-
-        case SMSG_INVENTORY_CHANGE_FAILURE:
-        {
-            WorldPacket p(packet);
-            uint8 err;
-            p >> err;
-
-            if (err != EQUIP_ERR_OK)
-            {
-                switch (err)
-                {
-                    case EQUIP_ERR_CANT_CARRY_MORE_OF_THIS:
-                        TellMaster("I can't carry anymore of those.");
-                        return;
-                    case EQUIP_ERR_MISSING_REAGENT:
-                        TellMaster("I'm missing some reagents for that.");
-                        return;
-                    case EQUIP_ERR_ITEM_LOCKED:
-                        TellMaster("That item is locked.");
-                        return;
-                    case EQUIP_ERR_ALREADY_LOOTED:
-                        TellMaster("That is already looted.");
-                        return;
-                    case EQUIP_ERR_INVENTORY_FULL:
-                    {
-                        if (m_lootCurrent.IsGameObject())
-                            if (GameObject* go = m_bot->GetMap()->GetGameObject(m_lootCurrent))
-                                m_collectObjects.remove(go->GetEntry());
-
-                        if (m_inventory_full)
-                            return;
-
-                        TellMaster("My inventory is full.");
-                        m_inventory_full = true;
-                        return;
-                    }
-                    case EQUIP_ERR_NOT_IN_COMBAT:
-                        TellMaster("I can't use that in combat.");
-                        return;
-                    case EQUIP_ERR_LOOT_CANT_LOOT_THAT_NOW:
-                        TellMaster("I can't get that now.");
-                        return;
-                    case EQUIP_ERR_ITEM_UNIQUE_EQUIPABLE:
-                        TellMaster("I can only have one of those equipped.");
-                        return;
-                    case EQUIP_ERR_BANK_FULL:
-                        TellMaster("My bank is full.");
-                        return;
-                    case EQUIP_ERR_ITEM_NOT_FOUND:
-                        TellMaster("I can't find the item.");
-                        return;
-                    case EQUIP_ERR_TOO_FAR_AWAY_FROM_BANK:
-                        TellMaster("I'm too far from the bank.");
-                        return;
-                    case EQUIP_ERR_NONE:
-                        TellMaster("I can't use it on that");
-                        return;
-                    default:
-                        TellMaster("I can't use that.");
-                        DEBUG_LOG("[PlayerbotAI]: HandleBotOutgoingPacket - SMSG_INVENTORY_CHANGE_FAILURE: %u", err);
-                        return;
-                }
-            }
-        }
-
-        /*    case SMSG_CAST_FAILED:
-                {
-                    WorldPacket p(packet);
-                    uint8 castCount;
-                    uint32 spellId;
-                    uint8 result;
-                    std::ostringstream out;
-
-                    p >> spellId >> result >> castCount;
-
-                    SpellEntry const* spellInfo = sSpellTemplate.LookupEntry<SpellEntry>(spellId);
-                    if (!spellInfo)
-                        return;
-
-                    if (result != SPELL_CAST_OK)
-                    {
-                        switch (result)
-                        {
-                        case SPELL_FAILED_INTERRUPTED:  // 40
-                        {
-                            DEBUG_LOG("spell %s interrupted (%u)",spellInfo->SpellName[0],result);
-                            return;
-                        }
-                        case SPELL_FAILED_UNIT_NOT_INFRONT:  // 134
-                            if (m_targetCombat)
-                                m_bot->SetInFront(m_targetCombat);
-                        case SPELL_FAILED_BAD_TARGETS:  // 12
-                            {
-                                // DEBUG_LOG("[%s]bad target / not in front(%u) for spellId (%u) & m_CurrentlyCastingSpellId (%u)",m_bot->GetName(),result,spellId,m_CurrentlyCastingSpellId);
-                                Spell* const pSpell = GetCurrentSpell();
-                                if (pSpell)
-                                    pSpell->cancel();
-                                break;
-                            }
-                            case SPELL_FAILED_TOTEM_CATEGORY:
-                            {
-                                for (uint8 i = 0; i < MAX_SPELL_TOTEM_CATEGORIES; i++)
-                                    if (!HasTool(spellInfo->TotemCategory[i]))
-                                        break;
-
-                                m_lootCurrent = ObjectGuid();
-                                break;
-                            }
-                        case SPELL_FAILED_REQUIRES_SPELL_FOCUS: // 102
-                            {
-                                switch(spellInfo->RequiresSpellFocus) // SpellFocusObject.dbc id
-                                {
-                                    case 1 : // need an anvil
-                                        out << "|cffff0000I require an anvil.";
-                                        break;
-                                    case 2 : // need a loom
-                                        out << "|cffff0000I require a loom.";
-                                        break;
-                                    case 3 : // need forge
-                                        out << "|cffff0000I require a forge.";
-                                        break;
-                                    case 4 : // need cooking fire
-                                        out << "|cffff0000I require a cooking fire.";
-                                        break;
-                                    default:
-                                        out << "|cffff0000I Require Spell Focus on " << spellInfo->RequiresSpellFocus;
-                                }
-                                break;
-                            }
-                        case SPELL_FAILED_CANT_BE_DISENCHANTED:  // 14
-                            {
-                                out << "|cffff0000Item cannot be disenchanted.";
-                                break;
-                            }
-                            case SPELL_FAILED_CANT_BE_PROSPECTED:  // 17
-                            {
-                                out << "|cffff0000There are no gems in this.";
-                                break;
-                            }
-                        case SPELL_FAILED_EQUIPPED_ITEM_CLASS:  // 29
-                            {
-                                out << "|cffff0000That item is not a valid target.";
-                                break;
-                            }
-                            case SPELL_FAILED_NEED_MORE_ITEMS:  // 55
-                            {
-                                ItemPrototype const *pProto = ObjectMgr::GetItemPrototype(m_itemTarget);
-                                if (!pProto)
-                                    return;
-
-                                out << "|cffff0000Requires 5 " << pProto->Name1 << ".";
-                                m_itemTarget = 0;
-                                break;
-                            }
-                            case SPELL_FAILED_REAGENTS:
-                            {
-                                out << "|cffff0000I don't have the reagents";
-                                break;
-                            }
-                            default:
-                                DEBUG_LOG ("[%s] SMSG_CAST_FAIL: %s err (%u)",m_bot->GetName(), spellInfo->SpellName[0], result);
-                                return;
-                        }
-                    }
-                    TellMaster(out.str().c_str());
-                    return;
-                }*/
-
-        case SMSG_SPELL_FAILURE:
-        {
-            WorldPacket p(packet);
-            uint8 castCount;
-            uint32 spellId;
-            ObjectGuid casterGuid;
-
-            p >> casterGuid.ReadAsPacked();
-            if (casterGuid != m_bot->GetObjectGuid())
-                return;
-
-            p >> castCount >> spellId;
-            if (m_CurrentlyCastingSpellId == spellId)
-            {
-                SetIgnoreUpdateTime(0);
-                m_CurrentlyCastingSpellId = 0;
-            }
-            return;
-        }
-
-        // if a change in speed was detected for the master
-        // make sure we have the same mount status
-        case SMSG_FORCE_RUN_SPEED_CHANGE:
-        {
-            WorldPacket p(packet);
-            ObjectGuid guid;
-
-            p >> guid.ReadAsPacked();
-            if (guid != GetMaster()->GetObjectGuid())
-                return;
-            if (GetMaster()->IsMounted() && !m_bot->IsMounted())
-            {
-                //Player Part
-                if (!GetMaster()->GetAurasByType(SPELL_AURA_MOUNTED).empty())
-                {
-                    int32 master_speed1 = 0;
-                    int32 master_speed2 = 0;
-                    master_speed1 = GetMaster()->GetAurasByType(SPELL_AURA_MOUNTED).front()->GetSpellProto()->EffectBasePoints[1];
-                    master_speed2 = GetMaster()->GetAurasByType(SPELL_AURA_MOUNTED).front()->GetSpellProto()->EffectBasePoints[2];
-
-                    //Bot Part
-                    uint32 spellMount = 0;
-                    for (PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
-                    {
-                        uint32 spellId = itr->first;
-                        if (itr->second.state == PLAYERSPELL_REMOVED || itr->second.disabled || IsPassiveSpell(spellId))
-                            continue;
-                        const SpellEntry* pSpellInfo = sSpellTemplate.LookupEntry<SpellEntry>(spellId);
-                        if (!pSpellInfo)
-                            continue;
-
-                        if (pSpellInfo->EffectApplyAuraName[0] == SPELL_AURA_MOUNTED)
-                        {
-                            if (pSpellInfo->EffectApplyAuraName[1] == SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED)
-                            {
-                                if (pSpellInfo->EffectBasePoints[1] == master_speed1)
-                                {
-                                    spellMount = spellId;
-                                    break;
-                                }
-                            }
-                            else if (pSpellInfo->EffectApplyAuraName[2] == SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED)
-                                if (pSpellInfo->EffectBasePoints[2] == master_speed2)
-                                {
-                                    spellMount = spellId;
-                                    break;
-                                }
-                        }
-                    }
-                    if (spellMount > 0) m_bot->CastSpell(m_bot, spellMount, TRIGGERED_NONE);
-                }
-            }
-            else if (!GetMaster()->IsMounted() && m_bot->IsMounted())
-            {
-                WorldPacket emptyPacket;
-                m_bot->GetSession()->HandleCancelMountAuraOpcode(emptyPacket);  //updated code
-            }
-            return;
-        }
-
-        // handle flying acknowledgement
-        case SMSG_MOVE_SET_CAN_FLY:
-        {
-            WorldPacket p(packet);
-            ObjectGuid guid;
-
-            p >> guid.ReadAsPacked();
-            if (guid != m_bot->GetObjectGuid())
-                return;
-            m_bot->m_movementInfo.AddMovementFlag(MOVEFLAG_FLYING);
-            //m_bot->SetSpeed(MOVE_RUN, GetMaster()->GetSpeed(MOVE_FLIGHT) +0.1f, true);
-            return;
-        }
-
-        // handle dismount flying acknowledgement
-        case SMSG_MOVE_UNSET_CAN_FLY:
-        {
-            WorldPacket p(packet);
-            ObjectGuid guid;
-
-            p >> guid.ReadAsPacked();
-            if (guid != m_bot->GetObjectGuid())
-                return;
-            m_bot->m_movementInfo.RemoveMovementFlag(MOVEFLAG_FLYING);
-            //m_bot->SetSpeed(MOVE_RUN,GetMaster()->GetSpeedRate(MOVE_RUN),true);
-            return;
-        }
-
-        // Handle chat messages here
-        case SMSG_MESSAGECHAT:
-        {
-            WorldPacket p(packet);
-            uint8 msgtype;
-            uint32 language;
-
-            p >> msgtype;           // 1 type
-            p >> language;          // 4 language
-
-            if (language == LANG_ADDON)
-                return;
-
-            switch (msgtype)
-            {
-                case CHAT_MSG_RAID:
-                case CHAT_MSG_RAID_LEADER:
-                case CHAT_MSG_PARTY:
-                case CHAT_MSG_WHISPER:
-                {
-                    ObjectGuid senderGuid;
-                    std::string channelName;
-                    uint32 length;
-                    std::string text;
-                    uint8 chattag;
-
-                    p >> senderGuid;        // 8 player from guid
-                    p.read_skip<uint32>();  // 4 chat msg group
-                    p.read_skip<uint64>();  // 8 player from guid
-                    p >> length;            // 4 length of text
-                    p >> text;              // string message
-                    p >> chattag;           // 1 AFK/DND/WHISPER_INFORM
-
-                    Player* sender = sObjectMgr.GetPlayer(senderGuid);
-                    if (!sender)            // couldn't find player that sent message
-                        return;
-
-                    // do not listen to other bots
-                    if (sender != m_bot && sender->GetPlayerbotAI())
-                        return;
-                    HandleCommand(text, *sender);
-                    return;
-                }
-                default:
-                    return;
-            }
-
-            return;
-        }
-
-        // If the leader role was given to the bot automatically give it to the master
-        // if the master is in the group, otherwise leave group
-        case SMSG_GROUP_SET_LEADER:
-        {
-            WorldPacket p(packet);
-            std::string name;
-            p >> name;
-            if (m_bot->GetGroup() && name == m_bot->GetName())
-            {
-                if (m_bot->GetGroup()->IsMember(GetMaster()->GetObjectGuid()))
-                {
-                    p.resize(8);
-                    p << GetMaster()->GetObjectGuid();
-                    m_bot->GetSession()->HandleGroupSetLeaderOpcode(p);
-                }
-                else
-                {
-                    p.clear(); // not really needed
-                    m_bot->GetSession()->HandleGroupDisbandOpcode(p); // packet not used updated code
-                }
-            }
-            return;
-        }
-
-        // If the master leaves the group, then the bot leaves too
-        case SMSG_PARTY_COMMAND_RESULT:
-        {
-            WorldPacket p(packet);
-            uint32 operation;
-            p >> operation;
-            std::string member;
-            p >> member;
-            uint32 result;
-            p >> result;
-            p.clear();
-            if (operation == PARTY_OP_LEAVE)
-                if (member == GetMaster()->GetName())
-                    m_bot->GetSession()->HandleGroupDisbandOpcode(p);  // packet not used updated code
-            return;
-        }
-
-        // Handle Group invites (auto accept if master is in group, otherwise decline & send message
-        case SMSG_GROUP_INVITE:
-        {
-            if (m_bot->GetGroupInvite())
-            {
-                const Group* const grp = m_bot->GetGroupInvite();
-                if (!grp)
-                    return;
-
-                Player* const inviter = sObjectMgr.GetPlayer(grp->GetLeaderGuid());
-                if (!inviter)
-                    return;
-
-                WorldPacket p;
-                if (!canObeyCommandFrom(*inviter))
-                {
-                    std::string buf = "I can't accept your invite unless you first invite my master ";
-                    buf += GetMaster()->GetName();
-                    buf += ".";
-                    SendWhisper(buf, *inviter);
-                    m_bot->GetSession()->HandleGroupDeclineOpcode(p); // packet not used
-                }
-                else
-                    m_bot->GetSession()->HandleGroupAcceptOpcode(p);  // packet not used
-            }
-            return;
-        }
-
-        case SMSG_GUILD_INVITE:
-        {
-            Guild* guild = sGuildMgr.GetGuildById(m_bot->GetGuildIdInvited());
-            if (!guild || m_bot->GetGuildId())
-                return;
-
-            // not let enemies sign guild charter
-            if (!sWorld.getConfig(CONFIG_BOOL_ALLOW_TWO_SIDE_INTERACTION_GUILD) && m_bot->GetTeam() != sObjectMgr.GetPlayerTeamByGUID(guild->GetLeaderGuid()))
-                return;
-
-            if (!guild->AddMember(m_bot->GetObjectGuid(), guild->GetLowestRank()))
-                return;
-            // Put record into guild log
-            guild->LogGuildEvent(GUILD_EVENT_LOG_JOIN_GUILD, m_bot->GetObjectGuid());
-
-            guild->BroadcastEvent(GE_JOINED, m_bot->GetObjectGuid(), m_bot->GetName());
-        }
-
-        // Handle when another player opens the trade window with the bot
-        // also sends list of tradable items bot can trade if bot is allowed to obey commands from
-        case SMSG_TRADE_STATUS:
-        {
-            if (m_bot->GetTrader() == nullptr)
-                break;
-
-            WorldPacket p(packet);
-            uint32 status;
-            p >> status;
-            p.resize(4);
-
-            //4 == TRADE_STATUS_TRADE_ACCEPT
-            if (status == 4)
-            {
-                m_bot->GetSession()->HandleAcceptTradeOpcode(p);  // packet not used
-                SetQuestNeedItems();
-                AutoUpgradeEquipment();
-            }
-
-            //1 == TRADE_STATUS_BEGIN_TRADE
-            else if (status == 1)
-            {
-                m_bot->GetSession()->HandleBeginTradeOpcode(p); // packet not used
-
-                if (!canObeyCommandFrom(*(m_bot->GetTrader())))
-                {
-                    // TODO: Really? What if I give a bot all my junk so it's inventory is full when a nice green/blue/purple comes along?
-                    SendWhisper("I'm not allowed to trade you any of my items, but you are free to give me money or items.", *(m_bot->GetTrader()));
-                    return;
-                }
-
-                // list out items available for trade
-                std::ostringstream out;
-                std::list<std::string> lsItemsTradable;
-                std::list<std::string> lsItemsUntradable;
-
-                // list out items in main backpack
-                for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
-                {
-                    const Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
-                    if (pItem)
-                    {
-                        MakeItemLink(pItem, out, true);
-                        if (pItem->CanBeTraded())
-                            lsItemsTradable.push_back(out.str());
-                        else
-                            lsItemsUntradable.push_back(out.str());
-                        out.str("");
-                    }
-                }
-
-                // list out items in other removable backpacks
-                for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
-                {
-                    const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
-                    if (pBag)
-                    {
-                        // Very cool, but unnecessary
-                        //const ItemPrototype* const pBagProto = pBag->GetProto();
-                        //std::string bagName = pBagProto->Name1;
-                        //ItemLocalization(bagName, pBagProto->ItemId);
-
-                        for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
-                        {
-                            const Item* const pItem = m_bot->GetItemByPos(bag, slot);
-                            if (pItem)
-                            {
-                                MakeItemLink(pItem, out, true);
-                                if (pItem->CanBeTraded())
-                                    lsItemsTradable.push_back(out.str());
-                                else
-                                    lsItemsUntradable.push_back(out.str());
-                                out.str("");
-                            }
-                        }
-                    }
-                }
-
-                ChatHandler ch(m_bot->GetTrader());
-                out.str("");
-                out << "Items I have but cannot trade:";
-                uint32 count = 0;
-                for (std::list<std::string>::iterator iter = lsItemsUntradable.begin(); iter != lsItemsUntradable.end(); iter++)
-                {
-                    out << (*iter);
-                    // Why this roundabout way of posting max 20 items per whisper? To keep the list scrollable.
-                    count++;
-                    if (count % 20 == 0)
-                    {
-                        ch.SendSysMessage(out.str().c_str());
-                        out.str("");
-                    }
-                }
-                if (count > 0)
-                    ch.SendSysMessage(out.str().c_str());
-
-                out.str("");
-                out << "I could give you:";
-                count = 0;
-                for (std::list<std::string>::iterator iter = lsItemsTradable.begin(); iter != lsItemsTradable.end(); iter++)
-                {
-                    out << (*iter);
-                    // Why this roundabout way of posting max 20 items per whisper? To keep the list scrollable.
-                    count++;
-                    if (count % 20 == 0)
-                    {
-                        ch.SendSysMessage(out.str().c_str());
-                        out.str("");
-                    }
-                }
-                if (count > 0)
-                    ch.SendSysMessage(out.str().c_str());
-                else
-                    ch.SendSysMessage("I have nothing to give you.");
-
-                // calculate how much money bot has
-                // send bot the message
-                uint32 copper = m_bot->GetMoney();
-                out.str("");
-                out << "I have |cff00ff00" << Cash(copper) << "|r";
-                SendWhisper(out.str().c_str(), *(m_bot->GetTrader()));
-            }
-            return;
-        }
-
-        case SMSG_SPELL_START:
-        {
-
-            WorldPacket p(packet);
-
-            ObjectGuid castItemGuid;
-            p >> castItemGuid.ReadAsPacked();
-            ObjectGuid casterGuid;
-            p >> casterGuid.ReadAsPacked();
-            if (casterGuid != m_bot->GetObjectGuid())
-                return;
-
-            uint32 spellId;
-            p >> spellId;
-            uint8 cast_count;
-            p >> cast_count;
-            uint16 castFlags;
-            p >> castFlags;
-            uint32 msTime;
-            p >> msTime;
-
-            // DEBUG_LOG("castItemGuid (%s) casterItemGuid(%s) spellId (%u) cast_count (%u) castFlags (%u) msTime (%u)",castItemGuid.GetString().c_str(),casterGuid.GetString().c_str(), spellId, cast_count, castFlags, msTime);
-
-            const SpellEntry* const pSpellInfo = sSpellTemplate.LookupEntry<SpellEntry>(spellId);
-            if (!pSpellInfo)
-                return;
-
-            if (pSpellInfo->AuraInterruptFlags & AURA_INTERRUPT_FLAG_NOT_SEATED)
-                return;
-
-            uint32 CastingTime = !IsChanneledSpell(pSpellInfo) ? GetSpellCastTime(pSpellInfo) : GetSpellDuration(pSpellInfo);
-
-            SetIgnoreUpdateTime((msTime / 1000) + 1);
-
-            return;
-        }
-
-        case SMSG_SPELL_GO:
-        {
-            WorldPacket p(packet);
-
-            ObjectGuid castItemGuid;
-            p >> castItemGuid.ReadAsPacked();
-            ObjectGuid casterGuid;
-            p >> casterGuid.ReadAsPacked();
-            if (casterGuid != m_bot->GetObjectGuid())
-                return;
-
-            uint32 spellId;
-            p >> spellId;
-            uint16 castFlags;
-            p >> castFlags;
-
-            return;
-        }
-
-        // if someone tries to resurrect, then accept
-        case SMSG_RESURRECT_REQUEST:
-        {
-            if (!m_bot->isAlive())
-            {
-                WorldPacket p(packet);
-                ObjectGuid guid;
-                p >> guid;
-
-                std::unique_ptr<WorldPacket> packet(new WorldPacket(CMSG_RESURRECT_RESPONSE, 8 + 1));
-                *packet << guid;
-                *packet << uint8(1);                        // accept
-                m_bot->GetSession()->QueuePacket(std::move(packet));   // queue the packet to get around race condition
-
-                // set back to normal
-                SetState(BOTSTATE_NORMAL);
-                SetIgnoreUpdateTime(0);
-            }
-            return;
-        }
-
-        case SMSG_LOOT_RESPONSE:
-        {
-            WorldPacket p(packet); // (8+1+4+1+1+4+4+4+4+4+1)
-            ObjectGuid guid;
-            uint8 loot_type;
-            uint32 gold;
-            uint8 items;
-
-            p >> guid;      // 8 corpse guid
-            p >> loot_type; // 1 loot type
-            p >> gold;      // 4 gold
-            p >> items;     // 1 items count
-
-            if (gold > 0)
-            {
-                WorldPacket* const packet = new WorldPacket(CMSG_LOOT_MONEY, 0);
-                m_bot->GetSession()->QueuePacket(std::move(std::unique_ptr<WorldPacket>(packet)));
-            }
-
-            for (uint8 i = 0; i < items; ++i)
-            {
-                uint32 itemid;
-                uint32 itemcount;
-                uint8 lootslot_type;
-                uint8 itemindex;
-
-                p >> itemindex;         // 1 counter
-                p >> itemid;            // 4 itemid
-                p >> itemcount;         // 4 item stack count
-                p.read_skip<uint32>();  // 4 item model
-                p.read_skip<uint32>();  // 4 randomSuffix
-                p.read_skip<uint32>();  // 4 randomPropertyId
-                p >> lootslot_type;     // 1 LootSlotType
-
-                if (lootslot_type != LOOT_SLOT_NORMAL && lootslot_type != LOOT_SLOT_OWNER)
-                    continue;
-
-                // skinning or collect loot flag = just auto loot everything for getting object
-                // corpse = run checks
-                if (loot_type == LOOT_SKINNING || HasCollectFlag(COLLECT_FLAG_LOOT) ||
-                        (loot_type == LOOT_CORPSE && (IsInQuestItemList(itemid) || IsItemUseful(itemid))))
-                {
-                    WorldPacket* const packet = new WorldPacket(CMSG_AUTOSTORE_LOOT_ITEM, 1);
-                    *packet << itemindex;
-                    m_bot->GetSession()->QueuePacket(std::move(std::unique_ptr<WorldPacket>(packet)));
-                }
-            }
-
-            // release loot
-            WorldPacket* const packet = new WorldPacket(CMSG_LOOT_RELEASE, 8);
-            *packet << guid;
-            m_bot->GetSession()->QueuePacket(std::move(std::unique_ptr<WorldPacket>(packet)));
-
-            return;
-        }
-
-        case SMSG_LOOT_RELEASE_RESPONSE:
-        {
-            WorldPacket p(packet);
-            ObjectGuid guid;
-
-            p >> guid;
-
-            if (guid == m_lootCurrent)
-            {
-
-                Creature* c = m_bot->GetMap()->GetCreature(m_lootCurrent);
-
-                if (c && c->GetCreatureInfo()->SkinningLootId && c->GetLootStatus() != CREATURE_LOOT_STATUS_LOOTED)
-                {
-                    uint32 reqSkill = c->GetCreatureInfo()->GetRequiredLootSkill();
-                    // check if it is a leather skin and if it is to be collected (could be ore or herb)
-                    if (m_bot->HasSkill(reqSkill) && ((reqSkill != SKILL_SKINNING) ||
-                                                      (HasCollectFlag(COLLECT_FLAG_SKIN) && reqSkill == SKILL_SKINNING)))
-                    {
-                        // calculate skill requirement
-                        uint32 skillValue = m_bot->GetSkillValue(reqSkill);
-                        uint32 targetLevel = c->getLevel();
-                        uint32 reqSkillValue = targetLevel < 10 ? 0 : targetLevel < 20 ? (targetLevel - 10) * 10 : targetLevel * 5;
-                        if (skillValue >= reqSkillValue)
-                        {
-                            if (m_lootCurrent != m_lootPrev)    // if this wasn't previous loot try again
-                            {
-                                m_lootPrev = m_lootCurrent;
-                                SetIgnoreUpdateTime(3);
-                                return; // so that the DoLoot function is called again to get skin
-                            }
-                        }
-                        else
-                            TellMaster("My skill is %u but it requires %u", skillValue, reqSkillValue);
-                    }
-                }
-
-                // if previous is current, clear
-                if (m_lootPrev == m_lootCurrent)
-                    m_lootPrev = ObjectGuid();
-                // clear current target
-                m_lootCurrent = ObjectGuid();
-                // clear movement
-                m_bot->GetMotionMaster()->Clear(false);
-                m_bot->GetMotionMaster()->MoveIdle();
-                SetIgnoreUpdateTime(0);
-            }
-
-            return;
-        }
-
-        case SMSG_LOOT_ROLL_WON:
-        {
-            WorldPacket p(packet);   // (8+4+4+4+4+8+1+1)
-            ObjectGuid guid;
-            uint32 itemid;
-
-            p.read_skip<ObjectGuid>(); // creature guid what we're looting
-            p.read_skip<uint32>();   // item slot in loot
-            p >> itemid;             // the itemEntryId for the item that shall be rolled fo
-            p.read_skip<uint32>();   // randomSuffix
-            p.read_skip<uint32>();   // Item random property
-            p >> guid;               // guid of the player who won
-            p.read_skip<uint8>();    // rollnumber related to SMSG_LOOT_ROLL
-            p.read_skip<uint8>();    // Rolltype related to SMSG_LOOT_ROLL
-
-            if (m_bot->GetObjectGuid() != guid)
-                return;
-
-            SetState(BOTSTATE_DELAYED);
-
-            /*            ItemPrototype const *pProto = ObjectMgr::GetItemPrototype(itemid);
-                        if(pProto)
-                        {
-                            std::ostringstream out;
-                            out << "|cff009900" << "I won: |r";
-                            MakeItemLink(pProto,out);
-                            if (FindItem(itemid,true))
-                                out << "and have the item";
-                            TellMaster(out.str().c_str());
-                        }*/
-            return;
-        }
-
-        case SMSG_PARTYKILLLOG:
-        {
-            // reset AI delay so bots immediately respond to next combat target & or looting/skinning
-            SetIgnoreUpdateTime(0);
-            return;
-        }
-
-        case SMSG_ITEM_PUSH_RESULT:
-        {
-            WorldPacket p(packet);  // (8+4+4+4+1+4+4+4+4+4+4)
-            ObjectGuid guid;
-
-            p >> guid;              // 8 player guid
-            if (m_bot->GetObjectGuid() != guid)
-                return;
-
-            uint8 bagslot;
-            uint32 itemslot, itemid, count, totalcount, received, created;
-
-            p >> received;          // 4 0=looted, 1=from npc
-            p >> created;           // 4 0=received, 1=created
-            p.read_skip<uint32>();  // 4 IsShowChatMessage
-            p >> bagslot;           // 1 bagslot
-            p >> itemslot;          // 4 item slot, but when added to stack: 0xFFFFFFFF
-            p >> itemid;            // 4 item entry id
-            p.read_skip<uint32>();  // 4 SuffixFactor
-            p.read_skip<uint32>();  // 4 random item property id
-            p >> count;             // 4 count of items
-            p >> totalcount;        // 4 count of items in inventory
-
-            ItemPrototype const* pProto = ObjectMgr::GetItemPrototype(itemid);
-            if (pProto)
-            {
-                std::ostringstream out;
-                if (received == 1)
-                {
-                    if (created == 1)
-                        out << "|cff009900" << "I created: |r";
-                    else
-                        out << "|cff009900" << "I received: |r";
-                    MakeItemLink(pProto, out);
-                    TellMaster(out.str().c_str());
-                    SetState(BOTSTATE_DELAYED);
-                }
-            }
-
-            if (IsInQuestItemList(itemid))
-            {
-                m_needItemList[itemid] = (m_needItemList[itemid] - count);
-                if (m_needItemList[itemid] <= 0)
-                    m_needItemList.erase(itemid);
-            }
-
-            return;
-        }
-
-        /* uncomment this and your bots will tell you all their outgoing packet opcode names
-           case SMSG_MONSTER_MOVE:
-           case SMSG_UPDATE_WORLD_STATE:
-           case SMSG_COMPRESSED_UPDATE_OBJECT:
-           case MSG_MOVE_SET_FACING:
-           case MSG_MOVE_STOP:
-           case MSG_MOVE_HEARTBEAT:
-           case MSG_MOVE_STOP_STRAFE:
-           case MSG_MOVE_START_STRAFE_LEFT:
-           case SMSG_UPDATE_OBJECT:
-           case MSG_MOVE_START_FORWARD:
-           case MSG_MOVE_START_STRAFE_RIGHT:
-           case SMSG_DESTROY_OBJECT:
-           case MSG_MOVE_START_BACKWARD:
-           case SMSG_AURA_UPDATE_ALL:
-           case MSG_MOVE_FALL_LAND:
-           case MSG_MOVE_JUMP:
-            return;*/
-
-        default:
-        {
-            /*const char* oc = LookupOpcodeName(packet.GetOpcode());
-
-            std::ostringstream out;
-            out << "botout: " << oc;
-            sLog.outError(out.str().c_str());
-
-            TellMaster(oc);*/
-        }
-    }
-}
-
-uint8 PlayerbotAI::GetHealthPercent(const Unit& target) const
-{
-    return (static_cast<float>(target.GetHealth()) / target.GetMaxHealth()) * 100;
-}
-
-uint8 PlayerbotAI::GetHealthPercent() const
-{
-    return GetHealthPercent(*m_bot);
-}
-
-uint8 PlayerbotAI::GetManaPercent(const Unit& target) const
-{
-    return (static_cast<float>(target.GetPower(POWER_MANA)) / target.GetMaxPower(POWER_MANA)) * 100;
-}
-
-uint8 PlayerbotAI::GetManaPercent() const
-{
-    return GetManaPercent(*m_bot);
-}
-
-uint8 PlayerbotAI::GetBaseManaPercent(const Unit& target) const
-{
-    if (target.GetPower(POWER_MANA) >= target.GetCreateMana())
-        return (100);
-    else
-        return (static_cast<float>(target.GetPower(POWER_MANA)) / target.GetCreateMana()) * 100;
-}
-
-uint8 PlayerbotAI::GetBaseManaPercent() const
-{
-    return GetBaseManaPercent(*m_bot);
-}
-
-uint8 PlayerbotAI::GetRageAmount(const Unit& target) const
-{
-    return (static_cast<float>(target.GetPower(POWER_RAGE)));
-}
-
-uint8 PlayerbotAI::GetRageAmount() const
-{
-    return GetRageAmount(*m_bot);
-}
-
-uint8 PlayerbotAI::GetEnergyAmount(const Unit& target) const
-{
-    return (static_cast<float>(target.GetPower(POWER_ENERGY)));
-}
-
-uint8 PlayerbotAI::GetEnergyAmount() const
-{
-    return GetEnergyAmount(*m_bot);
-}
-
-bool PlayerbotAI::HasAura(uint32 spellId, const Unit& player) const
-{
-    if (spellId <= 0)
-        return false;
-
-    for (Unit::SpellAuraHolderMap::const_iterator iter = player.GetSpellAuraHolderMap().begin(); iter != player.GetSpellAuraHolderMap().end(); ++iter)
-    {
-        if (iter->second->GetId() == spellId)
-            return true;
-    }
-    return false;
-}
-
-bool PlayerbotAI::HasAura(const char* spellName) const
-{
-    return HasAura(spellName, *m_bot);
-}
-
-bool PlayerbotAI::HasAura(const char* spellName, const Unit& player) const
-{
-    uint32 spellId = getSpellId(spellName);
-    return (spellId) ? HasAura(spellId, player) : false;
-}
-
-// looks through all items / spells that bot could have to get a mount
-Item* PlayerbotAI::FindMount(uint32 matchingRidingSkill) const
-{
-    // list out items in main backpack
-
-    Item* partialMatch = nullptr;
-
-    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
-    {
-        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
-        if (pItem)
-        {
-            const ItemPrototype* const pItemProto = pItem->GetProto();
-            if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK || pItemProto->RequiredSkill != SKILL_RIDING)
-                continue;
-
-            if (pItemProto->RequiredSkillRank == matchingRidingSkill)
-                return pItem;
-
-            else if (!partialMatch || (partialMatch && partialMatch->GetProto()->RequiredSkillRank < pItemProto->RequiredSkillRank))
-                partialMatch = pItem;
-        }
-    }
-
-    // list out items in other removable backpacks
-    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
-    {
-        const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
-        if (pBag)
-            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
-            {
-                Item* const pItem = m_bot->GetItemByPos(bag, slot);
-                if (pItem)
-                {
-                    const ItemPrototype* const pItemProto = pItem->GetProto();
-                    if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK || pItemProto->RequiredSkill != SKILL_RIDING)
-                        continue;
-
-                    if (pItemProto->RequiredSkillRank == matchingRidingSkill)
-                        return pItem;
-
-                    else if (!partialMatch || (partialMatch && partialMatch->GetProto()->RequiredSkillRank < pItemProto->RequiredSkillRank))
-                        partialMatch = pItem;
-                }
-            }
-    }
-    return partialMatch;
-}
-
-Item* PlayerbotAI::FindFood() const
-{
-    // list out items in main backpack
-    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
-    {
-        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
-        if (pItem)
-        {
-            const ItemPrototype* const pItemProto = pItem->GetProto();
-            if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
-                continue;
-
-            if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_FOOD)
-                // if is FOOD
-                // this enum is no longer defined in mangos. Is it no longer valid?
-                // according to google it was 11
-                if (pItemProto->Spells[0].SpellCategory == 11)
-                    return pItem;
-        }
-    }
-    // list out items in other removable backpacks
-    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
-    {
-        const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
-        if (pBag)
-            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
-            {
-                Item* const pItem = m_bot->GetItemByPos(bag, slot);
-                if (pItem)
-                {
-                    const ItemPrototype* const pItemProto = pItem->GetProto();
-
-                    if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
-                        continue;
-
-                    // this enum is no longer defined in mangos. Is it no longer valid?
-                    // according to google it was 11
-                    if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_FOOD)
-                        // if is FOOD
-                        // this enum is no longer defined in mangos. Is it no longer valid?
-                        // according to google it was 11
-                        // if (pItemProto->Spells[0].SpellCategory == SPELL_CATEGORY_FOOD)
-                        if (pItemProto->Spells[0].SpellCategory == 11)
-                            return pItem;
-                }
-            }
-    }
-    return nullptr;
-}
-
-Item* PlayerbotAI::FindDrink() const
-{
-    // list out items in main backpack
-    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
-    {
-        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
-        if (pItem)
-        {
-            const ItemPrototype* const pItemProto = pItem->GetProto();
-
-            if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
-                continue;
-
-            if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_FOOD)
-                // if (pItemProto->Spells[0].SpellCategory == SPELL_CATEGORY_DRINK)
-
-                // this enum is no longer defined in mangos. Is it no longer valid?
-                // according to google it was 59
-                // if (pItemProto->Spells[0].SpellCategory == 59)
-                if (pItemProto->Spells[0].SpellCategory == 59)
-                    return pItem;
-        }
-    }
-    // list out items in other removable backpacks
-    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
-    {
-        const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
-        if (pBag)
-            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
-            {
-                Item* const pItem = m_bot->GetItemByPos(bag, slot);
-                if (pItem)
-                {
-                    const ItemPrototype* const pItemProto = pItem->GetProto();
-
-                    if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
-                        continue;
-
-                    if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_FOOD)
-                        // if is WATER
-                        // SPELL_CATEGORY_DRINK is no longer defined in an enum in mangos
-                        // google says the valus is 59. Is this still valid?
-                        // if (pItemProto->Spells[0].SpellCategory == SPELL_CATEGORY_DRINK)
-                        if (pItemProto->Spells[0].SpellCategory == 59)
-                            return pItem;
-                }
-            }
-    }
-    return nullptr;
-}
-
-Item* PlayerbotAI::FindBandage() const
-{
-    // list out items in main backpack
-    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
-    {
-        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
-        if (pItem)
-        {
-            const ItemPrototype* const pItemProto = pItem->GetProto();
-
-            if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
-                continue;
-
-            if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_BANDAGE)
-                return pItem;
-        }
-    }
-    // list out items in other removable backpacks
-    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
-    {
-        const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
-        if (pBag)
-            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
-            {
-                Item* const pItem = m_bot->GetItemByPos(bag, slot);
-                if (pItem)
-                {
-                    const ItemPrototype* const pItemProto = pItem->GetProto();
-
-                    if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
-                        continue;
-
-                    if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_BANDAGE)
-                        return pItem;
-                }
-            }
-    }
-    return nullptr;
-}
-
-Item* PlayerbotAI::FindConsumable(uint32 displayId) const
-{
-    // list out items in main backpack
-    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
-    {
-        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
-        if (pItem)
-        {
-            const ItemPrototype* const pItemProto = pItem->GetProto();
-
-            if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
-                continue;
-
-            if ((pItemProto->Class == ITEM_CLASS_CONSUMABLE || pItemProto->Class == ITEM_SUBCLASS_BANDAGE) && pItemProto->DisplayInfoID == displayId)
-                return pItem;
-        }
-    }
-    // list out items in other removable backpacks
-    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
-    {
-        const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
-        if (pBag)
-            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
-            {
-                Item* const pItem = m_bot->GetItemByPos(bag, slot);
-                if (pItem)
-                {
-                    const ItemPrototype* const pItemProto = pItem->GetProto();
-
-                    if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
-                        continue;
-
-                    if ((pItemProto->Class == ITEM_CLASS_CONSUMABLE || pItemProto->Class == ITEM_SUBCLASS_BANDAGE) && pItemProto->DisplayInfoID == displayId)
-                        return pItem;
-                }
-            }
-    }
-    return nullptr;
-}
-
-static const uint32 uPriorizedSharpStoneIds[8] =
-{
-    ADAMANTITE_SHARPENING_DISPLAYID, FEL_SHARPENING_DISPLAYID, ELEMENTAL_SHARPENING_DISPLAYID, DENSE_SHARPENING_DISPLAYID,
-    SOLID_SHARPENING_DISPLAYID, HEAVY_SHARPENING_DISPLAYID, COARSE_SHARPENING_DISPLAYID, ROUGH_SHARPENING_DISPLAYID
-};
-
-static const uint32 uPriorizedWeightStoneIds[7] =
-{
-    ADAMANTITE_WEIGHTSTONE_DISPLAYID, FEL_WEIGHTSTONE_DISPLAYID, DENSE_WEIGHTSTONE_DISPLAYID, SOLID_WEIGHTSTONE_DISPLAYID,
-    HEAVY_WEIGHTSTONE_DISPLAYID, COARSE_WEIGHTSTONE_DISPLAYID, ROUGH_WEIGHTSTONE_DISPLAYID
-};
-
-/**
- * FindStoneFor()
- * return Item* Returns sharpening/weight stone item eligible to enchant a bot weapon
- *
- * params:weapon Item* the weapn the function should search and return a enchanting item for
- * return nullptr if no relevant item is found in bot inventory, else return a sharpening or weight
- * stone based on the weapon subclass
- *
- */
-Item* PlayerbotAI::FindStoneFor(Item* weapon) const
-{
-    Item* stone;
-    ItemPrototype const* pProto = weapon->GetProto();
-    if (pProto && (pProto->SubClass == ITEM_SUBCLASS_WEAPON_SWORD || pProto->SubClass == ITEM_SUBCLASS_WEAPON_SWORD2
-                   || pProto->SubClass == ITEM_SUBCLASS_WEAPON_AXE || pProto->SubClass == ITEM_SUBCLASS_WEAPON_AXE2
-                   || pProto->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER))
-    {
-        for (uint8 i = 0; i < countof(uPriorizedSharpStoneIds); ++i)
-        {
-            stone = FindConsumable(uPriorizedSharpStoneIds[i]);
-            if (stone)
-                return stone;
-        }
-    }
-    else if (pProto && (pProto->SubClass == ITEM_SUBCLASS_WEAPON_MACE || pProto->SubClass == ITEM_SUBCLASS_WEAPON_MACE2))
-    {
-        for (uint8 i = 0; i < countof(uPriorizedWeightStoneIds); ++i)
-        {
-            stone = FindConsumable(uPriorizedWeightStoneIds[i]);
-            if (stone)
-                return stone;
-        }
-    }
-
-    return nullptr;
-}
-
-static const uint32 uPriorizedManaPotionIds[12] =
-{
-    FEL_MANA_POTION, CRYSTAL_MANA_POTION, SUPER_MANA_POTION, UNSTABLE_MANA_POTION,
-    MAJOR_MANA_POTION, MAJOR_REJUVENATION_POTION, SUPERIOR_MANA_POTION,
-    GREATER_MANA_POTION, MANA_POTION, LESSER_MANA_POTION,
-    MINOR_MANA_POTION, MINOR_REJUVENATION_POTION
-};
-
-/**
- * FindManaRegenItem()
- * return Item* Returns items like runes or potion that can help the bot to instantly resplenish some of its mana
- *
- * return nullptr if no relevant item is found in bot inventory, else return a consumable item providing mana
- *
- */
-Item* PlayerbotAI::FindManaRegenItem() const
-{
-    Item* manaRegen;
-    // If bot has enough health, try to use a Demonic or Dark Rune
-    // to avoid triggering the health potion cooldown with a mana potion
-    if (m_bot->GetHealth() > 1500)
-    {
-        // First try a Demonic Rune as they are BoP
-        manaRegen = FindConsumable(DEMONIC_RUNE);
-        if (manaRegen)
-            return manaRegen;
-        else
-        {
-            manaRegen = FindConsumable(DARK_RUNE);
-            if (manaRegen)
-                return manaRegen;
-        }
-    }
-    // Else use mana potion (and knowingly trigger the health potion cooldown)
-    for (uint8 i = 0; i < countof(uPriorizedManaPotionIds); ++i)
-    {
-        manaRegen = FindConsumable(uPriorizedManaPotionIds[i]);
-        if (manaRegen)
-            return manaRegen;
-    }
-
-    return nullptr;
-}
-
-bool PlayerbotAI::FindAmmo() const
-{
-    for (int i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
-    {
-        Item* pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
-        if (pItem)
-        {
-            const ItemPrototype* const pItemProto = pItem->GetProto();
-
-            if (pItemProto->Class == ITEM_CLASS_PROJECTILE && m_bot->CheckAmmoCompatibility(pItemProto))
-            {
-                m_bot->SetAmmo(pItem->GetEntry());
-                return true;
-            }
-        }
-    }
-    for (int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
-    {
-        if (Bag* pBag = (Bag*)m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
-        {
-            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
-            {
-                Item* pItem = m_bot->GetItemByPos(i, j);
-                if (pItem)
-                {
-                    const ItemPrototype* const pItemProto = pItem->GetProto();
-
-                    if (pItemProto->Class == ITEM_CLASS_PROJECTILE && m_bot->CheckAmmoCompatibility(pItemProto))
-                    {
-                        m_bot->SetAmmo(pItem->GetEntry());
-                        return true;
-                    }
-                }
-            }
-        }
-    }
-    return false;
-}
-
-void PlayerbotAI::InterruptCurrentCastingSpell()
-{
-    // TellMaster("I'm interrupting my current spell!");
-    std::unique_ptr<WorldPacket> packet(new WorldPacket(CMSG_CANCEL_CAST, 5));  //changed from thetourist suggestion
-    *packet << m_CurrentlyCastingSpellId;
-    *packet << m_targetGuidCommand;   //changed from thetourist suggestion
-    m_CurrentlyCastingSpellId = 0;
-    m_bot->GetSession()->QueuePacket(std::move(packet));
-}
-
-// intelligently sets a reasonable combat order for this bot
-// based on its class / level / etc
-void PlayerbotAI::Attack(Unit* forcedTarget)
-{
-    // set combat state, and clear looting, etc...
-    if (m_botState != BOTSTATE_COMBAT)
-    {
-        SetState(BOTSTATE_COMBAT);
-        // m_lootCurrent = ObjectGuid(); This was clearing loot target, causing bots to leave corpses unlooted if interupted by combat. Needs testing.
-        // using this caused bot to remove current loot target, and add this new threat to the loot list.  Now it remembers the loot target and adds a new one.
-        // Bot will still clear the target if the master gets too far away from it.
-        m_targetCombat = 0;
-        m_DelayAttackInit = CurrentTime(); // Combat started, new start time to check CombatDelay for.
-    }
-
-    GetCombatTarget(forcedTarget);
-
-    if (!m_targetCombat)
-        return;
-
-    m_bot->Attack(m_targetCombat, true);
-
-    // add thingToAttack to loot list
-    m_lootTargets.push_back(m_targetCombat->GetObjectGuid());
-}
-
-// intelligently sets a reasonable combat order for this bot
-// based on its class / level / etc
-void PlayerbotAI::GetCombatTarget(Unit* forcedTarget)
-{
-    // update attacker info now
-    UpdateAttackerInfo();
-
-    // check for attackers on protected unit, and make it a forcedTarget if any
-    if (!forcedTarget && (m_combatOrder & ORDERS_PROTECT) && m_targetProtect)
-    {
-        Unit* newTarget = FindAttacker((ATTACKERINFOTYPE)(AIT_VICTIMNOTSELF | AIT_HIGHESTTHREAT), m_targetProtect);
-        if (newTarget && newTarget != m_targetCombat)
-        {
-            forcedTarget = newTarget;
-            m_targetType = TARGET_THREATEN;
-            if (m_mgr->m_confDebugWhisper)
-                TellMaster("Changing target to %s to protect %s", forcedTarget->GetName(), m_targetProtect->GetName());
-        }
-    }
-    else if (forcedTarget)
-    {
-        if (m_mgr->m_confDebugWhisper)
-            TellMaster("Changing target to %s by force!", forcedTarget->GetName());
-        m_targetType = (m_combatOrder & ORDERS_TANK ? TARGET_THREATEN : TARGET_NORMAL);
-    }
-
-    // we already have a target and we are not forced to change it
-    if (m_targetCombat && !forcedTarget)
-        return;
-
-    // forced to change target to current target == null operation
-    if (forcedTarget && forcedTarget == m_targetCombat)
-        return;
-
-    // are we forced on a target?
-    if (forcedTarget)
-    {
-        m_targetCombat = forcedTarget;
-        m_targetChanged = true;
-    }
-    // do we have to assist someone?
-    if (!m_targetCombat && (m_combatOrder & ORDERS_ASSIST) && m_targetAssist)
-    {
-        m_targetCombat = FindAttacker((ATTACKERINFOTYPE)(AIT_VICTIMNOTSELF | AIT_LOWESTTHREAT), m_targetAssist);
-        if (m_mgr->m_confDebugWhisper && m_targetCombat)
-            TellMaster("Attacking %s to assist %s", m_targetCombat->GetName(), m_targetAssist->GetName());
-        m_targetType = (m_combatOrder & ORDERS_TANK ? TARGET_THREATEN : TARGET_NORMAL);
-        m_targetChanged = true;
-    }
-    // are there any other attackers?
-    if (!m_targetCombat)
-    {
-        m_targetCombat = FindAttacker();
-        m_targetType = (m_combatOrder & ORDERS_TANK ? TARGET_THREATEN : TARGET_NORMAL);
-        m_targetChanged = true;
-    }
-    // no attacker found anyway
-    if (!m_targetCombat)
-    {
-        m_targetType = TARGET_NORMAL;
-        m_targetChanged = false;
-        return;
-    }
-
-    // if thing to attack is in a duel, then ignore and don't call updateAI for 6 seconds
-    // this method never gets called when the bot is in a duel and this code
-    // prevents bot from helping
-    if (m_targetCombat->GetTypeId() == TYPEID_PLAYER && dynamic_cast<Player*>(m_targetCombat)->duel)
-    {
-        SetIgnoreUpdateTime(6);
-        return;
-    }
-
-    m_bot->SetSelectionGuid((m_targetCombat->GetObjectGuid()));
-    SetIgnoreUpdateTime(1);
-
-    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
-        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
-}
-
-void PlayerbotAI::GetDuelTarget(Unit* forcedTarget)
-{
-    // set combat state, and clear looting, etc...
-    if (m_botState != BOTSTATE_COMBAT)
-    {
-        SetState(BOTSTATE_COMBAT);
-        m_targetChanged = true;
-        m_targetCombat = forcedTarget;
-        m_targetType = TARGET_THREATEN;
-        m_combatStyle = COMBAT_MELEE;
-    }
-    m_bot->Attack(m_targetCombat, true);
-}
-
-void PlayerbotAI::DoNextCombatManeuver()
-{
-    if (!GetClassAI())
-        return; // error, error...
-
-    if (m_combatOrder == ORDERS_PASSIVE)
-        return;
-
-    // check for new targets
-    if (m_ScenarioType == SCENARIO_PVP_DUEL)
-        GetDuelTarget(GetMaster()); // TODO: Wow... wait... what? So not right.
-    else
-        Attack();
-
-    // clear orders if current target for attacks doesn't make sense anymore
-    if (!m_targetCombat || m_targetCombat->isDead() || !m_targetCombat->IsInWorld() || !m_bot->CanAttack(m_targetCombat) || !m_bot->IsInMap(m_targetCombat))
-    {
-        m_bot->AttackStop();
-        m_bot->SetSelectionGuid(ObjectGuid());
-        MovementReset();
-        m_bot->InterruptNonMeleeSpells(true);
-        m_targetCombat = 0;
-        m_targetChanged = false;
-        m_targetType = TARGET_NORMAL;
-        SetQuestNeedCreatures();
-        if (GetCombatOrder() & ORDERS_TEMP)
-        {
-            if (GetCombatOrder() & ORDERS_TEMP_WAIT_TANKAGGRO)
-                TellMaster("I was still waiting for the tank to gain aggro, but that doesn't make sense anymore...");
-            if (GetCombatOrder() & ORDERS_TEMP_WAIT_OOC)
-                TellMaster("I was still waiting OOC but that was way off...");
-            ClearCombatOrder(ORDERS_TEMP);
-        }
-        return;
-    }
-
-    // new target -> DoFirstCombatManeuver
-    if (m_targetChanged)
-    {
-        switch (GetClassAI()->DoFirstCombatManeuver(m_targetCombat))
-        {
-            case RETURN_CONTINUE: // true needed for rogue stealth attack
-                break;
-
-            case RETURN_NO_ACTION_ERROR:
-                TellMaster("FirstCombatManeuver: No action performed due to error. Heading onto NextCombatManeuver.");
-            case RETURN_FINISHED_FIRST_MOVES: // false default
-            case RETURN_NO_ACTION_UNKNOWN:
-            case RETURN_NO_ACTION_OK:
-            default: // assume no action -> no return
-                m_targetChanged = false;
-        }
-    }
-
-    // do normal combat movement
-    DoCombatMovement();
-
-    if (!m_targetChanged)
-    {
-        // if m_targetChanged = false
-        switch (GetClassAI()->DoNextCombatManeuver(m_targetCombat))
-        {
-            case RETURN_NO_ACTION_UNKNOWN:
-            case RETURN_NO_ACTION_OK:
-            case RETURN_CONTINUE:
-            case RETURN_NO_ACTION_ERROR:
-            default:
-                return;
-        }
-    }
-}
-
-void PlayerbotAI::DoCombatMovement()
-{
-    if (!m_targetCombat) return;
-
-    bool meleeReach = m_bot->CanReachWithMeleeAttack(m_targetCombat);
-
-    if (m_combatStyle == COMBAT_MELEE
-            && !m_bot->hasUnitState(UNIT_STAT_CHASE)
-            && ((m_movementOrder == MOVEMENT_STAY && meleeReach) || m_movementOrder != MOVEMENT_STAY)
-            && GetClassAI()->GetWaitUntil() == 0)  // Not waiting
-    {
-        // melee combat - chase target if in range or if we are not forced to stay
-        m_bot->GetMotionMaster()->Clear(false);
-        m_bot->GetMotionMaster()->MoveChase(m_targetCombat);
-    }
-    else if (m_combatStyle == COMBAT_RANGED
-             && m_movementOrder != MOVEMENT_STAY
-             && GetClassAI()->GetWaitUntil() == 0)  // Not waiting
-    {
-        // ranged combat - just move within spell range if bot does not have heal orders
-        if (!CanReachWithSpellAttack(m_targetCombat) && !IsHealer())
-        {
-            m_bot->GetMotionMaster()->Clear(false);
-            m_bot->GetMotionMaster()->MoveChase(m_targetCombat);
-        }
-        else
-            MovementClear();
-    }
-}
-
-/*
- * IsGroupReady()
- *
- * return false if any member of the group is in combat or (error handling only) occupied in some way
- * return true otherwise
- */
-bool PlayerbotAI::IsGroupReady()
-{
-    if (!m_bot) return true;
-    if (!m_bot->isAlive() || m_bot->IsInDuel()) return false; // Let's just say you're otherwise occupied
-    if (m_bot->isInCombat()) return false;
-
-    if (m_bot->GetGroup())
-    {
-        Group::MemberSlotList const& groupSlot = m_bot->GetGroup()->GetMemberSlots();
-        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
-        {
-            Player* groupMember = sObjectMgr.GetPlayer(itr->guid);
-            if (groupMember && groupMember->isAlive())
-            {
-                if (groupMember->IsInDuel() || groupMember->isInCombat())            // all occupied in some way
-                    return false;
-            }
-        }
-    }
-
-    return true;
-}
-
-Player* PlayerbotAI::GetGroupTank()
-{
-    if (!m_bot) return nullptr;
-
-    if (m_bot->GetGroup())
-    {
-        Group::MemberSlotList const& groupSlot = m_bot->GetGroup()->GetMemberSlots();
-        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
-        {
-            Player* groupMember = sObjectMgr.GetPlayer(itr->guid);
-            if (!groupMember || !groupMember->GetPlayerbotAI())
-                return nullptr;
-            if (groupMember->GetPlayerbotAI()->IsTank())
-                return groupMember;
-        }
-    }
-
-    return nullptr;
-}
-
-void PlayerbotAI::SetGroupCombatOrder(CombatOrderType co)
-{
-    if (!m_bot) return;
-
-    if (m_bot->GetGroup())
-    {
-        Group::MemberSlotList const& groupSlot = m_bot->GetGroup()->GetMemberSlots();
-        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
-        {
-            Player* groupMember = sObjectMgr.GetPlayer(itr->guid);
-            if (!groupMember || !groupMember->GetPlayerbotAI())
-                continue;
-            groupMember->GetPlayerbotAI()->SetCombatOrder(co);
-        }
-    }
-    else
-        SetCombatOrder(co);
-}
-
-void PlayerbotAI::ClearGroupCombatOrder(CombatOrderType co)
-{
-    if (!m_bot) return;
-
-    if (m_bot->GetGroup())
-    {
-        Group::MemberSlotList const& groupSlot = m_bot->GetGroup()->GetMemberSlots();
-        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
-        {
-            Player* groupMember = sObjectMgr.GetPlayer(itr->guid);
-            if (!groupMember || !groupMember->GetPlayerbotAI())
-                continue;
-            groupMember->GetPlayerbotAI()->ClearCombatOrder(co);
-        }
-    }
-    else
-        ClearCombatOrder(co);
-}
-
-void PlayerbotAI::SetGroupIgnoreUpdateTime(uint8 t)
-{
-    if (!m_bot) return;
-
-    if (m_bot->GetGroup())
-    {
-        Group::MemberSlotList const& groupSlot = m_bot->GetGroup()->GetMemberSlots();
-        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
-        {
-            Player* groupMember = sObjectMgr.GetPlayer(itr->guid);
-            if (!groupMember || !groupMember->GetPlayerbotAI())
-                continue;
-            groupMember->GetPlayerbotAI()->SetIgnoreUpdateTime(t);
-        }
-    }
-    else
-        SetIgnoreUpdateTime(t);
-}
-
-bool PlayerbotAI::GroupHoTOnTank()
-{
-    if (!m_bot) return false;
-
-    bool bReturn = false;
-
-    if (m_bot->GetGroup())
-    {
-        Group::MemberSlotList const& groupSlot = m_bot->GetGroup()->GetMemberSlots();
-        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
-        {
-            Player* groupMember = sObjectMgr.GetPlayer(itr->guid);
-            if (!groupMember || !groupMember->GetPlayerbotAI())
-                continue;
-            if (groupMember->GetPlayerbotAI()->GetClassAI()->CastHoTOnTank())
-                bReturn = true;
-        }
-
-        if (bReturn)
-        {
-            for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
-            {
-                Player* groupMember = sObjectMgr.GetPlayer(itr->guid);
-                if (!groupMember || !groupMember->GetPlayerbotAI())
-                    continue;
-                groupMember->GetPlayerbotAI()->SetIgnoreUpdateTime(1);
-            }
-        }
-    }
-    else // No group
-    {
-        if (GetClassAI()->CastHoTOnTank())
-        {
-            SetIgnoreUpdateTime(1);
-            return true;
-        }
-    }
-
-    return bReturn;
-}
-
-bool PlayerbotAI::CanPull(Player& fromPlayer)
-{
-    if (!m_bot) return false;
-    if (!GetClassAI()) return false;
-
-    if (!m_bot->GetGroup() || fromPlayer.GetGroup() != m_bot->GetGroup())
-    {
-        SendWhisper("I can't pull - we're not in the same group.", fromPlayer);
-        return false;
-    }
-
-    if (!IsGroupReady()) // TODO: add raid support
-    {
-        SendWhisper("Unable to pull - the group or one of its member is somehow busy.", fromPlayer);
-        return false;
-    }
-
-    if ((GetCombatOrder() & ORDERS_TANK) == 0)
-    {
-        SendWhisper("I cannot pull as I do not have combat orders to tank.", fromPlayer);
-        return false;
-    }
-
-    switch (m_bot->getClass())
-    {
-        case CLASS_PALADIN:
-            if (((PlayerbotPaladinAI*)GetClassAI())->CanPull() == false)
-            {
-                SendWhisper("I cannot pull, I do not have the proper spell or it's not ready yet.", fromPlayer);
-                return false;
-            }
-            break;
-
-        case CLASS_DRUID:
-            if (((PlayerbotDruidAI*)GetClassAI())->CanPull() == false)
-            {
-                SendWhisper("I cannot pull, I do not have the proper spell or it's not ready yet.", fromPlayer);
-                return false;
-            }
-            break;
-
-        case CLASS_WARRIOR:
-            if (((PlayerbotWarriorAI*)GetClassAI())->CanPull() == false)
-            {
-                SendWhisper("I cannot pull, I do not have the proper weapon and/or ammo.", fromPlayer);
-                return false;
-            }
-            break;
-
-        default:
-            SendWhisper("I cannot pull, I am not a tanking class.", fromPlayer);
-            return false;
-    }
-
-    return true;
-}
-
-// This function assumes a "CanPull()" call was preceded (not doing so will result in odd behavior)
-bool PlayerbotAI::CastPull()
-{
-    if (!m_bot) return false;
-    if (!GetClassAI()) return false;
-    if (!GetCurrentTarget()) return false;
-
-    if ((GetCombatOrder() & ORDERS_TANK) == 0) return false;
-
-    switch (m_bot->getClass())
-    {
-        case CLASS_PALADIN:
-            return ((PlayerbotPaladinAI*)GetClassAI())->Pull();
-
-        case CLASS_DRUID:
-            return ((PlayerbotDruidAI*)GetClassAI())->Pull();
-
-        case CLASS_WARRIOR:
-            return ((PlayerbotWarriorAI*)GetClassAI())->Pull();
-
-        default:
-            return false;
-    }
-
-    return false;
-}
-
-bool PlayerbotAI::GroupTankHoldsAggro()
-{
-    if (!m_bot) return false;
-
-    // update attacker info now
-    UpdateAttackerInfo();
-
-    if (m_bot->GetGroup())
-    {
-        Unit* newTarget = FindAttacker((ATTACKERINFOTYPE)(AIT_VICTIMNOTSELF), GetGroupTank());
-        if (newTarget)
-        {
-            return false;
-        }
-    }
-    else
-        return false; // no group -> no group tank to hold aggro
-
-    return true;
-}
-
-// Wrapper for the UpdateAI cast subfunction
-// Each bot class neutralize function will return a spellId
-// depending on the creatureType of the target
-bool PlayerbotAI::CastNeutralize()
-{
-    if (!m_bot) return false;
-    if (!GetClassAI()) return false;
-    if (!m_targetGuidCommand) return false;
-
-    Unit* pTarget = ObjectAccessor::GetUnit(*m_bot, m_targetGuidCommand);
-    if (!pTarget) return false;
-
-    Creature* pCreature = (Creature*) pTarget;
-    if (!pCreature) return false;
-
-    // Define the target's creature type, so the bot AI will now if
-    // it can neutralize it
-    uint8 creatureType = 0;
-    creatureType = pCreature->GetCreatureInfo()->CreatureType;
-
-    switch (m_bot->getClass())
-    {
-        case CLASS_DRUID:
-            m_spellIdCommand = ((PlayerbotDruidAI*)GetClassAI())->Neutralize(creatureType);
-            break;
-        case CLASS_PRIEST:
-            m_spellIdCommand = ((PlayerbotPriestAI*)GetClassAI())->Neutralize(creatureType);
-            break;
-        case CLASS_MAGE:
-            m_spellIdCommand = ((PlayerbotMageAI*)GetClassAI())->Neutralize(creatureType);
-            break;
-        case CLASS_WARLOCK:
-            m_spellIdCommand = ((PlayerbotWarlockAI*)GetClassAI())->Neutralize(creatureType);
-            break;
-        default:
-            return false;
-    }
-
-    // A spellId was found
-    if (m_spellIdCommand != 0)
-        return true;
-
-    return false;
-}
-
-void PlayerbotAI::SetQuestNeedCreatures()
-{
-    // reset values first
-    m_needCreatureOrGOList.clear();
-
-    // run through accepted quests, get quest info and data
-    for (int qs = 0; qs < MAX_QUEST_LOG_SIZE; ++qs)
-    {
-        uint32 questid = m_bot->GetQuestSlotQuestId(qs);
-        if (questid == 0)
-            continue;
-
-        QuestStatusData& qData = m_bot->getQuestStatusMap()[questid];
-        // only check quest if it is incomplete
-        if (qData.m_status != QUEST_STATUS_INCOMPLETE)
-            continue;
-
-        Quest const* qInfo = sObjectMgr.GetQuestTemplate(questid);
-        if (!qInfo)
-            continue;
-
-        // All creature/GO slain/casted (not required, but otherwise it will display "Creature slain 0/10")
-        for (int i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
-        {
-            if (!qInfo->ReqCreatureOrGOCount[i] || (qInfo->ReqCreatureOrGOCount[i] - qData.m_creatureOrGOcount[i]) <= 0)
-                continue;
-            m_needCreatureOrGOList[qInfo->ReqCreatureOrGOId[i]] = (qInfo->ReqCreatureOrGOCount[i] - qData.m_creatureOrGOcount[i]);
-        }
-    }
-}
-
-void PlayerbotAI::SetQuestNeedItems()
-{
-    // reset values first
-    m_needItemList.clear();
-    m_botQuestLoot.clear();
-
-    // run through accepted quests, get quest info and data
-    for (int qs = 0; qs < MAX_QUEST_LOG_SIZE; ++qs)
-    {
-        uint32 questid = m_bot->GetQuestSlotQuestId(qs);
-        if (questid == 0)
-            continue;
-
-        QuestStatusData& qData = m_bot->getQuestStatusMap()[questid];
-        // only check quest if it is incomplete
-        if (qData.m_status != QUEST_STATUS_INCOMPLETE)
-            continue;
-
-        Quest const* qInfo = sObjectMgr.GetQuestTemplate(questid);
-        if (!qInfo)
-            continue;
-
-        // check for items we not have enough of
-        for (int i = 0; i < QUEST_ITEM_OBJECTIVES_COUNT; i++)
-        {
-            if (!qInfo->ReqItemCount[i] || (qInfo->ReqItemCount[i] - qData.m_itemcount[i]) <= 0)
-                continue;
-
-            m_needItemList[qInfo->ReqItemId[i]] = (qInfo->ReqItemCount[i] - qData.m_itemcount[i]);
-
-            // collect flags not set to gather quest objects skip remaining section
-            if (!HasCollectFlag(COLLECT_FLAG_NEAROBJECT) && !HasCollectFlag(COLLECT_FLAG_QUEST))
-                continue;
-
-            // TODO: find faster way to handle this look up instead of using SQL lookup for each item
-            QueryResult* result;
-            result = WorldDatabase.PQuery("SELECT gt.entry FROM gameobject_template gt "
-                                          "LEFT JOIN gameobject_loot_template glt ON gt.data1 = glt.entry WHERE glt.item = '%u'", qInfo->ReqItemId[i]);
-
-            if (result)
-            {
-                do
-                {
-                    Field* fields = result->Fetch();
-                    uint32 entry = fields[0].GetUInt32();
-
-                    GameObjectInfo const* gInfo = ObjectMgr::GetGameObjectInfo(entry);
-                    if (!gInfo)
-                        continue;
-
-                    // add this GO to our collection list if is chest/ore/herb
-                    if (gInfo->type == GAMEOBJECT_TYPE_CHEST)
-                    {
-                        m_botQuestLoot.push_back(std::pair<uint32, uint32>(gInfo->GetLootId(), qInfo->ReqItemId[i]));
-                        m_botQuestLoot.unique();
-                        m_collectObjects.push_back(entry);
-                        m_collectObjects.sort();
-                        m_collectObjects.unique();
-                    }
-                }
-                while (result->NextRow());
-
-                delete result;
-            }
-        }
-    }
-}
-
-void PlayerbotAI::SetState(BotState state)
-{
-    // DEBUG_LOG ("[PlayerbotAI]: SetState - %s switch state %d to %d", m_bot->GetName(), m_botState, state );
-    m_botState = state;
-}
-
-uint32 PlayerbotAI::GetFreeBagSpace() const
-{
-    uint32 totalused = 0;
-    // list out items in main backpack
-    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
-    {
-        const Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
-        if (pItem)
-            totalused++;
-    }
-    uint32 totalfree = 16 - totalused;
-    // list out items in other removable backpacks
-    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
-    {
-        const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
-        if (pBag)
-        {
-            ItemPrototype const* pBagProto = pBag->GetProto();
-            if (pBagProto->Class == ITEM_CLASS_CONTAINER && pBagProto->SubClass == ITEM_SUBCLASS_CONTAINER)
-                totalfree =  totalfree + pBag->GetFreeSlots();
-        }
-    }
-    return totalfree;
-}
-
-void PlayerbotAI::DoFlight()
-{
-    // DEBUG_LOG("[PlayerbotAI]: DoFlight - %s : %s", m_bot->GetName(), m_taxiMaster.GetString().c_str());
-
-    Creature* npc = m_bot->GetNPCIfCanInteractWith(m_taxiMaster, UNIT_NPC_FLAG_FLIGHTMASTER);
-    if (!npc)
-    {
-        DEBUG_LOG("[PlayerbotAI]: DoFlight - %s not found or you can't interact with it.", m_taxiMaster.GetString().c_str());
-        return;
-    }
-
-    m_bot->ActivateTaxiPathTo(m_taxiNodes, npc);
-}
-
-void PlayerbotAI::DoLoot()
-{
-    // clear BOTSTATE_LOOTING if no more loot targets
-    if (m_lootCurrent.IsEmpty() && m_lootTargets.empty())
-    {
-        // DEBUG_LOG ("[PlayerbotAI]: DoLoot - %s is going back to idle", m_bot->GetName());
-        SetState(BOTSTATE_NORMAL);
-        m_bot->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_LOOTING);
-        m_inventory_full = false;
-        AutoUpgradeEquipment();
-        return;
-    }
-
-    // set first in list to current
-    if (m_lootCurrent.IsEmpty())
-    {
-        m_lootCurrent = m_lootTargets.front();
-        m_lootTargets.pop_front();
-    }
-
-    WorldObject* wo = m_bot->GetMap()->GetWorldObject(m_lootCurrent);
-
-    // clear invalid object or object that is too far from master
-    if (!wo || GetMaster()->GetDistance(wo) > float(m_mgr->m_confCollectDistanceMax))
-    {
-        m_lootCurrent = ObjectGuid();
-        return;
-    }
-
-    Creature* c = nullptr;
-    GameObject* go = nullptr;
-    if (m_lootCurrent.IsAnyTypeCreature())
-        c = static_cast<Creature*>(wo);
-    else if (m_lootCurrent.IsGameObject())
-        go = static_cast<GameObject*>(wo);
-
-    // clear creature or object that is not spawned or if not creature or object
-    if ((c && c->IsDespawned()) || (go && !go->IsSpawned()) || (!c && !go))
-    {
-        m_lootCurrent = ObjectGuid();
-        return;
-    }
-
-    uint32 skillId = 0;
-
-    if (c)
-    {
-        if (c->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE))
-            skillId = c->GetCreatureInfo()->GetRequiredLootSkill();
-
-        // not a lootable creature, clear it
-        if (!c->HasFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE) &&
-                (!c->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE) ||
-                 (c->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE) && !m_bot->HasSkill(skillId))))
-        {
-            m_lootCurrent = ObjectGuid();
-            // clear movement target, take next target on next update
-            m_bot->GetMotionMaster()->Clear(false);
-            m_bot->GetMotionMaster()->MoveIdle();
-            return;
-        }
-    }
-
-    if (m_bot->GetDistance(wo) > CONTACT_DISTANCE + wo->GetObjectBoundingRadius())
-    {
-        m_bot->GetMotionMaster()->MovePoint(wo->GetMapId(), wo->GetPositionX(), wo->GetPositionY(), wo->GetPositionZ());
-        // give time to move to point before trying again
-        SetIgnoreUpdateTime(1);
-    }
-
-    if (m_bot->GetDistance(wo) < INTERACTION_DISTANCE)
-    {
-        uint32 reqSkillValue = 0;
-        uint32 SkillValue = 0;
-        bool keyFailed = false;
-        bool skillFailed = false;
-        bool forceFailed = false;
-
-        if (c)  // creature
-        {
-            if (c->HasFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE) && !c->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE))
-            {
-                // loot the creature
-                std::unique_ptr<WorldPacket> packet(new WorldPacket(CMSG_LOOT, 8));
-                *packet << m_lootCurrent;
-                m_bot->GetSession()->QueuePacket(std::move(packet));
-                return; // no further processing is needed
-                // m_lootCurrent is reset in SMSG_LOOT_RESPONSE/SMSG_LOOT_RELEASE_RESPONSE
-            }
-            else if (c->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE))
-                // not all creature skins are leather, some are ore or herb
-                if (m_bot->HasSkill(skillId) && ((skillId != SKILL_SKINNING) ||
-                                                 (HasCollectFlag(COLLECT_FLAG_SKIN) && skillId == SKILL_SKINNING)))
-                {
-                    // calculate skinning skill requirement
-                    uint32 targetLevel = c->getLevel();
-                    reqSkillValue = targetLevel < 10 ? 0 : targetLevel < 20 ? (targetLevel - 10) * 10 : targetLevel * 5;
-                }
-
-            // creatures cannot be unlocked or forced open
-            keyFailed = true;
-            forceFailed = true;
-        }
-
-        if (go) // object
-        {
-
-            // add this GO to our collection list if active and is chest/ore/herb
-            if (go && HasCollectFlag(COLLECT_FLAG_NEAROBJECT) && go->GetGoType() == GAMEOBJECT_TYPE_CHEST)
-            {
-                m_collectObjects.push_back(go->GetEntry());
-                m_collectObjects.sort();
-                m_collectObjects.unique();
-            }
-
-            uint32 reqItem = 0;
-
-            // check skill or lock on object
-            uint32 lockId = go->GetGOInfo()->GetLockId();
-            LockEntry const* lockInfo = sLockStore.LookupEntry(lockId);
-            if (lockInfo)
-                for (int i = 0; i < 8; ++i)
-                {
-                    if (lockInfo->Type[i] == LOCK_KEY_ITEM)
-                    {
-                        if (lockInfo->Index[i] > 0)
-                        {
-                            reqItem = lockInfo->Index[i];
-                            if (m_bot->HasItemCount(reqItem, 1))
-                                break;
-                            continue;
-                        }
-                    }
-                    else if (lockInfo->Type[i] == LOCK_KEY_SKILL)
-                    {
-                        switch (LockType(lockInfo->Index[i]))
-                        {
-                            case LOCKTYPE_OPEN:
-                                if (CastSpell(3365))    // Opening
-                                    return;
-                                break;
-                            case LOCKTYPE_CLOSE:
-                                if (CastSpell(6233))    // Closing
-                                    return;
-                                break;
-                            case LOCKTYPE_QUICK_OPEN:
-                                if (CastSpell(6247))    // Opening
-                                    return;
-                                break;
-                            case LOCKTYPE_QUICK_CLOSE:
-                                if (CastSpell(6247))    // Closing
-                                    return;
-                                break;
-                            case LOCKTYPE_OPEN_TINKERING:
-                                if (CastSpell(6477))    // Opening
-                                    return;
-                                break;
-                            case LOCKTYPE_OPEN_KNEELING:
-                                if (CastSpell(22810))    // Opening; listed with 17667 and 22810
-                                    return;
-                                break;
-                            case LOCKTYPE_OPEN_ATTACKING:
-                                if (CastSpell(8386))    // Attacking
-                                    return;
-                                break;
-                            case LOCKTYPE_SLOW_OPEN:
-                                if (CastSpell(21651))   // Opening; also had 26868
-                                    return;
-                                break;
-                            case LOCKTYPE_SLOW_CLOSE:
-                                if (CastSpell(21652))   // Closing
-                                    return;
-                                break;
-                            default:
-                                if (SkillByLockType(LockType(lockInfo->Index[i])) > 0)
-                                {
-                                    skillId = SkillByLockType(LockType(lockInfo->Index[i]));
-                                    reqSkillValue = lockInfo->Skill[i];
-                                }
-                        }
-                    }
-                }
-
-            // use key on object if available
-            if (reqItem > 0 && m_bot->HasItemCount(reqItem, 1))
-            {
-                UseItem(FindItem(reqItem), TARGET_FLAG_OBJECT, m_lootCurrent);
-                m_lootCurrent = ObjectGuid();
-                return;
-            }
-            else
-                keyFailed = true;
-        }
-
-        // determine bot's skill value for object's required skill
-        if (skillId != SKILL_NONE)
-            SkillValue = uint32(m_bot->GetSkillValue(skillId));
-
-        // bot has the specific skill or object requires no skill at all
-        if ((m_bot->HasSkill(skillId) && skillId != SKILL_NONE) || (skillId == SKILL_NONE && go))
-        {
-            if (SkillValue < reqSkillValue)
-            {
-                TellMaster("My skill is not high enough. It requires %u, but mine is %u.",
-                           reqSkillValue, SkillValue);
-                skillFailed = true;
-            }
-            switch (skillId)
-            {
-                case SKILL_MINING:
-                    if (HasTool(TC_MINING_PICK) && CastSpell(MINING))
-                        return;
-                    else
-                        skillFailed = true;
-                    break;
-                case SKILL_HERBALISM:
-                    if (CastSpell(HERB_GATHERING))
-                        return;
-                    else
-                        skillFailed = true;
-                    break;
-                case SKILL_SKINNING:
-                    if (c && HasCollectFlag(COLLECT_FLAG_SKIN) &&
-                            HasTool(TC_SKINNING_KNIFE) && CastSpell(SKINNING, *c))
-                        return;
-                    else
-                        skillFailed = true;
-                    break;
-                case SKILL_LOCKPICKING:
-                    if (CastSpell(PICK_LOCK_1))
-                        return;
-                    else
-                        skillFailed = true;
-                    break;
-                case SKILL_NONE:
-                    if (CastSpell(3365)) //Spell 3365 = Opening?
-                        return;
-                    else
-                        skillFailed = true;
-                    break;
-                default:
-                    TellMaster("I'm not sure how to get that.");
-                    skillFailed = true;
-                    DEBUG_LOG("[PlayerbotAI]:DoLoot Skill %u is not implemented", skillId);
-                    break;
-            }
-        }
-        else
-        {
-            TellMaster("I do not have the required skill.");
-            skillFailed = true;
-        }
-
-        if (go) // only go's can be forced
-        {
-            // if pickable, check if a forcible item is available for the bot
-            if (skillId == SKILL_LOCKPICKING && (m_bot->HasSkill(SKILL_BLACKSMITHING) ||
-                                                 m_bot->HasSkill(SKILL_ENGINEERING)))
-            {
-                // check for skeleton keys appropriate for lock value
-                if (m_bot->HasSkill(SKILL_BLACKSMITHING))
-                {
-                    Item* kItem = FindKeyForLockValue(reqSkillValue);
-                    if (kItem)
-                    {
-                        TellMaster("I have a skeleton key that can open it!");
-                        UseItem(kItem, TARGET_FLAG_OBJECT, m_lootCurrent);
-                        return;
-                    }
-                    else
-                    {
-                        TellMaster("I have no skeleton keys that can open that lock.");
-                        forceFailed = true;
-                    }
-                }
-
-                // check for a charge that can blast it open
-                if (m_bot->HasSkill(SKILL_ENGINEERING))
-                {
-                    Item* bItem = FindBombForLockValue(reqSkillValue);
-                    if (bItem)
-                    {
-                        TellMaster("I can blast it open!");
-                        UseItem(bItem, TARGET_FLAG_OBJECT, m_lootCurrent);
-                        return;
-                    }
-                    else
-                    {
-                        TellMaster("I have nothing to blast it open with.");
-                        forceFailed = true;
-                    }
-                }
-            }
-            else
-                forceFailed = true;
-        }
-
-        // DEBUG_LOG ("[PlayerbotAI]%s: keyFailed [%s]", m_bot->GetName(), keyFailed ? "true" : "false");
-        // DEBUG_LOG ("[PlayerbotAI]%s: skillFailed [%s]", m_bot->GetName(), skillFailed ? "true" : "false");
-        // DEBUG_LOG ("[PlayerbotAI]%s: forceFailed [%s]", m_bot->GetName(), forceFailed ? "true" : "false");
-
-        // if all attempts failed in some way then clear because it won't get SMSG_LOOT_RESPONSE
-        if (keyFailed && skillFailed && forceFailed)
-        {
-            DEBUG_LOG("[PlayerbotAI]: DoLoot attempts failed on [%s]",
-                      go ? go->GetGOInfo()->name : c->GetCreatureInfo()->Name);
-            m_lootCurrent = ObjectGuid();
-
-            // remove this GO from our list using the same settings that it was added with earlier
-            if (go && HasCollectFlag(COLLECT_FLAG_NEAROBJECT) && go->GetGoType() == GAMEOBJECT_TYPE_CHEST)
-                m_collectObjects.remove(go->GetEntry());
-        }
-        // clear movement target, take next target on next update
-        m_bot->GetMotionMaster()->Clear(false);
-        m_bot->GetMotionMaster()->MoveIdle();
-    }
-}
-
-void PlayerbotAI::AcceptQuest(Quest const* qInfo, Player* pGiver)
-{
-    if (!qInfo || !pGiver)
-        return;
-
-    uint32 quest = qInfo->GetQuestId();
-
-    if (!pGiver->CanShareQuest(qInfo->GetQuestId()))
-    {
-        // giver can't share quest
-        m_bot->ClearDividerGuid();
-        return;
-    }
-
-    if (!m_bot->CanTakeQuest(qInfo, false))
-    {
-        // can't take quest
-        m_bot->ClearDividerGuid();
-        return;
-    }
-
-    if (m_bot->GetDividerGuid())
-    {
-        // send msg to quest giving player
-        pGiver->SendPushToPartyResponse(m_bot, QUEST_PARTY_MSG_ACCEPT_QUEST);
-        m_bot->ClearDividerGuid();
-    }
-
-    if (m_bot->CanAddQuest(qInfo, false))
-    {
-        m_bot->AddQuest(qInfo, pGiver);
-
-        if (m_bot->CanCompleteQuest(quest))
-            m_bot->CompleteQuest(quest);
-
-        // build needed items if quest contains any
-        for (int i = 0; i < QUEST_ITEM_OBJECTIVES_COUNT; i++)
-            if (qInfo->ReqItemCount[i] > 0)
-            {
-                SetQuestNeedItems();
-                break;
-            }
-
-        // build needed creatures if quest contains any
-        for (int i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
-            if (qInfo->ReqCreatureOrGOCount[i] > 0)
-            {
-                SetQuestNeedCreatures();
-                break;
-            }
-
-        // Runsttren: did not add typeid switch from WorldSession::HandleQuestgiverAcceptQuestOpcode!
-        // I think it's not needed, cause typeid should be TYPEID_PLAYER - and this one is not handled
-        // there and there is no default case also.
-
-        if (qInfo->GetSrcSpell() > 0)
-            m_bot->CastSpell(m_bot, qInfo->GetSrcSpell(), TRIGGERED_OLD_TRIGGERED);
-    }
-}
-
-void PlayerbotAI::TurnInQuests(WorldObject* questgiver)
-{
-    ObjectGuid giverGUID = questgiver->GetObjectGuid();
-
-    if (!m_bot->IsInMap(questgiver))
-        TellMaster("hey you are turning in quests without me!");
-    else
-    {
-        m_bot->SetSelectionGuid(giverGUID);
-
-        // auto complete every completed quest this NPC has
-        m_bot->PrepareQuestMenu(giverGUID);
-        QuestMenu& questMenu = m_bot->PlayerTalkClass->GetQuestMenu();
-        for (uint32 iI = 0; iI < questMenu.MenuItemCount(); ++iI)
-        {
-            QuestMenuItem const& qItem = questMenu.GetItem(iI);
-            uint32 questID = qItem.m_qId;
-            Quest const* pQuest = sObjectMgr.GetQuestTemplate(questID);
-
-            std::ostringstream out;
-            std::string questTitle  = pQuest->GetTitle();
-            QuestLocalization(questTitle, questID);
-
-            QuestStatus status = m_bot->GetQuestStatus(questID);
-
-            // if quest is complete, turn it in
-            if (status == QUEST_STATUS_COMPLETE)
-            {
-                // if bot hasn't already turned quest in
-                if (!m_bot->GetQuestRewardStatus(questID))
-                {
-                    // auto reward quest if no choice in reward
-                    if (pQuest->GetRewChoiceItemsCount() == 0)
-                    {
-                        if (m_bot->CanRewardQuest(pQuest, false))
-                        {
-                            m_bot->RewardQuest(pQuest, 0, questgiver, false);
-                            out << "Quest complete: |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
-                        }
-                        else
-                            out << "|cffff0000Unable to turn quest in:|r |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
-                    }
-
-                    // auto reward quest if one item as reward
-                    else if (pQuest->GetRewChoiceItemsCount() == 1)
-                    {
-                        int rewardIdx = 0;
-                        ItemPrototype const* pRewardItem = sObjectMgr.GetItemPrototype(pQuest->RewChoiceItemId[rewardIdx]);
-                        std::string itemName = pRewardItem->Name1;
-                        ItemLocalization(itemName, pRewardItem->ItemId);
-                        if (m_bot->CanRewardQuest(pQuest, rewardIdx, false))
-                        {
-                            m_bot->RewardQuest(pQuest, rewardIdx, questgiver, true);
-
-                            std::string itemName = pRewardItem->Name1;
-                            ItemLocalization(itemName, pRewardItem->ItemId);
-
-                            out << "Quest complete: "
-                                << " |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel()
-                                << "|h[" << questTitle << "]|h|r reward: |cffffffff|Hitem:"
-                                << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r";
-                        }
-                        else
-                            out << "|cffff0000Unable to turn quest in:|r "
-                                << "|cff808080|Hquest:" << questID << ':'
-                                << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r"
-                                << " reward: |cffffffff|Hitem:"
-                                << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r";
-                    }
-
-                    // else multiple rewards - let master pick
-                    else
-                    {
-                        out << "What reward should I take for |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel()
-                            << "|h[" << questTitle << "]|h|r? ";
-                        for (uint8 i = 0; i < pQuest->GetRewChoiceItemsCount(); ++i)
-                        {
-                            ItemPrototype const* const pRewardItem = sObjectMgr.GetItemPrototype(pQuest->RewChoiceItemId[i]);
-                            std::string itemName = pRewardItem->Name1;
-                            ItemLocalization(itemName, pRewardItem->ItemId);
-                            out << "|cffffffff|Hitem:" << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r";
-                        }
-                    }
-                }
-            }
-
-            else if (status == QUEST_STATUS_INCOMPLETE)
-                out << "|cffff0000Quest incomplete:|r "
-                    << " |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
-
-            else if (status == QUEST_STATUS_AVAILABLE)
-                out << "|cff00ff00Quest available:|r "
-                    << " |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
-
-            if (!out.str().empty())
-                TellMaster(out.str());
-        }
-        AutoUpgradeEquipment();
-    }
-}
-
-bool PlayerbotAI::IsInCombat()
-{
-    Pet* pet;
-    bool inCombat = false;
-    inCombat |= m_bot->isInCombat();
-    pet = m_bot->GetPet();
-    if (pet)
-        inCombat |= pet->isInCombat();
-    inCombat |= GetMaster()->isInCombat();
-    if (m_bot->GetGroup())
-    {
-        GroupReference* ref = m_bot->GetGroup()->GetFirstMember();
-        while (ref)
-        {
-            inCombat |= ref->getSource()->isInCombat();
-            pet = ref->getSource()->GetPet();
-            if (pet)
-                inCombat |= pet->isInCombat();
-            ref = ref->next();
-        }
-    }
-    return inCombat;
-}
-
-bool PlayerbotAI::IsRegenerating()
-{
-    Unit::SpellAuraHolderMap& auras = m_bot->GetSpellAuraHolderMap();
-    for (Unit::SpellAuraHolderMap::iterator aura = auras.begin(); aura != auras.end(); aura++)
-    {
-        SpellEntry const* spell = aura->second->GetSpellProto();
-        if (!spell)
-            continue;
-        if (spell->Category == 59 || spell->Category == 11)
-        {
-            return true;
-        }
-    }
-    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
-        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
-    return false;
-}
-
-void PlayerbotAI::UpdateAttackersForTarget(Unit* victim)
-{
-    HostileReference* ref = victim->getHostileRefManager().getFirst();
-    while (ref)
-    {
-        ThreatManager* target = ref->getSource();
-        ObjectGuid guid = target->getOwner()->GetObjectGuid();
-        m_attackerInfo[guid].attacker = target->getOwner();
-        m_attackerInfo[guid].victim = target->getOwner()->getVictim();
-        m_attackerInfo[guid].threat = target->getThreat(victim);
-        m_attackerInfo[guid].count = 1;
-        //m_attackerInfo[guid].source = 1; // source is not used so far.
-        ref = ref->next();
-    }
-}
-
-void PlayerbotAI::UpdateAttackerInfo()
-{
-    // clear old list
-    m_attackerInfo.clear();
-
-    // check own attackers
-    UpdateAttackersForTarget(m_bot);
-    Pet* pet = m_bot->GetPet();
-    if (pet)
-        UpdateAttackersForTarget(pet);
-
-    // check master's attackers
-    UpdateAttackersForTarget(GetMaster());
-    pet = GetMaster()->GetPet();
-    if (pet)
-        UpdateAttackersForTarget(pet);
-
-    // check all group members now
-    if (m_bot->GetGroup())
-    {
-        GroupReference* gref = m_bot->GetGroup()->GetFirstMember();
-        while (gref)
-        {
-            if (gref->getSource() == m_bot || gref->getSource() == GetMaster())
-            {
-                gref = gref->next();
-                continue;
-            }
-
-            UpdateAttackersForTarget(gref->getSource());
-            pet = gref->getSource()->GetPet();
-            if (pet)
-                UpdateAttackersForTarget(pet);
-
-            gref = gref->next();
-        }
-    }
-
-    // get highest threat not caused by bot for every entry in AttackerInfoList...
-    for (AttackerInfoList::iterator itr = m_attackerInfo.begin(); itr != m_attackerInfo.end(); ++itr)
-    {
-        if (!itr->second.attacker)
-            continue;
-        Unit* a = itr->second.attacker;
-        float t = 0.00;
-        std::list<HostileReference*>::const_iterator i = a->getThreatManager().getThreatList().begin();
-        for (; i != a->getThreatManager().getThreatList().end(); ++i)
-        {
-            if ((*i)->getThreat() > t && (*i)->getTarget() != m_bot)
-                t = (*i)->getThreat();
-        }
-        m_attackerInfo[itr->first].threat2 = t;
-    }
-
-    // DEBUG: output attacker info
-    //sLog.outBasic( "[PlayerbotAI]: %s m_attackerInfo = {", m_bot->GetName() );
-    //for( AttackerInfoList::iterator i=m_attackerInfo.begin(); i!=m_attackerInfo.end(); ++i )
-    //    sLog.outBasic( "[PlayerbotAI]:     [%016I64X] { %08X, %08X, %.2f, %.2f, %d, %d }",
-    //        i->first,
-    //        (i->second.attacker?i->second.attacker->GetGUIDLow():0),
-    //        (i->second.victim?i->second.victim->GetGUIDLow():0),
-    //        i->second.threat,
-    //        i->second.threat2,
-    //        i->second.count,
-    //        i->second.source );
-    //sLog.outBasic( "[PlayerbotAI]: };" );
-}
-
-uint32 PlayerbotAI::EstRepairAll()
-{
-    uint32 TotalCost = 0;
-    // equipped, backpack, bags itself
-    for (int i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
-        TotalCost += EstRepair(((INVENTORY_SLOT_BAG_0 << 8) | i));
-
-    // bank, buyback and keys not repaired
-
-    // items in inventory bags
-    for (int j = INVENTORY_SLOT_BAG_START; j < INVENTORY_SLOT_BAG_END; ++j)
-        for (int i = 0; i < MAX_BAG_SIZE; ++i)
-            TotalCost += EstRepair(((j << 8) | i));
-    return TotalCost;
-}
-
-uint32 PlayerbotAI::EstRepair(uint16 pos)
-{
-    Item* item = m_bot->GetItemByPos(pos);
-
-    uint32 TotalCost = 0;
-    if (!item)
-        return TotalCost;
-
-    uint32 maxDurability = item->GetUInt32Value(ITEM_FIELD_MAXDURABILITY);
-    if (!maxDurability)
-        return TotalCost;
-
-    uint32 curDurability = item->GetUInt32Value(ITEM_FIELD_DURABILITY);
-
-    uint32 LostDurability = maxDurability - curDurability;
-    if (LostDurability > 0)
-    {
-        ItemPrototype const* ditemProto = item->GetProto();
-
-        DurabilityCostsEntry const* dcost = sDurabilityCostsStore.LookupEntry(ditemProto->ItemLevel);
-        if (!dcost)
-        {
-            sLog.outError("RepairDurability: Wrong item lvl %u", ditemProto->ItemLevel);
-            return TotalCost;
-        }
-
-        uint32 dQualitymodEntryId = (ditemProto->Quality + 1) * 2;
-        DurabilityQualityEntry const* dQualitymodEntry = sDurabilityQualityStore.LookupEntry(dQualitymodEntryId);
-        if (!dQualitymodEntry)
-        {
-            sLog.outError("RepairDurability: Wrong dQualityModEntry %u", dQualitymodEntryId);
-            return TotalCost;
-        }
-
-        uint32 dmultiplier = dcost->multiplier[ItemSubClassToDurabilityMultiplierId(ditemProto->Class, ditemProto->SubClass)];
-        uint32 costs = uint32(LostDurability * dmultiplier * double(dQualitymodEntry->quality_mod));
-
-        if (costs == 0)                                 //fix for ITEM_QUALITY_ARTIFACT
-            costs = 1;
-
-        TotalCost = costs;
-    }
-    return TotalCost;
-}
-
-Unit* PlayerbotAI::FindAttacker(ATTACKERINFOTYPE ait, Unit* victim)
-{
-    // list empty? why are we here?
-    if (m_attackerInfo.empty())
-        return nullptr;
-
-    // not searching something specific - return first in list
-    if (!ait)
-        return (m_attackerInfo.begin())->second.attacker;
-
-    float t = ((ait & AIT_HIGHESTTHREAT) ? 0.00 : 9999.00);
-    Unit* a = nullptr;
-    AttackerInfoList::iterator itr = m_attackerInfo.begin();
-    for (; itr != m_attackerInfo.end(); ++itr)
-    {
-        if ((ait & AIT_VICTIMSELF) && !(ait & AIT_VICTIMNOTSELF) && itr->second.victim != m_bot)
-            continue;
-
-        if (!(ait & AIT_VICTIMSELF) && (ait & AIT_VICTIMNOTSELF) && itr->second.victim == m_bot)
-            continue;
-
-        if ((ait & AIT_VICTIMNOTSELF) && victim && itr->second.victim != victim)
-            continue;
-
-        if (!(ait & (AIT_LOWESTTHREAT | AIT_HIGHESTTHREAT)))
-            return itr->second.attacker;
-        else
-        {
-            if ((ait & AIT_HIGHESTTHREAT) && /*(itr->second.victim==m_bot) &&*/ itr->second.threat >= t)
-            {
-                t = itr->second.threat;
-                a = itr->second.attacker;
-            }
-            else if ((ait & AIT_LOWESTTHREAT) && /*(itr->second.victim==m_bot) &&*/ itr->second.threat <= t)
-            {
-                t = itr->second.threat;
-                a = itr->second.attacker;
-            }
-        }
-    }
-    return a;
-}
-
-/**
-* BotDataRestore()
-* Restores autoequip - the toggle status for the 'equip auto' command.
-* Restores gDelayAttack - the other attributes need a valid target. This function is to be called when the targets
-* may or may not be online (such as upon login). See CombatOrderRestore() for full orders restore.
-* Restores m_DelayAttack - the other attributes need a valid target. This function is to be called when the targets
-*/
-void PlayerbotAI::BotDataRestore()
-{
-    QueryResult* result = CharacterDatabase.PQuery("SELECT combat_delay,autoequip FROM playerbot_saved_data WHERE guid = '%u'", m_bot->GetGUIDLow());
-
-    if (!result)
-    {
-        sLog.outString();
-        sLog.outString(">> [BotDataRestore()] Loaded `playerbot_saved_data`, found no match for guid %u.", m_bot->GetGUIDLow());
-        m_DelayAttack = 0;
-        return;
-    }
-    else
-    {
-        Field* fields = result->Fetch();
-        m_DelayAttack = fields[0].GetUInt8();
-        m_AutoEquipToggle = fields[1].GetBool();
-        delete result;
-    }
-}
-
-/**
-* CombatOrderRestore()
-* Restores all saved attributes. This function is to be called when the targets are assumed to be online.
-*/
-
-void PlayerbotAI::CombatOrderRestore()
-{
-    QueryResult* result = CharacterDatabase.PQuery("SELECT combat_order,primary_target,secondary_target,pname,sname,combat_delay,auto_follow FROM playerbot_saved_data WHERE guid = '%u'", m_bot->GetGUIDLow());
-
-    if (!result)
-    {
-        sLog.outString();
-        sLog.outString(">> [CombatOrderRestore()] Loaded `playerbot_saved_data`, found no match for guid %u.", m_bot->GetGUIDLow());
-        TellMaster("I have no orders");
-        return;
-    }
-
-    Field* fields = result->Fetch();
-    CombatOrderType combatOrders = (CombatOrderType)fields[0].GetUInt32();
-    ObjectGuid PrimtargetGUID = ObjectGuid(fields[1].GetUInt64());
-    ObjectGuid SectargetGUID = ObjectGuid(fields[2].GetUInt64());
-    std::string pname = fields[3].GetString();
-    std::string sname = fields[4].GetString();
-    m_DelayAttack = fields[5].GetUInt8();
-    gPrimtarget = ObjectAccessor::GetUnit(*m_bot->GetMap()->GetWorldObject(PrimtargetGUID), PrimtargetGUID);
-    gSectarget = ObjectAccessor::GetUnit(*m_bot->GetMap()->GetWorldObject(SectargetGUID), SectargetGUID);
-    delete result;
-
-    //Unit* target = nullptr;
-    //ObjectGuid NoTargetGUID = m_bot->GetObjectGuid();
-    //target = ObjectAccessor::GetUnit(*m_bot, NoTargetGUID);
-
-    if (combatOrders & ORDERS_PRIMARY) SetCombatOrder(combatOrders, gPrimtarget);
-    if (combatOrders & ORDERS_SECONDARY) SetCombatOrder(combatOrders, gSectarget);
-}
-
-void PlayerbotAI::SetCombatOrderByStr(std::string str, Unit* target)
-{
-    CombatOrderType co;
-    if (str == "tank")              co = ORDERS_TANK;
-    else if (str == "assist")       co = ORDERS_ASSIST;
-    else if (str == "heal")         co = ORDERS_HEAL;
-    else if (str == "protect")      co = ORDERS_PROTECT;
-    else if (str == "passive")      co = ORDERS_PASSIVE;
-    else if (str == "pull")         co = ORDERS_TEMP_WAIT_TANKAGGRO;
-    else if (str == "nodispel")     co = ORDERS_NODISPEL;
-    else if (str == "resistfrost")  co = ORDERS_RESIST_FROST;
-    else if (str == "resistnature") co = ORDERS_RESIST_NATURE;
-    else if (str == "resistfire")   co = ORDERS_RESIST_FIRE;
-    else if (str == "resistshadow") co = ORDERS_RESIST_SHADOW;
-    else                            co = ORDERS_RESET;
-
-    SetCombatOrder(co, target);
-    if (m_FollowAutoGo != FOLLOWAUTOGO_OFF)
-        m_FollowAutoGo = FOLLOWAUTOGO_INIT;
-}
-
-void PlayerbotAI::SetCombatOrder(CombatOrderType co, Unit* target)
-{
-    uint32 gTempTarget;
-    std::string gname;
-    if (target)
-    {
-        gTempTarget = target->GetGUIDLow();
-        gname = target->GetName();
-    }
-
-    // reset m_combatOrder after ORDERS_PASSIVE
-    if (m_combatOrder == ORDERS_PASSIVE)
-    {
-        m_combatOrder = ORDERS_NONE;
-        m_targetAssist = 0;
-        m_targetProtect = 0;
-    }
-
-    switch (co)
-    {
-        case ORDERS_ASSIST: // 2(10)
-        {
-            if (!target)
-            {
-                TellMaster("The assist command requires a target.");
-                return;
-            }
-            else m_targetAssist = target;
-            break;
-        }
-        case ORDERS_PROTECT: // 10(10000)
-        {
-            if (!target)
-            {
-                TellMaster("The protect command requires a target.");
-                return;
-            }
-            else m_targetProtect = target;
-            break;
-        }
-        case ORDERS_PASSIVE: // 20(100000)
-        {
-            m_combatOrder = ORDERS_PASSIVE;
-            m_targetAssist = 0;
-            m_targetProtect = 0;
-            return;
-        }
-        case ORDERS_RESET: // FFFF(11111111)
-        {
-            m_combatOrder = ORDERS_NONE;
-            m_targetAssist = 0;
-            m_targetProtect = 0;
-            m_DelayAttackInit = CurrentTime();
-            m_DelayAttack = 0;
-            CharacterDatabase.DirectPExecute("UPDATE playerbot_saved_data SET combat_order = 0, primary_target = 0, secondary_target = 0, pname = '',sname = '', combat_delay = 0 WHERE guid = '%u'", m_bot->GetGUIDLow());
-            TellMaster("Orders are cleaned!");
-            return;
-        }
-        default:
-            break;
-    }
-
-    // Do your magic
-    if ((co & ORDERS_PRIMARY))
-    {
-        m_combatOrder = (CombatOrderType)(((uint32) m_combatOrder & (uint32) ORDERS_SECONDARY) | (uint32) co);
-        if (target)
-            CharacterDatabase.DirectPExecute("UPDATE playerbot_saved_data SET combat_order = '%u', primary_target = '%u', pname = '%s' WHERE guid = '%u'", (m_combatOrder & ~ORDERS_TEMP), gTempTarget, gname.c_str(), m_bot->GetGUIDLow());
-        else
-            CharacterDatabase.DirectPExecute("UPDATE playerbot_saved_data SET combat_order = '%u' WHERE guid = '%u'", (m_combatOrder & ~ORDERS_TEMP), m_bot->GetGUIDLow());
-    }
-    else
-    {
-        m_combatOrder = (CombatOrderType)((uint32)m_combatOrder | (uint32)co);
-        if (target)
-            CharacterDatabase.DirectPExecute("UPDATE playerbot_saved_data SET combat_order = '%u', secondary_target = '%u', sname = '%s' WHERE guid = '%u'", (m_combatOrder & ~ORDERS_TEMP), gTempTarget, gname.c_str(), m_bot->GetGUIDLow());
-        else
-            CharacterDatabase.DirectPExecute("UPDATE playerbot_saved_data SET combat_order = '%u' WHERE guid = '%u'", (m_combatOrder & ~ORDERS_TEMP), m_bot->GetGUIDLow());
-    }
-}
-
-void PlayerbotAI::ClearCombatOrder(CombatOrderType co)
-{
-    m_combatOrder = (CombatOrderType)((uint32) m_combatOrder & (uint32) ~co);
-
-    switch (co)
-    {
-        case ORDERS_NONE:
-        case ORDERS_TANK:
-        case ORDERS_ASSIST:
-        case ORDERS_HEAL:
-        case ORDERS_PASSIVE:
-        case ORDERS_PRIMARY:
-        case ORDERS_RESET:
-        case ORDERS_SECONDARY:
-            SetCombatOrder(ORDERS_RESET);
-            return;
-
-        default:
-            return;
-    }
-}
-
-void PlayerbotAI::SetMovementOrder(MovementOrderType mo, Unit* followTarget)
-{
-    m_movementOrder = mo;
-    m_followTarget = followTarget;
-    MovementReset();
-}
-
-void PlayerbotAI::MovementReset()
-{
-    // stop moving...
-    MovementClear();
-    if (m_movementOrder == MOVEMENT_FOLLOW)
-    {
-        if (!m_followTarget)
-            return;
-
-        WorldObject* distTarget = m_followTarget;   // target to distance check
-
-        // don't follow while in combat
-        if (m_bot->isInCombat())
-            return;
-
-        Player* pTarget;                            // target is player
-        if (m_followTarget->GetTypeId() == TYPEID_PLAYER)
-            pTarget = ((Player*) m_followTarget);
-
-        if (pTarget)
-        {
-            // check player for follow situations
-            if (pTarget->IsBeingTeleported() || pTarget->IsTaxiFlying())
-                return;
-
-            // use player's corpse as distance check target
-            if (pTarget->GetCorpse())
-                distTarget = pTarget->GetCorpse();
-        }
-
-        // is bot too far from the follow target
-        if (!m_bot->IsWithinDistInMap(distTarget, 50))
-        {
-            DoTeleport(*m_followTarget);
-            return;
-        }
-
-        if (m_bot->isAlive() && !m_bot->IsBeingTeleported())
-        {
-            if (DistOverRide != 0)
-            {
-                if (m_FollowAutoGo == FOLLOWAUTOGO_OFF)
-                {
-                    if (IsUpOrDown < DistOverRide)
-                    {
-                        IsUpOrDown = DistOverRide;
-                        gTempDist = (gTempDist + 1.0);
-                        gTempDist2 = (gTempDist2 + 1.0);
-                    }
-                    if (IsUpOrDown > DistOverRide)
-                    {
-                        if (IsUpOrDown >= 2)
-                        {
-                            IsUpOrDown = DistOverRide;
-                            gTempDist = (gTempDist - 1.0);
-                            gTempDist2 = (gTempDist2 - 1.0);
-                        }
-                    }
-                }
-                else
-                {
-                    if (IsUpOrDown < DistOverRide)
-                    {
-                        gTempDist = 1.0;
-                        gTempDist2 = 2.0;
-                        IsUpOrDown = 0;
-                        for (IsUpOrDown = 0; IsUpOrDown < DistOverRide; ++IsUpOrDown)
-                        {
-                            gTempDist = (gTempDist + 1.0);
-                            gTempDist2 = (gTempDist2 + 1.0);
-                        }
-                        IsUpOrDown = DistOverRide;
-                    }
-                    else if (IsUpOrDown > DistOverRide)
-                    {
-                        uint8 getdowndist = (IsUpOrDown - DistOverRide);
-                        for (uint8 getdowndistb = 0; getdowndistb < getdowndist; ++getdowndistb)
-                        {
-                            gTempDist = (gTempDist - 1.0);
-                            gTempDist2 = (gTempDist2 - 1.0);
-                        }
-                        IsUpOrDown = DistOverRide;
-                    }
-                }
-                if (m_FollowAutoGo != FOLLOWAUTOGO_RESET)
-                {
-                    gDist[0] = gTempDist;
-                    gDist[1] = gTempDist2;
-                }
-                else
-                {
-                    gDist[0] = 0.5f;
-                    gDist[1] = 1.0f;
-                    SetIgnoreUpdateTime(3);
-                    m_FollowAutoGo = FOLLOWAUTOGO_INIT;
-                }
-            }
-            float dist = rand_float(m_mgr->m_confFollowDistance[0], m_mgr->m_confFollowDistance[1]);
-            float bdist = rand_float(gDist[0], gDist[1]);
-            float angle = rand_float(0, M_PI_F);
-            float bangle = rand_float(2.8f, 3.6f); // angle is based on radians
-            float TankAngle = 3.1f;
-            float AssistAngle = 2.8f;
-            if (DistOverRide != 0)
-            {
-                if (m_combatOrder & ORDERS_TANK)
-                    m_bot->GetMotionMaster()->MoveFollow(m_followTarget, bdist, TankAngle);
-                else if (m_combatOrder & ORDERS_ASSIST)
-                    m_bot->GetMotionMaster()->MoveFollow(m_followTarget, bdist, AssistAngle);
-                else
-                    m_bot->GetMotionMaster()->MoveFollow(m_followTarget, bdist, bangle);
-            }
-            else
-                m_bot->GetMotionMaster()->MoveFollow(m_followTarget, dist, angle);
-            if (m_FollowAutoGo == FOLLOWAUTOGO_RUN)
-                m_FollowAutoGo = FOLLOWAUTOGO_INIT;
-        }
-    }
-}
-
-void PlayerbotAI::MovementClear()
-{
-    // stop...
-    m_bot->GetMotionMaster()->Initialize();
-
-    // stand up...
-    if (!m_bot->IsStandState())
-        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
-}
-
-void PlayerbotAI::PlaySound(uint32 soundid)
-{
-    WorldPacket data(SMSG_PLAY_SOUND, 4);
-    data << soundid;
-    GetMaster()->GetSession()->SendPacket(data);
-}
-
-// PlaySound data from SoundEntries.dbc
-void PlayerbotAI::Announce(AnnounceFlags msg)
-{
-    switch (m_bot->getRace())
-    {
-        case RACE_HUMAN:
-            switch (msg)
-            {
-                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? PlaySound(1908) : PlaySound(2032); break;
-                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? PlaySound(1875) : PlaySound(1999); break;
-                case CANT_USE_TOO_FAR: m_bot->getGender() == GENDER_MALE ? PlaySound(1924) : PlaySound(2048); break;
-                default: break;
-            }
-            break;
-        case RACE_ORC:
-            switch (msg)
-            {
-                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? PlaySound(2319) : PlaySound(2374); break;
-                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? PlaySound(2284) : PlaySound(2341); break;
-                case CANT_USE_TOO_FAR: m_bot->getGender() == GENDER_MALE ? PlaySound(2335) : PlaySound(2390); break;
-                default: break;
-            }
-            break;
-        case RACE_DWARF:
-            switch (msg)
-            {
-                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? PlaySound(1630) : PlaySound(1686); break;
-                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? PlaySound(1581) : PlaySound(1654); break;
-                case CANT_USE_TOO_FAR: m_bot->getGender() == GENDER_MALE ? PlaySound(1636) : PlaySound(1702); break;
-                default: break;
-            }
-            break;
-        case RACE_NIGHTELF:
-            switch (msg)
-            {
-                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? PlaySound(2151) : PlaySound(2262); break;
-                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? PlaySound(2118) : PlaySound(2229); break;
-                case CANT_USE_TOO_FAR: m_bot->getGender() == GENDER_MALE ? PlaySound(2167) : PlaySound(2278); break;
-                default: break;
-            }
-            break;
-        case RACE_UNDEAD:
-            switch (msg)
-            {
-                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? PlaySound(2096) : PlaySound(2207); break;
-                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? PlaySound(2054) : PlaySound(2173); break;
-                case CANT_USE_TOO_FAR: m_bot->getGender() == GENDER_MALE ? PlaySound(2112) : PlaySound(2223); break;
-                default: break;
-            }
-            break;
-        case RACE_TAUREN:
-            switch (msg)
-            {
-                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? PlaySound(2463) : PlaySound(2462); break;
-                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? PlaySound(2396) : PlaySound(2397); break;
-                case CANT_USE_TOO_FAR: m_bot->getGender() == GENDER_MALE ? PlaySound(2495) : PlaySound(2494); break;
-                default: break;
-            }
-            break;
-        case RACE_GNOME:
-            switch (msg)
-            {
-                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? PlaySound(1743) : PlaySound(1798); break;
-                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? PlaySound(1708) : PlaySound(1709); break;
-                case CANT_USE_TOO_FAR: m_bot->getGender() == GENDER_MALE ? PlaySound(1759) : PlaySound(1814); break;
-                default: break;
-            }
-            break;
-        case RACE_TROLL:
-            switch (msg)
-            {
-                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? PlaySound(1853) : PlaySound(1963); break;
-                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? PlaySound(1820) : PlaySound(1930); break;
-                case CANT_USE_TOO_FAR: m_bot->getGender() == GENDER_MALE ? PlaySound(1869) : PlaySound(1993); break;
-                default: break;
-            }
-            break;
-        case RACE_BLOODELF:
-            switch (msg)
-            {
-                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? PlaySound(9583) : PlaySound(9584); break;
-                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? PlaySound(9549) : PlaySound(9550); break;
-                case CANT_USE_TOO_FAR: m_bot->getGender() == GENDER_MALE ? PlaySound(9565) : PlaySound(9566); break;
-                default: break;
-            }
-            break;
-        case RACE_DRAENEI:
-            switch (msg)
-            {
-                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? PlaySound(9498) : PlaySound(9499); break;
-                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? PlaySound(9465) : PlaySound(9466); break;
-                case CANT_USE_TOO_FAR: m_bot->getGender() == GENDER_MALE ? PlaySound(9481) : PlaySound(9482); break;
-                default: break;
-            }
-            break;
-        default:
-            break;
-    }
-}
-
-bool PlayerbotAI::IsMoving()
-{
-    return (m_bot->GetMotionMaster()->GetCurrentMovementGeneratorType() == IDLE_MOTION_TYPE ? false : true);
-}
-
-// some possible things to use in AI
-// GetRandomContactPoint
-// GetPower, GetMaxPower
-// HasSpellCooldown
-// IsAffectedBySpellmod
-// isMoving
-// hasUnitState(FLAG) FLAG like: UNIT_STAT_ROOT, UNIT_STAT_CONFUSED, UNIT_STAT_STUNNED
-// hasAuraType
-
-void PlayerbotAI::UpdateAI(const uint32 /*p_time*/)
-{
-    if (m_bot->IsBeingTeleported() || m_bot->GetTrader())
-        return;
-
-    if (CurrentTime() < m_ignoreAIUpdatesUntilTime)
-        return;
-
-    // default updates occur every two seconds
-    SetIgnoreUpdateTime(2);
-    if (m_FollowAutoGo == FOLLOWAUTOGO_INIT)
-    {
-        if (m_combatOrder & ORDERS_TANK)
-            DistOverRide = 1;
-        else if (m_combatOrder & ORDERS_ASSIST)
-            DistOverRide = 3;
-        else
-            DistOverRide = 4;
-        m_FollowAutoGo = FOLLOWAUTOGO_SET;
-        SetMovementOrder(MOVEMENT_FOLLOW, GetMaster());
-    }
-
-    if (!m_bot->isAlive())
-    {
-        if (m_botState == BOTSTATE_DEAD)
-        {
-            // become ghost
-            if (m_bot->GetCorpse())
-            {
-                // DEBUG_LOG ("[PlayerbotAI]: UpdateAI - %s already has a corpse...", m_bot->GetName());
-                SetState(BOTSTATE_DEADRELEASED);
-                return;
-            }
-            m_bot->SetBotDeathTimer();
-            m_bot->BuildPlayerRepop();
-            // relocate ghost
-            WorldLocation loc;
-            Corpse* corpse = m_bot->GetCorpse();
-            corpse->GetPosition(loc);
-            m_bot->TeleportTo(loc.mapid, loc.coord_x, loc.coord_y, loc.coord_z, m_bot->GetOrientation());
-            // set state to released
-            SetState(BOTSTATE_DEADRELEASED);
-
-            return;
-        }
-
-        if (m_botState == BOTSTATE_DEADRELEASED)
-        {
-            // get bot's corpse
-            Corpse* corpse = m_bot->GetCorpse();
-            if (!corpse)
-                // DEBUG_LOG ("[PlayerbotAI]: UpdateAI - %s has no corpse!", m_bot->GetName());
-                return;
-            // teleport ghost from graveyard to corpse
-            // DEBUG_LOG ("[PlayerbotAI]: UpdateAI - Teleport %s to corpse...", m_bot->GetName());
-            DoTeleport(*corpse);
-            // check if we are allowed to resurrect now
-            time_t resurrect_time = corpse->GetGhostTime() + m_bot->GetCorpseReclaimDelay(corpse->GetType() == CORPSE_RESURRECTABLE_PVP);
-            if (resurrect_time > CurrentTime())
-            {
-                SetIgnoreUpdateTime(resurrect_time);
-                // DEBUG_LOG ("[PlayerbotAI]: UpdateAI - %s has to wait for %d seconds to revive...", m_bot->GetName(), m_ignoreAIUpdatesUntilTime-CurrentTime() );
-                return;
-            }
-            // resurrect now
-            // DEBUG_LOG ("[PlayerbotAI]: UpdateAI - Reviving %s to corpse...", m_bot->GetName() );
-
-            SetIgnoreUpdateTime(6);
-
-            PlayerbotChatHandler ch(GetMaster());
-            if (!ch.revive(*m_bot))
-            {
-                ch.sysmessage(".. could not be revived ..");
-                return;
-            }
-            // set back to normal
-            SetState(BOTSTATE_NORMAL);
-
-            return;
-        }
-
-        // if (m_botState != BOTSTATE_DEAD && m_botState != BOTSTATE_DEADRELEASED)
-        // DEBUG_LOG ("[PlayerbotAI]: UpdateAI - %s died and is not in correct state...", m_bot->GetName() );
-        // clear loot list on death
-        m_lootTargets.clear();
-        m_lootCurrent = ObjectGuid();
-        // clear combat orders
-        m_bot->SetSelectionGuid(ObjectGuid());
-        m_bot->GetMotionMaster()->Clear(true);
-        // set state to dead
-        SetState(BOTSTATE_DEAD);
-        // wait 30sec
-        SetIgnoreUpdateTime(30);
-
-        return;
-    }
-
-    // bot still alive
-    if (!m_findNPC.empty())
-        findNearbyCreature();
-
-    // if we are casting a spell then interrupt it
-    // make sure any actions that cast a spell set a proper m_ignoreAIUpdatesUntilTime!
-    Spell* const pSpell = GetCurrentSpell();
-    if (pSpell && !(pSpell->IsChannelActive() || pSpell->IsAutoRepeat()))
-    {
-        // DEBUG_LOG("spell (%s) is being interrupted",pSpell->m_spellInfo->SpellName[0]);
-        InterruptCurrentCastingSpell();
-        return;
-    }
-
-    if (m_botState == BOTSTATE_TAME)
-    {
-        Unit* pTarget = ObjectAccessor::GetUnit(*m_bot, m_targetGuidCommand);
-        if (!pTarget)
-            return;
-
-        m_bot->SetSelectionGuid(m_targetGuidCommand);
-
-        if (!In_Range(pTarget, TAME_BEAST_1))
-            m_bot->clearUnitState(UNIT_STAT_CHASE);
-
-        if (!m_bot->hasUnitState(UNIT_STAT_CHASE))
-        {
-            m_bot->GetMotionMaster()->MoveChase(pTarget);
-            return;
-        }
-
-        SpellEntry const* spellInfo = sSpellTemplate.LookupEntry<SpellEntry>(TAME_BEAST_1);
-        if (!spellInfo)
-            return;
-
-        Spell* spell = new Spell(m_bot, spellInfo, false);
-        if (!spell)
-            return;
-
-        if (m_bot->GetPetGuid() || spell->CheckCast(true) != SPELL_CAST_OK || !pTarget ||
-                pTarget->isDead() || !m_bot->IsInMap(pTarget) || !(((Creature*) pTarget)->GetCreatureInfo()->CreatureTypeFlags & CREATURE_TYPEFLAGS_TAMEABLE))
-        {
-            MovementReset();
-            m_bot->SetSelectionGuid(ObjectGuid());
-            SetState(BOTSTATE_NORMAL);
-            SetIgnoreUpdateTime(0);
-        }
-        else if (!m_bot->HasAura(TAME_BEAST_1, EFFECT_INDEX_1))
-        {
-            m_bot->SetFacingTo(m_bot->GetAngle(pTarget));
-            SpellCastTargets targets;
-            targets.setUnitTarget(pTarget);
-            spell->SpellStart(&targets);
-            SetIgnoreUpdateTime(10);
-        }
-        return;
-    }
-
-    // direct cast command from master
-    if (m_spellIdCommand != 0)
-    {
-        Unit* pTarget = ObjectAccessor::GetUnit(*m_bot, m_targetGuidCommand);
-        if (pTarget)
-        {
-            // Face the target to avoid facing casting error
-            FaceTarget(pTarget);
-            CastSpell(m_spellIdCommand, *pTarget);
-        }
-        m_spellIdCommand = 0;
-        m_targetGuidCommand = ObjectGuid();
-
-        return;
-    }
-
-    if (m_botState == BOTSTATE_DELAYED)
-    {
-        if (m_CraftSpellId == 0)
-        {
-            SetState(BOTSTATE_NORMAL);
-            AutoUpgradeEquipment();
-            return;
-        }
-
-        SpellEntry const* spellInfo = sSpellTemplate.LookupEntry<SpellEntry>(m_CraftSpellId);
-        if (!spellInfo)
-            return;
-
-        Spell* spell = new Spell(m_bot, spellInfo, false);
-        if (!spell)
-            return;
-
-        if (GetSpellCharges(m_CraftSpellId) == 0 || spell->CheckCast(true) != SPELL_CAST_OK)
-        {
-            SetState(BOTSTATE_NORMAL);
-            SetIgnoreUpdateTime(0);
-            AutoUpgradeEquipment();
-            m_CraftSpellId = 0;
-        }
-        else
-        {
-            SpellCastTargets targets;
-            spell->SpellStart(&targets);
-            SetIgnoreUpdateTime(6);
-        }
-
-        return;
-    }
-
-    //if master is unmounted, unmount the bot
-    if (!GetMaster()->IsMounted() && m_bot->IsMounted())
-    {
-        WorldPacket emptyPacket;
-        m_bot->GetSession()->HandleCancelMountAuraOpcode(emptyPacket);  //updated code
-
-        return;
-    }
-
-    // handle combat (either self/master/group in combat, or combat state and valid target)
-    if (IsInCombat() || (m_botState == BOTSTATE_COMBAT && m_targetCombat) ||  m_ScenarioType == SCENARIO_PVP_DUEL)
-    {
-        //check if the bot is Mounted
-        if (!m_bot->IsMounted())
-        {
-            if (!pSpell || !pSpell->IsChannelActive())
-            {
-                // DEBUG_LOG("m_DelayAttackInit (%li) + m_DelayAttack (%u) > time(%li)", m_DelayAttackInit, m_DelayAttack, CurrentTime());
-                if (m_DelayAttackInit + m_DelayAttack > CurrentTime())
-                    return SetIgnoreUpdateTime(1); // short bursts of delay
-
-                return DoNextCombatManeuver();
-            }
-            else // channelling a spell
-                return SetIgnoreUpdateTime(0);  // It's better to update AI more frequently during combat
-        }
-
-        return;
-    }
-
-    // bot was in combat recently - loot now
-    if (m_botState == BOTSTATE_COMBAT)
-    {
-        if (GetCombatOrder() & ORDERS_TEMP)
-        {
-            if (GetCombatOrder() & ORDERS_TEMP_WAIT_TANKAGGRO)
-                TellMaster("I was still waiting for the tank to gain aggro, but that doesn't make sense anymore...");
-            if (GetCombatOrder() & ORDERS_TEMP_WAIT_OOC)
-                TellMaster("I was still waiting OOC but I just got out of combat...");
-            ClearCombatOrder(ORDERS_TEMP);
-        }
-        SetState(BOTSTATE_LOOTING);
-        m_attackerInfo.clear();
-        if (HasCollectFlag(COLLECT_FLAG_COMBAT))
-            m_lootTargets.unique();
-        else
-            m_lootTargets.clear();
-    }
-
-    if (m_botState == BOTSTATE_LOOTING)
-        return DoLoot();
-
-    if (m_botState == BOTSTATE_FLYING)
-    {
-        /* std::ostringstream out;
-        out << "Taxi: " << m_bot->GetName() << m_ignoreAIUpdatesUntilTime;
-        TellMaster(out.str().c_str());*/
-        DoFlight();
-        SetState(BOTSTATE_NORMAL);
-        SetIgnoreUpdateTime(0);
-        return;
-    }
-
-    // if commanded to follow master and not already following master then follow master
-    if (!m_bot->isInCombat() && !IsMoving())
-        return MovementReset();
-
-    // do class specific non combat actions
-    if (GetClassAI() && !m_bot->IsMounted() && !IsRegenerating())
-    {
-        GetClassAI()->DoNonCombatActions();
-
-        // have we been told to collect GOs
-        if (HasCollectFlag(COLLECT_FLAG_NEAROBJECT))
-        {
-            findNearbyGO();
-            // start looting if have targets
-            if (!m_lootTargets.empty())
-                SetState(BOTSTATE_LOOTING);
-        }
-
-        return;
-    }
-}
-
-Spell* PlayerbotAI::GetCurrentSpell() const
-{
-    if (m_CurrentlyCastingSpellId == 0)
-        return nullptr;
-
-    Spell* const pSpell = m_bot->FindCurrentSpellBySpellId(m_CurrentlyCastingSpellId);
-    return pSpell;
-}
-
-void PlayerbotAI::TellMaster(const std::string& text) const
-{
-    SendWhisper(text, *GetMaster());
-}
-
-void PlayerbotAI::TellMaster(const char* fmt, ...) const
-{
-    char temp_buf[2048];
-    va_list ap;
-    va_start(ap, fmt);
-    (void) vsnprintf(temp_buf, 2048, fmt, ap);
-    va_end(ap);
-    std::string str = temp_buf;
-    TellMaster(str);
-}
-
-void PlayerbotAI::SendWhisper(const std::string& text, Player& player) const
-{
-    if (player.GetPlayerbotAI())
-        return;
-
-    WorldPacket* const packet = new WorldPacket(CMSG_MESSAGECHAT, 200);
-    *packet << uint32(CHAT_MSG_WHISPER);
-    *packet << uint32(LANG_UNIVERSAL);
-    *packet << player.GetName();
-    *packet << text;
-    m_bot->GetSession()->QueuePacket(std::move(std::unique_ptr<WorldPacket>(packet))); // queue the packet to get around race condition
-}
-
-bool PlayerbotAI::canObeyCommandFrom(const Player& player) const
-{
-    return player.GetSession()->GetAccountId() == GetMaster()->GetSession()->GetAccountId();
-}
-
-bool PlayerbotAI::In_Range(Unit* Target, uint32 spellId)
-{
-    const SpellEntry* const pSpellInfo = sSpellTemplate.LookupEntry<SpellEntry>(spellId);
-    if (!pSpellInfo)
-        return false;
-
-    SpellRangeEntry const* TempRange = GetSpellRangeStore()->LookupEntry(pSpellInfo->rangeIndex);
-
-    //Spell has invalid range store so we can't use it
-    if (!TempRange)
-        return false;
-
-    if (TempRange->minRange == 0.0f && TempRange->maxRange == 0.0f)
-        return true;
-
-    //Unit is out of range of this spell
-    if (!m_bot->IsInRange(Target, TempRange->minRange, TempRange->maxRange))
-        return false;
-
-    return true;
-}
-
-bool PlayerbotAI::CheckBotCast(const SpellEntry* sInfo)
-{
-    if (!sInfo)
-        return false;
-
-    // check DoLoot() spells before casting
-    Spell* tmp_spell = new Spell(m_bot, sInfo, false);
-    if (tmp_spell)
-    {
-        if (m_lootCurrent.IsCreature())
-        {
-            if (Creature* obj = m_bot->GetMap()->GetCreature(m_lootCurrent))
-                tmp_spell->m_targets.setUnitTarget(obj);
-        }
-        else if (m_lootCurrent.IsGameObject())
-        {
-            if (GameObject* obj = m_bot->GetMap()->GetGameObject(m_lootCurrent))
-                tmp_spell->m_targets.setGOTarget(obj);
-        }
-
-        SpellCastResult res = tmp_spell->CheckCast(false);
-        switch (res)
-        {
-            case SPELL_CAST_OK:
-                return true;
-            case SPELL_FAILED_ALREADY_OPEN:
-            case SPELL_FAILED_TRY_AGAIN:
-                return true;
-            default:
-                DEBUG_LOG("CheckBotCast SpellCastResult res(%u)", res);
-        }
-    }
-    return false;
-}
-
-bool PlayerbotAI::CastSpell(const char* args)
-{
-    uint32 spellId = getSpellId(args);
-    return (spellId) ? CastSpell(spellId) : false;
-}
-
-bool PlayerbotAI::CastSpell(uint32 spellId, Unit& target)
-{
-    ObjectGuid oldSel = m_bot->GetSelectionGuid();
-    m_bot->SetSelectionGuid(target.GetObjectGuid());
-    bool rv = CastSpell(spellId);
-    m_bot->SetSelectionGuid(oldSel);
-    return rv;
-}
-
-bool PlayerbotAI::CastSpell(uint32 spellId)
-{
-    // some AIs don't check if the bot doesn't have spell before using it
-    // so just return false when this happens
-    if (spellId == 0)
-        return false;
-
-    // see Creature.cpp 1738 for reference
-    // don't allow bot to cast damage spells on friends
-    const SpellEntry* const pSpellInfo = sSpellTemplate.LookupEntry<SpellEntry>(spellId);
-    if (!pSpellInfo)
-    {
-        TellMaster("missing spell entry in CastSpell for spellid %u.", spellId);
-        return false;
-    }
-
-    // check spell cooldown
-    if (!m_bot->IsSpellReady(*pSpellInfo))
-        return false;
-
-    // for AI debug purpose: uncomment the following line and bot will tell Master of every spell they attempt to cast
-    // TellMaster("I'm trying to cast %s (spellID %u)", pSpellInfo->SpellName[0], spellId);
-
-    // Power check (stolen from: CreatureAI.cpp - CreatureAI::CanCastSpell)
-    if (m_bot->GetPower((Powers)pSpellInfo->powerType) < Spell::CalculatePowerCost(pSpellInfo, m_bot))
-        return false;
-
-    // set target
-    ObjectGuid targetGUID = m_bot->GetSelectionGuid();
-    Unit* pTarget = ObjectAccessor::GetUnit(*m_bot, targetGUID);
-
-    if (!pTarget)
-        pTarget = m_bot;
-
-    if (IsPositiveSpell(spellId))
-    {
-        if (pTarget && m_bot->CanAttack(pTarget))
-            pTarget = m_bot;
-    }
-    else
-    {
-        if (pTarget && m_bot->CanAssist(pTarget))
-            return false;
-
-        m_bot->SetInFront(pTarget);
-    }
-
-    float CastTime = 0.0f;
-
-    // stop movement to prevent cancel spell casting
-    SpellCastTimesEntry const* castTimeEntry = sSpellCastTimesStore.LookupEntry(pSpellInfo->CastingTimeIndex);
-    // stop movement to prevent cancel spell casting
-    if (castTimeEntry && castTimeEntry->CastTime)
-    {
-        CastTime = (castTimeEntry->CastTime / 1000);
-        DEBUG_LOG("[PlayerbotAI]: CastSpell - Bot movement reset for casting %s (%u)", pSpellInfo->SpellName[0], spellId);
-        // m_bot->clearUnitState(UNIT_STAT_MOVING);
-        m_bot->StopMoving();
-    }
-
-    uint32 target_type = TARGET_FLAG_UNIT;
-
-    if (pSpellInfo->Effect[0] == SPELL_EFFECT_OPEN_LOCK)
-        target_type = TARGET_FLAG_OBJECT;
-
-    m_CurrentlyCastingSpellId = spellId;
-
-    if (pSpellInfo->Effect[0] == SPELL_EFFECT_OPEN_LOCK ||
-            pSpellInfo->Effect[0] == SPELL_EFFECT_SKINNING)
-    {
-        if (m_lootCurrent)
-        {
-            if (!CheckBotCast(pSpellInfo))
-                return false;
-
-            std::unique_ptr<WorldPacket> packet(new WorldPacket(CMSG_CAST_SPELL, 4 + 1 + 4 + 8));
-            *packet << spellId;
-            *packet << uint8(0);                            // spells cast count;
-            *packet << target_type;
-            *packet << m_lootCurrent.WriteAsPacked();
-            m_bot->GetSession()->QueuePacket(std::move(packet));       // queue the packet to get around race condition */
-
-            if (target_type == TARGET_FLAG_OBJECT)
-            {
-                std::unique_ptr<WorldPacket> packetgouse(new WorldPacket(CMSG_GAMEOBJ_USE, 8));
-                *packetgouse << m_lootCurrent;
-                m_bot->GetSession()->QueuePacket(std::move(packetgouse));  // queue the packet to get around race condition
-
-                GameObject* obj = m_bot->GetMap()->GetGameObject(m_lootCurrent);
-                if (!obj)
-                    return false;
-
-                // add other go types here, i.e.:
-                // GAMEOBJECT_TYPE_CHEST - loot quest items of chest
-                if (obj->GetGoType() == GAMEOBJECT_TYPE_QUESTGIVER)
-                {
-                    TurnInQuests(obj);
-
-                    // auto accept every available quest this NPC has
-                    m_bot->PrepareQuestMenu(m_lootCurrent);
-                    QuestMenu& questMenu = m_bot->PlayerTalkClass->GetQuestMenu();
-                    for (uint32 iI = 0; iI < questMenu.MenuItemCount(); ++iI)
-                    {
-                        QuestMenuItem const& qItem = questMenu.GetItem(iI);
-                        uint32 questID = qItem.m_qId;
-                        if (!AddQuest(questID, obj))
-                            TellMaster("Couldn't take quest");
-                    }
-                    m_lootCurrent = ObjectGuid();
-                    m_bot->GetMotionMaster()->Clear(false);
-                    m_bot->GetMotionMaster()->MoveIdle();
-                }
-            }
-        }
-        else
-            return false;
-    }
-    else
-    {
-        // Check spell range
-        if (!In_Range(pTarget, spellId))
-            return false;
-
-        // Check line of sight
-        if (!m_bot->IsWithinLOSInMap(pTarget))
-            return false;
-
-        if (IsAutoRepeatRangedSpell(pSpellInfo))
-            m_bot->CastSpell(pTarget, pSpellInfo, TRIGGERED_OLD_TRIGGERED); // cast triggered spell
-        else
-            m_bot->CastSpell(pTarget, pSpellInfo, TRIGGERED_NONE);          // uni-cast spell
-    }
-
-    // Some casting times are negative so set ignore update time to 1 sec to avoid stucking the bot AI
-    SetIgnoreUpdateTime(std::max(CastTime, 0.0f) + 1);
-
-    return true;
-}
-
-bool PlayerbotAI::CastPetSpell(uint32 spellId, Unit* target)
-{
-    if (spellId == 0)
-        return false;
-
-    Pet* pet = m_bot->GetPet();
-    if (!pet)
-        return false;
-
-    const SpellEntry* const pSpellInfo = sSpellTemplate.LookupEntry<SpellEntry>(spellId);
-    if (!pSpellInfo)
-    {
-        TellMaster("Missing spell entry in CastPetSpell()");
-        return false;
-    }
-
-    if (!pet->IsSpellReady(*pSpellInfo))
-        return false;
-
-    // set target
-    Unit* pTarget;
-    if (!target)
-    {
-        ObjectGuid targetGUID = m_bot->GetSelectionGuid();
-        pTarget = ObjectAccessor::GetUnit(*m_bot, targetGUID);
-    }
-    else
-        pTarget = target;
-
-    if (IsPositiveSpell(spellId))
-    {
-        if (pTarget && m_bot->CanAttack(pTarget))
-            pTarget = m_bot;
-    }
-    else
-    {
-        if (pTarget && m_bot->CanAssist(pTarget))
-            return false;
-
-        if (!pet->isInFrontInMap(pTarget, 10)) // distance probably should be calculated
-            pet->SetFacingTo(pet->GetAngle(pTarget));
-    }
-
-    pet->CastSpell(pTarget, pSpellInfo, TRIGGERED_NONE);
-
-    Spell* const pSpell = pet->FindCurrentSpellBySpellId(spellId);
-    if (!pSpell)
-        return false;
-
-    return true;
-}
-
-// Perform sanity checks and cast spell
-bool PlayerbotAI::Buff(uint32 spellId, Unit* target, void (*beforeCast)(Player*))
-{
-    if (spellId == 0)
-        return false;
-
-    SpellEntry const* spellProto = sSpellTemplate.LookupEntry<SpellEntry>(spellId);
-
-    if (!spellProto)
-        return false;
-
-    if (!target)
-        return false;
-
-    // Select appropriate spell rank for target's level
-    spellProto = sSpellMgr.SelectAuraRankForLevel(spellProto, target->getLevel());
-    if (!spellProto)
-        return false;
-
-    // Check if spell will boost one of already existent auras
-    bool willBenefitFromSpell = false;
-    for (uint8 i = 0; i < MAX_EFFECT_INDEX; ++i)
-    {
-        if (spellProto->EffectApplyAuraName[i] == SPELL_AURA_NONE)
-            break;
-
-        bool sameOrBetterAuraFound = false;
-        int32 bonus = m_bot->CalculateSpellDamage(target, spellProto, SpellEffectIndex(i));
-        Unit::AuraList const& auras = target->GetAurasByType(AuraType(spellProto->EffectApplyAuraName[i]));
-        for (Unit::AuraList::const_iterator it = auras.begin(); it != auras.end(); ++it)
-            if ((*it)->GetModifier()->m_miscvalue == spellProto->EffectMiscValue[i] && (*it)->GetModifier()->m_amount >= bonus)
-            {
-                sameOrBetterAuraFound = true;
-                break;
-            }
-        willBenefitFromSpell = willBenefitFromSpell || !sameOrBetterAuraFound;
-    }
-
-    if (!willBenefitFromSpell)
-        return false;
-
-    // Druids may need to shapeshift before casting
-    if (beforeCast)
-        (*beforeCast)(m_bot);
-
-    return CastSpell(spellProto->Id, *target);
-}
-
-// Can be used for personal buffs like Mage Armor and Inner Fire
-bool PlayerbotAI::SelfBuff(uint32 spellId)
-{
-    if (spellId == 0)
-        return false;
-
-    if (m_bot->HasAura(spellId))
-        return false;
-
-    return CastSpell(spellId, *m_bot);
-}
-
-// Checks if spell is single per target per caster and will make any effect on target
-bool PlayerbotAI::CanReceiveSpecificSpell(uint8 spec, Unit* target) const
-{
-    if (IsSpellSpecificUniquePerCaster(SpellSpecific(spec)))
-    {
-        Unit::SpellAuraHolderMap holders = target->GetSpellAuraHolderMap();
-        Unit::SpellAuraHolderMap::iterator it;
-        for (it = holders.begin(); it != holders.end(); ++it)
-            if ((*it).second->GetCasterGuid() == m_bot->GetObjectGuid() && GetSpellSpecific((*it).second->GetId()) == SpellSpecific(spec))
-                return false;
-    }
-    return true;
-}
-
-uint8 PlayerbotAI::_findItemSlot(Item* target)
-{
-    // list out items equipped & in main backpack
-    //INVENTORY_SLOT_ITEM_START = 23
-    //INVENTORY_SLOT_ITEM_END = 39
-
-    for (uint8 slot = EQUIPMENT_SLOT_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
-    {
-        // DEBUG_LOG ("[PlayerbotAI]: FindItem - [%s's]backpack slot = %u",m_bot->GetName(),slot); // 23 to 38 = 16
-        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);  // 255, 23 to 38
-        if (pItem)
-        {
-            const ItemPrototype* const pItemProto = pItem->GetProto();
-            if (!pItemProto)
-                continue;
-
-            if (pItemProto->ItemId == target->GetProto()->ItemId)   // have required item
-                return slot;
-        }
-    }
-    // list out items in other removable backpacks
-    //INVENTORY_SLOT_BAG_START = 19
-    //INVENTORY_SLOT_BAG_END = 23
-
-    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)  // 20 to 23 = 4
-    {
-        const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);    // 255, 20 to 23
-        if (pBag)
-            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
-            {
-                // DEBUG_LOG ("[PlayerbotAI]: FindItem - [%s's]bag[%u] slot = %u", m_bot->GetName(), bag, slot);  // 1 to bagsize = ?
-                Item* const pItem = m_bot->GetItemByPos(bag, slot); // 20 to 23, 1 to bagsize
-                if (pItem)
-                {
-                    const ItemPrototype* const pItemProto = pItem->GetProto();
-                    if (!pItemProto)
-                        continue;
-
-                    if (pItemProto->ItemId == target->GetProto()->ItemId)        // have required item
-                        return slot;
-                }
-            }
-    }
-    return 0;
-}
-
-Item* PlayerbotAI::FindItem(uint32 ItemId, bool Equipped_too /* default = false */)
-{
-    uint8 first_slot;
-    Equipped_too ? first_slot = EQUIPMENT_SLOT_START : first_slot = INVENTORY_SLOT_ITEM_START;
-
-    // list out items equipped &/OR in main backpack
-    //EQUIPMENT_SLOT_START = 0
-    //INVENTORY_SLOT_ITEM_START = 23
-    //INVENTORY_SLOT_ITEM_END = 39
-
-    for (uint8 slot = first_slot; slot < INVENTORY_SLOT_ITEM_END; slot++)
-    {
-        // DEBUG_LOG ("[PlayerbotAI]: FindItem - [%s's]backpack slot = %u",m_bot->GetName(),slot); // 23 to 38 = 16
-        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);  // 255, 23 to 38
-        if (pItem)
-        {
-            const ItemPrototype* const pItemProto = pItem->GetProto();
-            if (!pItemProto)
-                continue;
-
-            if (pItemProto->ItemId == ItemId)   // have required item
-                return pItem;
-        }
-    }
-    // list out items in other removable backpacks
-    //INVENTORY_SLOT_BAG_START = 19
-    //INVENTORY_SLOT_BAG_END = 23
-
-    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)  // 20 to 23 = 4
-    {
-        const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);    // 255, 20 to 23
-        if (pBag)
-            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
-            {
-                DEBUG_LOG("[PlayerbotAI]: FindItem - [%s's]bag[%u] slot = %u", m_bot->GetName(), bag, slot);   // 1 to bagsize = ?
-                Item* const pItem = m_bot->GetItemByPos(bag, slot); // 20 to 23, 1 to bagsize
-                if (pItem)
-                {
-                    const ItemPrototype* const pItemProto = pItem->GetProto();
-                    if (!pItemProto)
-                        continue;
-
-                    if (pItemProto->ItemId == ItemId)        // have required item
-                        return pItem;
-                }
-            }
-    }
-    return nullptr;
-}
-
-Item* PlayerbotAI::FindItemInBank(uint32 ItemId)
-{
-    // list out items in bank item slots
-
-    for (uint8 slot = BANK_SLOT_ITEM_START; slot < BANK_SLOT_ITEM_END; slot++)
-    {
-        // sLog.outDebug("[%s's]backpack slot = %u",m_bot->GetName(),slot);
-        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
-        if (pItem)
-        {
-            const ItemPrototype* const pItemProto = pItem->GetProto();
-            if (!pItemProto)
-                continue;
-
-            if (pItemProto->ItemId == ItemId)   // have required item
-                return pItem;
-        }
-    }
-    // list out items in bank bag slots
-
-    for (uint8 bag = BANK_SLOT_BAG_START; bag < BANK_SLOT_BAG_END; ++bag)
-    {
-        const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
-        if (pBag)
-            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
-            {
-                // sLog.outDebug("[%s's]bag[%u] slot = %u", m_bot->GetName(), bag, slot);
-                Item* const pItem = m_bot->GetItemByPos(bag, slot);
-                if (pItem)
-                {
-                    const ItemPrototype* const pItemProto = pItem->GetProto();
-                    if (!pItemProto)
-                        continue;
-
-                    if (pItemProto->ItemId == ItemId)        // have required item
-                        return pItem;
-                }
-            }
-    }
-    return nullptr;
-}
-
-Item* PlayerbotAI::FindKeyForLockValue(uint32 reqSkillValue)
-{
-    if (reqSkillValue <= 25 && m_bot->HasItemCount(SILVER_SKELETON_KEY, 1))
-        return FindItem(SILVER_SKELETON_KEY);
-    if (reqSkillValue <= 125 && m_bot->HasItemCount(GOLDEN_SKELETON_KEY, 1))
-        return FindItem(GOLDEN_SKELETON_KEY);
-    if (reqSkillValue <= 200 && m_bot->HasItemCount(TRUESILVER_SKELETON_KEY, 1))
-        return FindItem(TRUESILVER_SKELETON_KEY);
-    if (reqSkillValue <= 300 && m_bot->HasItemCount(ARCANITE_SKELETON_KEY, 1))
-        return FindItem(ARCANITE_SKELETON_KEY);
-
-    return nullptr;
-}
-
-Item* PlayerbotAI::FindBombForLockValue(uint32 reqSkillValue)
-{
-    if (reqSkillValue <= 150 && m_bot->HasItemCount(SMALL_SEAFORIUM_CHARGE, 1))
-        return FindItem(SMALL_SEAFORIUM_CHARGE);
-    if (reqSkillValue <= 250 && m_bot->HasItemCount(LARGE_SEAFORIUM_CHARGE, 1))
-        return FindItem(LARGE_SEAFORIUM_CHARGE);
-    if (reqSkillValue <= 300 && m_bot->HasItemCount(POWERFUL_SEAFORIUM_CHARGE, 1))
-        return FindItem(POWERFUL_SEAFORIUM_CHARGE);
-    if (reqSkillValue <= 350 && m_bot->HasItemCount(ELEMENTAL_SEAFORIUM_CHARGE, 1))
-        return FindItem(ELEMENTAL_SEAFORIUM_CHARGE);
-
-    return nullptr;
-}
-
-bool PlayerbotAI::HasTool(uint32 TC)
-{
-    std::ostringstream out;
-
-    switch (TC)
-    {
-        case TC_MINING_PICK:                //  = 165
-
-            if (m_bot->HasItemTotemCategory(TC))
-                return true;
-            else
-                out << "|cffff0000I do not have a MINING PICK!";
-            break;
-
-        case TC_ARCLIGHT_SPANNER:          //  = 14
-
-            if (m_bot->HasItemTotemCategory(TC))
-                return true;
-            else
-                out << "|cffff0000I do not have an ARCLIGHT SPANNER!";
-            break;
-
-        case TC_BLACKSMITH_HAMMER:         //  = 162
-
-            if (m_bot->HasItemTotemCategory(TC))
-                return true;
-            else
-                out << "|cffff0000I do not have a BLACKSMITH's HAMMER!";
-            break;
-
-        case TC_SKINNING_KNIFE:            //  = 166
-
-            if (m_bot->HasItemTotemCategory(TC))
-                return true;
-            else
-                out << "|cffff0000I do not have a SKINNING KNIFE!";
-            break;
-
-        case TC_COPPER_ROD:                //  = 6,
-            if (m_bot->HasItemTotemCategory(TC))
-                return true;
-            else
-                out << "|cffff0000I do not have a RUNED COPPER ROD!";
-            break;
-
-        case TC_SILVER_ROD:                //  = 7,
-            if (m_bot->HasItemTotemCategory(TC))
-                return true;
-            else
-                out << "|cffff0000I do not have a RUNED SILVER ROD!";
-            break;
-
-        case TC_GOLDEN_ROD:                //  = 8,
-            if (m_bot->HasItemTotemCategory(TC))
-                return true;
-            else
-                out << "|cffff0000I do not have a RUNED GOLDEN ROD!";
-            break;
-
-        case TC_TRUESILVER_ROD:            //  = 9,
-            if (m_bot->HasItemTotemCategory(TC))
-                return true;
-            else
-                out << "|cffff0000I do not have a RUNED TRUESILVER ROD!";
-            break;
-
-        case TC_ARCANITE_ROD:              //  = 10,
-            if (m_bot->HasItemTotemCategory(TC))
-                return true;
-            else
-                out << "|cffff0000I do not have a RUNED ARCANITE ROD!";
-            break;
-
-        case TC_FEL_IRON_ROD:              //  = 41,
-            if (m_bot->HasItemTotemCategory(TC))
-                return true;
-            else
-                out << "|cffff0000I do not have a RUNED FEL IRON ROD!";
-            break;
-
-        case TC_ADAMANTITE_ROD:            //  = 62,
-            if (m_bot->HasItemTotemCategory(TC))
-                return true;
-            else
-                out << "|cffff0000I do not have a RUNED ADAMANTITE ROD!";
-            break;
-
-        case TC_ETERNIUM_ROD:              //  = 63,
-            if (m_bot->HasItemTotemCategory(TC))
-                return true;
-            else
-                out << "|cffff0000I do not have a RUNED ETERNIUM ROD!";
-            break;
-        default:
-            out << "|cffffffffI do not know what tool that needs! TC (" << TC << ")";
-    }
-    TellMaster(out.str().c_str());
-    return false;
-}
-
-bool PlayerbotAI::PickPocket(Unit* pTarget)
-{
-    if (!pTarget)
-        return false;
-
-    ObjectGuid markGuid = pTarget->GetObjectGuid();
-    Creature* c = m_bot->GetMap()->GetCreature(markGuid);
-    if (c)
-    {
-        Loot*& loot = c->loot;
-        if (!loot)
-            loot = new Loot(m_bot, c, LOOT_PICKPOCKETING);
-        else
-        {
-            if (loot->GetLootType() != LOOT_PICKPOCKETING)
-            {
-                delete loot;
-                loot = new Loot(m_bot, c, LOOT_PICKPOCKETING);
-            }
-        }
-
-        if (loot->GetGoldAmount())
-        {
-            m_bot->ModifyMoney(loot->GetGoldAmount());
-
-            if (m_mgr->m_confDebugWhisper)
-            {
-                std::ostringstream out;
-
-                // calculate how much money bot loots
-                uint32 copper = loot->GetGoldAmount();
-                uint32 gold = uint32(copper / 10000);
-                copper -= (gold * 10000);
-                uint32 silver = uint32(copper / 100);
-                copper -= (silver * 100);
-
-                out << "|r|cff009900" << m_bot->GetName() << " loots: " << "|h|cffffffff[|r|cff00ff00" << gold
-                    << "|r|cfffffc00g|r|cff00ff00" << silver
-                    << "|r|cffcdcdcds|r|cff00ff00" << copper
-                    << "|r|cff993300c"
-                    << "|h|cffffffff]";
-
-                TellMaster(out.str().c_str());
-            }
-
-            // send the money to the bot and remove it from the creature
-            loot->SendGold(m_bot);
-        }
-
-        if (!loot->AutoStore(m_bot, false, NULL_BAG, NULL_SLOT))
-            sLog.outDebug("PLAYERBOT Debug: Failed to get loot from pickpocketed NPC");
-
-        // release the loot whatever happened
-        loot->Release(m_bot);
-    }
-    return false; // ensures that the rogue only pick pockets target once
-}
-
-bool PlayerbotAI::HasSpellReagents(uint32 spellId)
-{
-    const SpellEntry* const pSpellInfo = sSpellTemplate.LookupEntry<SpellEntry>(spellId);
-    if (!pSpellInfo)
-        return false;
-
-    if (m_bot->CanNoReagentCast(pSpellInfo))
-        return true;
-
-    for (uint32 i = 0; i < MAX_SPELL_REAGENTS; ++i)
-    {
-        if (pSpellInfo->Reagent[i] <= 0)
-            continue;
-
-        uint32 itemid = pSpellInfo->Reagent[i];
-        uint32 count = pSpellInfo->ReagentCount[i];
-
-        if (!m_bot->HasItemCount(itemid, count))
-            return false;
-    }
-
-    return true;
-}
-
-uint32 PlayerbotAI::GetSpellCharges(uint32 spellId)
-{
-    const SpellEntry* const pSpellInfo = sSpellTemplate.LookupEntry<SpellEntry>(spellId);
-    if (!pSpellInfo)
-        return 0;
-
-    if (m_bot->CanNoReagentCast(pSpellInfo))
-        return 0;
-
-    uint32 charges = 0;
-    std::list<uint32> chargeList;
-    for (uint32 i = 0; i < MAX_SPELL_REAGENTS; ++i)
-    {
-        if (pSpellInfo->Reagent[i] <= 0)
-            continue;
-
-        uint32 totalcount = 0;
-        uint32 itemid = pSpellInfo->Reagent[i];
-        uint32 count = pSpellInfo->ReagentCount[i];
-        ItemCountInInv(itemid, totalcount);
-        chargeList.push_back((totalcount / count));
-    }
-
-    for (uint32 i = 0; i < MAX_SPELL_TOTEM_CATEGORIES; ++i)
-    {
-        if (pSpellInfo->TotemCategory[i] == 0)
-            continue;
-
-        if (!m_bot->HasItemTotemCategory(pSpellInfo->TotemCategory[i]))
-        {
-            m_noToolList.push_back(pSpellInfo->TotemCategory[i]);
-            return 0;
-        }
-    }
-
-    if (!chargeList.empty())
-    {
-        charges = chargeList.front();
-        chargeList.pop_front();
-        for (std::list<uint32>::iterator it = chargeList.begin(); it != chargeList.end(); ++it)
-            if (*it < charges)
-                charges = *it;
-    }
-    return charges;
-}
-
-void PlayerbotAI::ItemCountInInv(uint32 itemid, uint32& count)
-{
-    for (int i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
-    {
-        Item* pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
-        if (pItem && pItem->GetEntry() == itemid && !pItem->IsInTrade())
-            count += pItem->GetCount();
-    }
-
-    for (int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
-    {
-        if (Bag* pBag = (Bag*)m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
-        {
-            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
-            {
-                Item* pItem = m_bot->GetItemByPos(i, j);
-                if (pItem && pItem->GetEntry() == itemid && !pItem->IsInTrade())
-                    count += pItem->GetCount();
-            }
-        }
-    }
-}
-
-// extracts all item ids in format below
-// I decided to roll my own extractor rather then use the one in ChatHandler
-// because this one works on a const string, and it handles multiple links
-// |color|linkType:key:something1:...:somethingN|h[name]|h|r
-void PlayerbotAI::extractItemIds(const std::string& text, std::list<uint32>& itemIds) const
-{
-    uint8 pos = 0;
-    while (true)
-    {
-        int i = text.find("Hitem:", pos);
-        if (i == -1)
-            break;
-        pos = i + 6;
-        int endPos = text.find(':', pos);
-        if (endPos == -1)
-            break;
-        std::string idC = text.substr(pos, endPos - pos);
-        uint32 id = atol(idC.c_str());
-        pos = endPos;
-        if (id)
-            itemIds.push_back(id);
-    }
-}
-
-void PlayerbotAI::extractMailIds(const std::string& text, std::list<uint32>& mailIds) const
-{
-    uint8 pos = 0;
-    while (true)
-    {
-        int i = text.find("Hmail:", pos);
-        if (i == -1)
-            break;
-        pos = i + 6;
-        int endPos = text.find('|', pos);
-        if (endPos == -1)
-            break;
-        std::string idC = text.substr(pos, endPos - pos);
-        uint32 id = atol(idC.c_str());
-        pos = endPos;
-        if (id)
-            mailIds.push_back(id);
-    }
-}
-
-void PlayerbotAI::extractQuestIds(const std::string& text, std::list<uint32>& questIds) const
-{
-    uint8 pos = 0;
-    while (true)
-    {
-        int i = text.find("Hquest:", pos);
-        if (i == -1)
-            break;
-        pos = i + 7;
-        int endPos = text.find(':', pos);
-        if (endPos == -1)
-            break;
-        std::string idC = text.substr(pos, endPos - pos);
-        uint32 id = atol(idC.c_str());
-        pos = endPos;
-        if (id)
-            questIds.push_back(id);
-    }
-}
-
-// Build an hlink for Weapon skills in Aqua
-void PlayerbotAI::MakeWeaponSkillLink(const SpellEntry* sInfo, std::ostringstream& out, uint32 skillid)
-{
-    int loc = GetMaster()->GetSession()->GetSessionDbcLocale();
-    out << "|cff00ffff|Hspell:" << sInfo->Id << "|h[" << sInfo->SpellName[loc] << " : " << m_bot->GetSkillValue(skillid) << " /" << m_bot->GetSkillMax(skillid) << "]|h|r";
-}
-
-// Build an hlink for spells in White
-void PlayerbotAI::MakeSpellLink(const SpellEntry* sInfo, std::ostringstream& out)
-{
-    int    loc = GetMaster()->GetSession()->GetSessionDbcLocale();
-    out << "|cffffffff|Hspell:" << sInfo->Id << "|h[" << sInfo->SpellName[loc] << "]|h|r";
-}
-
-// Builds a hlink for an item, but since its
-// only a ItemPrototype, we cant fill in everything
-void PlayerbotAI::MakeItemLink(const ItemPrototype* item, std::ostringstream& out)
-{
-    // Color
-    out << "|c";
-    switch (item->Quality)
-    {
-        case ITEM_QUALITY_POOR:     out << "ff9d9d9d"; break;  //GREY
-        case ITEM_QUALITY_NORMAL:   out << "ffffffff"; break;  //WHITE
-        case ITEM_QUALITY_UNCOMMON: out << "ff1eff00"; break;  //GREEN
-        case ITEM_QUALITY_RARE:     out << "ff0070dd"; break;  //BLUE
-        case ITEM_QUALITY_EPIC:     out << "ffa335ee"; break;  //PURPLE
-        case ITEM_QUALITY_LEGENDARY: out << "ffff8000"; break;  //ORANGE
-        case ITEM_QUALITY_ARTIFACT: out << "ffe6cc80"; break;  //LIGHT YELLOW
-        default:                    out << "ffff0000"; break;  //Don't know color, so red?
-    }
-    out << "|Hitem:";
-
-    // Item Id
-    out << item->ItemId << ":";
-
-    // Permanent enchantment, gems, 4 unknowns, and reporter_level
-    // ->new items wont have enchantments or gems so..
-    out << "0:0:0:0:0:0:0:0:0";
-
-    // Name
-    std::string name = item->Name1;
-    ItemLocalization(name, item->ItemId);
-    out << "|h[" << name << "]|h|r";
-}
-
-// Builds a hlink for an item, includes everything
-// |color|Hitem:item_id:perm_ench_id:gem1:gem2:gem3:0:0:0:0:reporter_level|h[name]|h|r
-void PlayerbotAI::MakeItemLink(const Item* item, std::ostringstream& out, bool IncludeQuantity /*= true*/)
-{
-    const ItemPrototype* proto = item->GetProto();
-    // Color
-    out << "|c";
-    switch (proto->Quality)
-    {
-        case ITEM_QUALITY_POOR:     out << "ff9d9d9d"; break;  //GREY
-        case ITEM_QUALITY_NORMAL:   out << "ffffffff"; break;  //WHITE
-        case ITEM_QUALITY_UNCOMMON: out << "ff1eff00"; break;  //GREEN
-        case ITEM_QUALITY_RARE:     out << "ff0070dd"; break;  //BLUE
-        case ITEM_QUALITY_EPIC:     out << "ffa335ee"; break;  //PURPLE
-        case ITEM_QUALITY_LEGENDARY: out << "ffff8000"; break;  //ORANGE
-        case ITEM_QUALITY_ARTIFACT: out << "ffe6cc80"; break;  //LIGHT YELLOW
-        default:                    out << "ffff0000"; break;  //Don't know color, so red?
-    }
-    out << "|Hitem:";
-
-    // Item Id
-    out << proto->ItemId << ":";
-
-    // Permanent enchantment
-    out << item->GetEnchantmentId(PERM_ENCHANTMENT_SLOT) << ":";
-
-    // Gems
-    uint32 g1 = 0, g2 = 0, g3 = 0;
-    for (uint32 slot = SOCK_ENCHANTMENT_SLOT; slot < SOCK_ENCHANTMENT_SLOT + MAX_GEM_SOCKETS; ++slot)
-    {
-        uint32 eId = item->GetEnchantmentId(EnchantmentSlot(slot));
-        if (!eId) continue;
-
-        SpellItemEnchantmentEntry const* entry = sSpellItemEnchantmentStore.LookupEntry(eId);
-        if (!entry) continue;
-
-        switch (slot - SOCK_ENCHANTMENT_SLOT)
-        {
-            case 1: g1 = entry->GemID; break;
-            case 2: g2 = entry->GemID; break;
-            case 3: g3 = entry->GemID; break;
-        }
-    }
-    out << g1 << ":" << g2 << ":" << g3 << ":";
-
-    // Temp enchantment, Bonus Enchantment, Prismatic Enchantment?
-    // Other stuff, don't know what it is
-    out << "0:0:0:0:";
-
-    // Reporter Level
-    out << "0";
-
-    // Name
-    std::string name = proto->Name1;
-    ItemLocalization(name, proto->ItemId);
-    out << "|h[" << name << "]|h|r";
-
-    // Stacked items
-    if (item->GetCount() > 1 && IncludeQuantity)
-        out << "x" << item->GetCount() << ' ';
-}
-
-// Builds a string for an item   |color[name]|r
-void PlayerbotAI::MakeItemText(const Item* item, std::ostringstream& out, bool IncludeQuantity /*= true*/)
-{
-    const ItemPrototype* proto = item->GetProto();
-    // Color
-    out << "|c";
-    switch (proto->Quality)
-    {
-        case ITEM_QUALITY_POOR:     out << "ff9d9d9d"; break;  //GREY
-        case ITEM_QUALITY_NORMAL:   out << "ffffffff"; break;  //WHITE
-        case ITEM_QUALITY_UNCOMMON: out << "ff1eff00"; break;  //GREEN
-        case ITEM_QUALITY_RARE:     out << "ff0070dd"; break;  //BLUE
-        case ITEM_QUALITY_EPIC:     out << "ffa335ee"; break;  //PURPLE
-        case ITEM_QUALITY_LEGENDARY: out << "ffff8000"; break;  //ORANGE
-        case ITEM_QUALITY_ARTIFACT: out << "ffe6cc80"; break;  //LIGHT YELLOW
-        default:                    out << "ffff0000"; break;  //Don't know color, so red?
-    }
-
-    // Name
-    std::string name = proto->Name1;
-    ItemLocalization(name, proto->ItemId);
-    out << "[" << name << "]|r";
-
-    // Stacked items
-    if (item->GetCount() > 1 && IncludeQuantity)
-        out << "x" << item->GetCount() << ' ';
-}
-
-void PlayerbotAI::extractAuctionIds(const std::string& text, std::list<uint32>& auctionIds) const
-{
-    uint8 pos = 0;
-    while (true)
-    {
-        int i = text.find("Htitle:", pos);
-        if (i == -1)
-            break;
-        pos = i + 7;
-        int endPos = text.find('|', pos);
-        if (endPos == -1)
-            break;
-        std::string idC = text.substr(pos, endPos - pos);
-        uint32 id = atol(idC.c_str());
-        pos = endPos;
-        if (id)
-            auctionIds.push_back(id);
-    }
-}
-
-void PlayerbotAI::extractSpellId(const std::string& text, uint32& spellId) const
-{
-
-    //   Link format
-    //   |cffffffff|Hspell:" << spellId << ":" << "|h[" << pSpellInfo->SpellName[loc] << "]|h|r";
-    //   cast |cff71d5ff|Hspell:686|h[Shadow Bolt]|h|r";
-    //   012345678901234567890123456
-    //        base = 16 >|  +7 >|
-
-    uint8 pos = 0;
-
-    int i = text.find("Hspell:", pos);
-    if (i == -1)
-        return;
-
-    // DEBUG_LOG("[PlayerbotAI]: extractSpellId - first pos %u i %u",pos,i);
-    pos = i + 7;     // start of window in text 16 + 7 = 23
-    int endPos = text.find('|', pos);
-    if (endPos == -1)
-        return;
-
-    // DEBUG_LOG("[PlayerbotAI]: extractSpellId - second endpos : %u pos : %u",endPos,pos);
-    std::string idC = text.substr(pos, endPos - pos);     // 26 - 23
-    spellId = atol(idC.c_str());
-    pos = endPos;     // end
-}
-
-void PlayerbotAI::extractSpellIdList(const std::string& text, BotEntryList& m_spellsToLearn) const
-{
-
-    //   Link format
-    //   |cffffffff|Hspell:" << spellId << ":" << "|h[" << pSpellInfo->SpellName[loc] << "]|h|r";
-    //   cast |cff71d5ff|Hspell:686|h[Shadow Bolt]|h|r";
-    //   012345678901234567890123456
-    //        base = 16 >|  +7 >|
-
-    uint8 pos = 0;
-    while (true)
-    {
-        int i = text.find("Hspell:", pos);
-        if (i == -1)
-            break;
-
-        // DEBUG_LOG("[PlayerbotAI]: extractSpellIdList - first pos %u i %u",pos,i);
-        pos = i + 7;     // start of window in text 16 + 7 = 23
-        int endPos = text.find('|', pos);
-        if (endPos == -1)
-            break;
-
-        // DEBUG_LOG("[PlayerbotAI]: extractSpellIdList - second endpos : %u pos : %u",endPos,pos);
-        std::string idC = text.substr(pos, endPos - pos);     // 26 - 23
-        uint32 spellId = atol(idC.c_str());
-        pos = endPos;     // end
-
-        if (spellId)
-            m_spellsToLearn.push_back(spellId);
-    }
-}
-
-void PlayerbotAI::extractGOinfo(const std::string& text, BotObjectList& m_lootTargets) const
-{
-
-    //    Link format
-    //    |cFFFFFF00|Hfound:" << guid << ':'  << entry << ':'  <<  "|h[" << gInfo->name << "]|h|r";
-    //    |cFFFFFF00|Hfound:9582:1731|h[Copper Vein]|h|r
-
-    uint8 pos = 0;
-    while (true)
-    {
-        // extract GO guid
-        int i = text.find("Hfound:", pos);     // base H = 11
-        if (i == -1)     // break if error
-            break;
-
-        pos = i + 7;     //start of window in text 11 + 7 = 18
-        int endPos = text.find(':', pos);     // end of window in text 22
-        if (endPos == -1)     //break if error
-            break;
-        std::string guidC = text.substr(pos, endPos - pos);     // get string within window i.e guid 22 - 18 =  4
-        uint32 guid = atol(guidC.c_str());     // convert ascii to long int
-
-        // extract GO entry
-        pos = endPos + 1;
-        endPos = text.find(':', pos);     // end of window in text
-        if (endPos == -1)     //break if error
-            break;
-
-        std::string entryC = text.substr(pos, endPos - pos);     // get string within window i.e entry
-        uint32 entry = atol(entryC.c_str());     // convert ascii to float
-
-        ObjectGuid lootCurrent = ObjectGuid(HIGHGUID_GAMEOBJECT, entry, guid);
-
-        if (GameObject* gob = m_bot->GetMap()->GetGameObject(lootCurrent))
-            m_lootTargets.push_back(gob->GetObjectGuid());
-    }
-}
-
-void PlayerbotAI::extractTalentIds(const std::string& text, std::list<talentPair>& talentIds) const
-{
-    // Link format:
-    // |color|Htalent:talent_id:rank|h[name]|h|r
-    // |cff4e96f7|Htalent:1396:4|h[Unleashed Fury]|h|r
-
-    uint8 pos = 0;
-    while (true)
-    {
-        int i = text.find("Htalent:", pos);
-        if (i == -1)
-            break;
-        pos = i + 8;
-        // DEBUG_LOG("extractTalentIds first pos %u i %u",pos,i);
-        // extract talent_id
-        int endPos = text.find(':', pos);
-        if (endPos == -1)
-            break;
-        // DEBUG_LOG("extractTalentId second endpos : %u pos : %u",endPos,pos);
-        std::string idC = text.substr(pos, endPos - pos);
-        uint32 id = atol(idC.c_str());
-        pos = endPos + 1;
-        // extract rank
-        endPos = text.find('|', pos);
-        if (endPos == -1)
-            break;
-        // DEBUG_LOG("extractTalentId third endpos : %u pos : %u",endPos,pos);
-        std::string rankC = text.substr(pos, endPos - pos);
-        uint32 rank = atol(rankC.c_str());
-        pos = endPos + 1;
-
-        // DEBUG_LOG("extractTalentId second id : %u  rank : %u",id,rank);
-
-        if (id)
-            talentIds.push_back(std::pair<uint32, uint32>(id, rank));
-    }
-}
-
-// extracts currency in #g#s#c format
-uint32 PlayerbotAI::extractMoney(const std::string& text) const
-{
-    // if user specified money in ##g##s##c format
-    std::string acum = "";
-    uint32 copper = 0;
-    for (uint8 i = 0; i < text.length(); i++)
-    {
-        if (text[i] == 'g')
-        {
-            copper += (atol(acum.c_str()) * 100 * 100);
-            acum = "";
-        }
-        else if (text[i] == 'c')
-        {
-            copper += atol(acum.c_str());
-            acum = "";
-        }
-        else if (text[i] == 's')
-        {
-            copper += (atol(acum.c_str()) * 100);
-            acum = "";
-        }
-        else if (text[i] == ' ')
-            break;
-        else if (text[i] >= 48 && text[i] <= 57)
-            acum += text[i];
-        else
-        {
-            copper = 0;
-            break;
-        }
-    }
-    return copper;
-}
-
-// finds items in equipment and adds Item* to foundItemList
-// also removes found item IDs from itemIdSearchList when found
-void PlayerbotAI::findItemsInEquip(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const
-{
-    for (uint8 slot = EQUIPMENT_SLOT_START; itemIdSearchList.size() > 0 && slot < EQUIPMENT_SLOT_END; slot++)
-    {
-        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
-        if (!pItem)
-            continue;
-
-        for (std::list<uint32>::iterator it = itemIdSearchList.begin(); it != itemIdSearchList.end(); ++it)
-        {
-            if (pItem->GetProto()->ItemId != *it)
-                continue;
-
-            foundItemList.push_back(pItem);
-            itemIdSearchList.erase(it);
-            break;
-        }
-    }
-}
-
-// finds items in inventory and adds Item* to foundItemList
-// also removes found item IDs from itemIdSearchList when found
-void PlayerbotAI::findItemsInInv(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const
-{
-
-    // look for items in main bag
-    for (uint8 slot = INVENTORY_SLOT_ITEM_START; itemIdSearchList.size() > 0 && slot < INVENTORY_SLOT_ITEM_END; ++slot)
-    {
-        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
-        if (!pItem)
-            continue;
-
-        for (std::list<uint32>::iterator it = itemIdSearchList.begin(); it != itemIdSearchList.end(); ++it)
-        {
-            if (pItem->GetProto()->ItemId != *it)
-                continue;
-
-            if (m_bot->GetTrader() && m_bot->GetTradeData()->HasItem(pItem->GetObjectGuid()))
-                continue;
-
-            foundItemList.push_back(pItem);
-            itemIdSearchList.erase(it);
-            break;
-        }
-    }
-
-    // for all for items in other bags
-    for (uint8 bag = INVENTORY_SLOT_BAG_START; itemIdSearchList.size() > 0 && bag < INVENTORY_SLOT_BAG_END; ++bag)
-    {
-        Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
-        if (!pBag)
-            continue;
-
-        for (uint8 slot = 0; itemIdSearchList.size() > 0 && slot < pBag->GetBagSize(); ++slot)
-        {
-            Item* const pItem = m_bot->GetItemByPos(bag, slot);
-            if (!pItem)
-                continue;
-
-            for (std::list<uint32>::iterator it = itemIdSearchList.begin(); it != itemIdSearchList.end(); ++it)
-            {
-                if (pItem->GetProto()->ItemId != *it)
-                    continue;
-
-                if (m_bot->GetTrader() && m_bot->GetTradeData()->HasItem(pItem->GetObjectGuid()))
-                    continue;
-
-                foundItemList.push_back(pItem);
-                itemIdSearchList.erase(it);
-                break;
-            }
-        }
-    }
-}
-
-void PlayerbotAI::findNearbyGO()
-{
-    if (m_collectObjects.empty())
-        return;
-
-    GameObjectList tempTargetGOList;
-    float radius = 20.0f;
-
-    for (BotEntryList::iterator itr = m_collectObjects.begin(); itr != m_collectObjects.end(); ++itr)
-    {
-        uint32 entry = *(itr);
-        GameObjectInfo const* gInfo = ObjectMgr::GetGameObjectInfo(entry);
-
-        uint32 lootid = gInfo->GetLootId();
-
-        if (gInfo->GetLootId() > 0)
-            for (BotLootList::iterator it = m_botQuestLoot.begin(); it != m_botQuestLoot.end(); ++it)
-                if (it->first == lootid)
-                    if (!IsInQuestItemList(it->second))
-                    {
-                        it = m_botQuestLoot.erase(it);
-                        m_collectObjects.remove(entry); // remove gameobject from collect list
-                        return;
-                    }
-
-        // search for GOs with entry, within range of m_bot
-        MaNGOS::GameObjectEntryInPosRangeCheck go_check(*m_bot, entry, m_bot->GetPositionX(), m_bot->GetPositionY(), m_bot->GetPositionZ(), radius);
-        MaNGOS::GameObjectListSearcher<MaNGOS::GameObjectEntryInPosRangeCheck> checker(tempTargetGOList, go_check);
-        Cell::VisitGridObjects(m_bot, checker, radius);
-
-        // no objects found, continue to next entry
-        if (tempTargetGOList.empty())
-            continue;
-
-        // add any objects found to our lootTargets
-        for (GameObjectList::iterator iter = tempTargetGOList.begin(); iter != tempTargetGOList.end(); iter++)
-        {
-            GameObject* go = (*iter);
-
-            TerrainInfo const* map = go->GetTerrain();
-
-            float ground_z = map->GetHeightStatic(go->GetPositionX(), go->GetPositionY(), go->GetPositionZ());
-            // DEBUG_LOG("ground_z (%f) > INVALID_HEIGHT (%f)",ground_z,INVALID_HEIGHT);
-            if ((ground_z > INVALID_HEIGHT) && go->IsSpawned())
-                m_lootTargets.push_back(go->GetObjectGuid());
-        }
-    }
-}
-
-void PlayerbotAI::findNearbyCreature()
-{
-    CreatureList creatureList;
-    float radius = 2.5;
-
-    CellPair pair(MaNGOS::ComputeCellPair(m_bot->GetPositionX(), m_bot->GetPositionY()));
-    Cell cell(pair);
-
-    MaNGOS::AnyUnitInObjectRangeCheck go_check(m_bot, radius);
-    MaNGOS::CreatureListSearcher<MaNGOS::AnyUnitInObjectRangeCheck> go_search(creatureList, go_check);
-    TypeContainerVisitor<MaNGOS::CreatureListSearcher<MaNGOS::AnyUnitInObjectRangeCheck>, GridTypeMapContainer> go_visit(go_search);
-
-    // Get Creatures
-    cell.Visit(pair, go_visit, *(m_bot->GetMap()), *(m_bot), radius);
-
-    // if (!creatureList.empty())
-    //    TellMaster("Found %i Creatures & size of m_findNPC (%i)", creatureList.size(),m_findNPC.size());
-
-    for (CreatureList::iterator iter = creatureList.begin(); iter != creatureList.end(); iter++)
-    {
-        Creature* currCreature = *iter;
-
-        for (std::list<enum NPCFlags>::iterator itr = m_findNPC.begin(); itr != m_findNPC.end();)
-        {
-            uint32 npcflags = currCreature->GetUInt32Value(UNIT_NPC_FLAGS);
-
-            if (!(*itr & npcflags))
-            {
-                ++itr;
-                continue;
-            }
-
-            if ((*itr == UNIT_NPC_FLAG_TRAINER) && !currCreature->CanTrainAndResetTalentsOf(m_bot))
-                break;
-
-            WorldObject* wo = m_bot->GetMap()->GetWorldObject(currCreature->GetObjectGuid());
-
-            if (m_bot->GetDistance(wo) > CONTACT_DISTANCE + wo->GetObjectBoundingRadius())
-            {
-                float x, y, z;
-                wo->GetContactPoint(m_bot, x, y, z, wo->GetObjectBoundingRadius());
-                m_bot->GetMotionMaster()->MovePoint(wo->GetMapId(), x, y, z, false);
-                // give time to move to point before trying again
-                SetIgnoreUpdateTime(1);
-            }
-
-            if (m_bot->GetDistance(wo) < INTERACTION_DISTANCE)
-            {
-                // DEBUG_LOG("%s is interacting with (%s)",m_bot->GetName(),currCreature->GetCreatureInfo()->Name);
-                GossipMenuItemsMapBounds pMenuItemBounds = sObjectMgr.GetGossipMenuItemsMapBounds(currCreature->GetCreatureInfo()->GossipMenuId);
-
-                // prepares quest menu when true
-                bool canSeeQuests = currCreature->GetCreatureInfo()->GossipMenuId == m_bot->GetDefaultGossipMenuForSource(wo);
-
-                // if canSeeQuests (the default, top level menu) and no menu options exist for this, use options from default options
-                if (pMenuItemBounds.first == pMenuItemBounds.second && canSeeQuests)
-                    pMenuItemBounds = sObjectMgr.GetGossipMenuItemsMapBounds(0);
-
-                for (GossipMenuItemsMap::const_iterator it = pMenuItemBounds.first; it != pMenuItemBounds.second; it++)
-                {
-                    if (!(it->second.npc_option_npcflag & npcflags))
-                        continue;
-
-                    switch (it->second.option_id)
-                    {
-                        case GOSSIP_OPTION_AUCTIONEER:
-                        case GOSSIP_OPTION_BANKER:
-                        case GOSSIP_OPTION_TAXIVENDOR:
-                        case GOSSIP_OPTION_GOSSIP:
-                        case GOSSIP_OPTION_INNKEEPER:
-                        case GOSSIP_OPTION_TRAINER:
-                        case GOSSIP_OPTION_QUESTGIVER:
-                        case GOSSIP_OPTION_VENDOR:
-                        case GOSSIP_OPTION_UNLEARNTALENTS:
-                        case GOSSIP_OPTION_ARMORER:
-                        {
-                            // Manage questgiver, trainer, banker, auctioneer, innkeeper & vendor actions
-                            if (!m_tasks.empty())
-                                for (std::list<taskPair>::iterator ait = m_tasks.begin(); ait != m_tasks.end(); ait = m_tasks.erase(ait))
-                                {
-                                    switch (ait->first)
-                                    {
-                                        // add new auction item
-                                        case ADD_AUCTION:
-                                        {
-                                            // TellMaster("Creating auction");
-                                            AddAuction(ait->second, currCreature);
-                                            ListAuctions();
-                                            break;
-                                        }
-                                        // cancel active auction
-                                        case REMOVE_AUCTION:
-                                        {
-                                            // TellMaster("Cancelling auction");
-                                            if (!RemoveAuction(ait->second))
-                                                DEBUG_LOG("RemoveAuction: Couldn't remove auction (%u)", ait->second);
-                                            ListAuctions();
-                                            break;
-                                        }
-                                        // list active auctions
-                                        case LIST_AUCTION:
-                                        {
-                                            // TellMaster("Listing auction");
-                                            ListAuctions();
-                                            break;
-                                        }
-                                        // withdraw items
-                                        case BANK_WITHDRAW:
-                                        {
-                                            // TellMaster("Withdraw items");
-                                            if (!Withdraw(ait->second))
-                                                DEBUG_LOG("Withdraw: Couldn't withdraw (%u)", ait->second);
-                                            BankBalance();
-                                            break;
-                                        }
-                                        // deposit items
-                                        case BANK_DEPOSIT:
-                                        {
-                                            // TellMaster("Deposit items");
-                                            if (!Deposit(ait->second))
-                                                DEBUG_LOG("Deposit: Couldn't deposit (%u)", ait->second);
-                                            BankBalance();
-                                            break;
-                                        }
-                                        // bank balance
-                                        case BANK_BALANCE:
-                                        {
-                                            // TellMaster("Bank Balance");
-                                            BankBalance();
-                                            break;
-                                        }
-                                        // reset talents
-                                        case RESET_TALENTS:
-                                        {
-                                            // TellMaster("Reset all talents");
-                                            if (Talent(currCreature))
-                                                InspectUpdate();
-                                            break;
-                                        }
-                                        // take new quests
-                                        case TAKE_QUEST:
-                                        {
-                                            // TellMaster("Accepting quest");
-                                            if (!AddQuest(ait->second, wo))
-                                                DEBUG_LOG("AddQuest: Couldn't add quest (%u)", ait->second);
-                                            break;
-                                        }
-                                        // list npc quests
-                                        case LIST_QUEST:
-                                        {
-                                            // TellMaster("Show available npc quests");
-                                            ListQuests(wo);
-                                            break;
-                                        }
-                                        // end quests
-                                        case END_QUEST:
-                                        {
-                                            // TellMaster("Turn in available quests");
-                                            TurnInQuests(wo);
-                                            break;
-                                        }
-                                        // sell items
-                                        case SELL_ITEMS:
-                                        {
-                                            // TellMaster("Selling items");
-                                            Sell(ait->second);
-                                            break;
-                                        }
-                                        // buy items
-                                        case BUY_ITEMS:
-                                        {
-                                            // TellMaster("Buying items");
-                                            Buy(currCreature, ait->second);
-                                            break;
-                                        }
-                                        // repair items
-                                        case REPAIR_ITEMS:
-                                        {
-                                            TellMaster("Repairing items");
-                                            Repair(ait->second, currCreature);
-                                            break;
-                                        }
-                                        default:
-                                            break;
-                                    }
-                                }
-                            break;
-                        }
-                        default:
-                            DEBUG_LOG("Unknown - GOSSIP_OPTION (%u)", it->second.option_id);
-                            break;
-                    }
-                    AutoUpgradeEquipment();
-                    m_bot->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
-                }
-            }
-            m_bot->GetMotionMaster()->Clear(false);
-            m_bot->GetMotionMaster()->MoveIdle();
-        }
-    }
-}
-
-/**
- * IsElite()
- * Playerbot wrapper to know if a target is elite or not. This is used by the AI to switch from one action to another
- * return bool Returns true if bot's target is a creature with elite rank (elite rare, elite, worldboss)
- *
- * params:pTarget Unit* the target to check if it is elite
- * params:isWorldBoss bool if true, the function will return true only if the target is a worldboss. This allow to enable specific code if the target is a worldboss
- * return false if the target is not elite/rare elite/worldboss or if isWorldBoss was provided as true and that the target is not a worldboss
- *
- */
-bool PlayerbotAI::IsElite(Unit* pTarget, bool isWorldBoss) const
-{
-    if (!pTarget)
-        return false;
-
-    if (Creature* pCreature = (Creature*) pTarget)
-    {
-        if (isWorldBoss)
-            return pCreature->IsWorldBoss();
-        else
-            return (pCreature->IsElite() || pCreature->IsWorldBoss());
-    }
-
-    return false;
-}
-
-// Check if bot target has one of the following auras: Sap, Polymorph, Shackle Undead, Banish, Seduction, Freezing Trap, Hibernate
-// This is used by the AI to prevent bots from attacking crowd control targets
-
-static const uint32 uAurasIds[21] =
-{
-    118, 12824, 12825, 12826,   // polymorph
-    28272, 28271,               // polymorph pig, turtle
-    9484, 9485, 10955,          // shackle
-    6358,                       // seduction
-    710, 18647,                 // banish
-    6770, 2070, 11297,          // sap
-    3355, 14308, 14309,         // freezing trap (effect auras IDs, not spell IDs)
-    2637, 18657, 18658          // hibernate
-};
-
-bool PlayerbotAI::IsNeutralized(Unit* pTarget)
-{
-    if (!pTarget)
-        return false;
-
-    for (uint8 i = 0; i < countof(uAurasIds); ++i)
-    {
-        if (pTarget->HasAura(uAurasIds[i], EFFECT_INDEX_0))
-            return true;
-    }
-
-    return false;
-}
-
-// Utility function to make the bots face their target
-// Useful to ensure bots can cast spells/abilities
-// without getting facing target errors
-void PlayerbotAI::FaceTarget(Unit* pTarget)
-{
-    if (!pTarget)
-        return;
-
-    // Only update orientation if not already facing target
-    if (!m_bot->HasInArc(pTarget))
-        m_bot->SetFacingTo(m_bot->GetAngle(pTarget));
-
-    return;
-}
-
-/**
- * IsImmuneToSchool()
- * Playerbot wrapper to know if a target is immune or not to a specific damage school. This is used by the AI to prevent using an ability the target is immuned to
- * return bool Returns true if bot's target is a creature with immunity to specified damage school
- *
- * params:target Unit* the target to check if it is immune
- * params:schoolMask the school mask to be checked against the creature template or current spell immunity
- * return false if the target is not immune, also return false by default
- *
- */
-bool PlayerbotAI::IsImmuneToSchool(Unit* target, SpellSchoolMask schoolMask)
-{
-    if (!target)
-        return false;
-
-    if (Creature* creature = (Creature*) target)
-            return creature->IsImmuneToDamage(schoolMask);
-
-    return false;
-}
-
-bool PlayerbotAI::CanStore()
-{
-    uint32 totalused = 0;
-    // list out items in main backpack
-    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
-    {
-        const Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
-        if (pItem)
-            totalused++;
-    }
-    uint32 totalfree = 16 - totalused;
-    // list out items in other removable backpacks
-    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
-    {
-        const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
-        if (pBag)
-        {
-            ItemPrototype const* pBagProto = pBag->GetProto();
-            if (pBagProto->Class == ITEM_CLASS_CONTAINER && pBagProto->SubClass == ITEM_SUBCLASS_CONTAINER)
-                totalfree =  totalfree + pBag->GetFreeSlots();
-        }
-    }
-    return totalfree;
-}
-
-// use item on self
-void PlayerbotAI::UseItem(Item* item)
-{
-    UseItem(item, TARGET_FLAG_SELF, ObjectGuid());
-}
-
-// use item on equipped item
-void PlayerbotAI::UseItem(Item* item, uint8 targetInventorySlot)
-{
-    if (targetInventorySlot >= EQUIPMENT_SLOT_END)
-        return;
-
-    Item* const targetItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, targetInventorySlot);
-    if (!targetItem)
-        return;
-
-    UseItem(item, TARGET_FLAG_ITEM, targetItem->GetObjectGuid());
-}
-
-// use item on unit
-void PlayerbotAI::UseItem(Item* item, Unit* target)
-{
-    if (!target)
-        return;
-
-    UseItem(item, TARGET_FLAG_UNIT, target->GetObjectGuid());
-}
-
-// generic item use method
-void PlayerbotAI::UseItem(Item* item, uint32 targetFlag, ObjectGuid targetGUID)
-{
-    if (!item)
-        return;
-
-    uint8 bagIndex = item->GetBagSlot();
-    uint8 slot = item->GetSlot();
-    uint8 cast_count = 0;
-    ObjectGuid item_guid = item->GetObjectGuid();
-
-    if (uint32 questid = item->GetProto()->StartQuest)
-    {
-        std::ostringstream report;
-
-        Quest const* qInfo = sObjectMgr.GetQuestTemplate(questid);
-        if (qInfo)
-        {
-            m_bot->GetMotionMaster()->Clear(true);
-            std::unique_ptr<WorldPacket> packet(new WorldPacket(CMSG_QUESTGIVER_ACCEPT_QUEST, 8 + 4 + 4));
-            *packet << item_guid;
-            *packet << questid;
-            *packet << uint32(0);
-            m_bot->GetSession()->QueuePacket(std::move(packet)); // queue the packet to get around race condition
-            report << "|cffffff00Quest taken |r" << qInfo->GetTitle();
-            TellMaster(report.str());
-        }
-        return;
-    }
-
-    uint32 spellId = 0;
-    uint8 spell_index = 0;
-    for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
-    {
-        if (item->GetProto()->Spells[i].SpellId > 0)
-        {
-            spellId = item->GetProto()->Spells[i].SpellId;
-            spell_index = i;
-            break;
-        }
-    }
-
-    if (item->GetProto()->Flags & ITEM_FLAG_HAS_LOOT && spellId == 0)
-    {
-        // Open quest item in inventory, containing related items (e.g Gnarlpine necklace, containing Tallonkai's Jewel)
-        std::unique_ptr<WorldPacket> packet(new WorldPacket(CMSG_OPEN_ITEM, 2));
-        *packet << item->GetBagSlot();
-        *packet << item->GetSlot();
-        m_bot->GetSession()->QueuePacket(std::move(packet)); // queue the packet to get around race condition
-        return;
-    }
-
-    SpellEntry const* spellInfo = sSpellTemplate.LookupEntry<SpellEntry>(spellId);
-    if (!spellInfo)
-    {
-        TellMaster("Can't find spell entry for spell %u on item %u", spellId, item->GetEntry());
-        return;
-    }
-
-    SpellCastTimesEntry const* castingTimeEntry = sSpellCastTimesStore.LookupEntry(spellInfo->CastingTimeIndex);
-    if (!castingTimeEntry)
-    {
-        TellMaster("Can't find casting time entry for spell %u with index %u", spellId, spellInfo->CastingTimeIndex);
-        return;
-    }
-    // stop movement to prevent cancel spell casting
-    else if (castingTimeEntry && castingTimeEntry->CastTime)
-    {
-        DEBUG_LOG("[PlayerbotAI]: UseItem - Bot movement reset for casting %s (%u)", spellInfo->SpellName[0], spellId);
-        MovementClear();
-    }
-
-    if (!m_bot->IsSpellReady(*spellInfo))
-        return;
-    // spell not on cooldown: mark it as next spell to cast whenever possible for bot
-    m_CurrentlyCastingSpellId = spellId;
-
-    std::unique_ptr<WorldPacket> packet(new WorldPacket(CMSG_USE_ITEM, 20));
-    *packet << bagIndex;
-    *packet << slot;
-    *packet << spell_index;
-    *packet << cast_count;
-    *packet << item_guid;
-    *packet << targetFlag;
-
-    if (targetFlag & (TARGET_FLAG_UNIT | TARGET_FLAG_ITEM | TARGET_FLAG_OBJECT))
-        *packet << targetGUID.WriteAsPacked();
-
-    m_bot->GetSession()->QueuePacket(std::move(packet));
-}
-
-static const uint32 uPriorizedHealingItemIds[19] =
-{
-    HEALTHSTONE_DISPLAYID, FEL_REGENERATION_POTION, SUPER_HEALING_POTION, CRYSTAL_HEALING_POTION, MAJOR_DREAMLESS_SLEEP_POTION, VOLATILE_HEALING_POTION,
-    MAJOR_HEALING_POTION, WHIPPER_ROOT_TUBER, NIGHT_DRAGON_BREATH, LIMITED_INVULNERABILITY_POTION, GREATER_DREAMLESS_SLEEP_POTION,
-    SUPERIOR_HEALING_POTION, CRYSTAL_RESTORE, DREAMLESS_SLEEP_POTION, GREATER_HEALING_POTION, HEALING_POTION, LESSER_HEALING_POTION, DISCOLORED_HEALING_POTION, MINOR_HEALING_POTION,
-};
-
-/**
- * TryEmergency()
- * Playerbot function to select an item that the bot will use to heal itself on low health without waiting for a heal from a healer
- *
- * params:pAttacker Unit* the creature that is attacking the bot
- * return nothing
- */
-void PlayerbotAI::TryEmergency(Unit* pAttacker)
-{
-    // Do not use consumable if bot can heal self
-    if (IsHealer() && GetManaPercent() > 20)
-        return;
-
-    // If bot does not have aggro: use bandage instead of potion/stone/crystal
-    if (!pAttacker && !m_bot->HasAura(11196)) // Recently bandaged
-    {
-        Item* bandage = FindBandage();
-        if (bandage)
-        {
-            SetIgnoreUpdateTime(8);
-            UseItem(bandage);
-            return;
-        }
-    }
-
-    // Else loop over the list of health consumable to pick one
-    Item* healthItem;
-    for (uint8 i = 0; i < countof(uPriorizedHealingItemIds); ++i)
-    {
-        healthItem = FindConsumable(uPriorizedHealingItemIds[i]);
-        if (healthItem)
-        {
-            UseItem(healthItem);
-            return;
-        }
-    }
-
-    return;
-}
-
-// submits packet to use an item
-void PlayerbotAI::EquipItem(Item* src_Item)
-{
-    uint8 src_bagIndex = src_Item->GetBagSlot();
-    uint8 src_slot = src_Item->GetSlot();
-
-    DEBUG_LOG("PlayerbotAI::EquipItem: %s in srcbag = %u, srcslot = %u", src_Item->GetProto()->Name1, src_bagIndex, src_slot);
-
-    uint16 dest;
-    InventoryResult msg = m_bot->CanEquipItem(NULL_SLOT, dest, src_Item, !src_Item->IsBag());
-    if (msg != EQUIP_ERR_OK)
-    {
-        m_bot->SendEquipError(msg, src_Item, nullptr);
-        return;
-    }
-
-    uint16 src = src_Item->GetPos();
-    if (dest == src)                                        // prevent equip in same slot, only at cheat
-        return;
-
-    Item* dest_Item = m_bot->GetItemByPos(dest);
-    if (!dest_Item)                                          // empty slot, simple case
-    {
-        m_bot->RemoveItem(src_bagIndex, src_slot, true);
-        m_bot->EquipItem(dest, src_Item, true);
-        m_bot->AutoUnequipOffhandIfNeed();
-    }
-    else                                                    // have currently equipped item, not simple case
-    {
-        uint8 dest_bagIndex = dest_Item->GetBagSlot();
-        uint8 dest_slot = dest_Item->GetSlot();
-
-        msg = m_bot->CanUnequipItem(dest, false);
-        if (msg != EQUIP_ERR_OK)
-        {
-            m_bot->SendEquipError(msg, dest_Item, nullptr);
-            return;
-        }
-
-        // check dest->src move possibility
-        ItemPosCountVec sSrc;
-        if (m_bot->IsInventoryPos(src))
-        {
-            msg = m_bot->CanStoreItem(src_bagIndex, src_slot, sSrc, dest_Item, true);
-            if (msg != EQUIP_ERR_OK)
-                msg = m_bot->CanStoreItem(src_bagIndex, NULL_SLOT, sSrc, dest_Item, true);
-            if (msg != EQUIP_ERR_OK)
-                msg = m_bot->CanStoreItem(NULL_BAG, NULL_SLOT, sSrc, dest_Item, true);
-        }
-
-        if (msg != EQUIP_ERR_OK)
-        {
-            m_bot->SendEquipError(msg, dest_Item, src_Item);
-            return;
-        }
-
-        // now do moves, remove...
-        m_bot->RemoveItem(dest_bagIndex, dest_slot, false);
-        m_bot->RemoveItem(src_bagIndex, src_slot, false);
-
-        // add to dest
-        m_bot->EquipItem(dest, src_Item, true);
-
-        // add to src
-        if (m_bot->IsInventoryPos(src))
-            m_bot->StoreItem(sSrc, dest_Item, true);
-
-        m_bot->AutoUnequipOffhandIfNeed();
-    }
-}
-
-// submits packet to trade an item (trade window must already be open)
-// default slot is -1 which means trade slots 0 to 5. if slot is set
-// to TRADE_SLOT_NONTRADED (which is slot 6) item will be shown in the
-// 'Will not be traded' slot.
-bool PlayerbotAI::TradeItem(const Item& item, int8 slot)
-{
-    // DEBUG_LOG ("[PlayerbotAI]: TradeItem - slot=%d, hasTrader=%d, itemInTrade=%d, itemTradeable=%d",
-    //    slot,
-    //    (m_bot->GetTrader() ? 1 : 0),
-    //    (item.IsInTrade() ? 1 : 0),
-    //    (item.CanBeTraded() ? 1 : 0)
-    //    );
-
-    if (!m_bot->GetTrader() || item.IsInTrade() || (!item.CanBeTraded() && slot != TRADE_SLOT_NONTRADED))
-        return false;
-
-    int8 tradeSlot = -1;
-
-    TradeData* pTrade = m_bot->GetTradeData();
-    if ((slot >= 0 && slot < TRADE_SLOT_COUNT) && pTrade->GetItem(TradeSlots(slot)) == nullptr)
-        tradeSlot = slot;
-    else
-        for (uint8 i = 0; i < TRADE_SLOT_TRADED_COUNT && tradeSlot == -1; i++)
-        {
-            if (pTrade->GetItem(TradeSlots(i)) == nullptr)
-            {
-                tradeSlot = i;
-                // reserve trade slot to allow multiple items to be traded
-                pTrade->SetItem(TradeSlots(i), const_cast<Item*>(&item));
-            }
-        }
-
-    if (tradeSlot == -1) return false;
-
-    std::unique_ptr<WorldPacket> packet(new WorldPacket(CMSG_SET_TRADE_ITEM, 3));
-    *packet << (uint8) tradeSlot << (uint8) item.GetBagSlot()
-            << (uint8) item.GetSlot();
-    m_bot->GetSession()->QueuePacket(std::move(packet));
-    return true;
-}
-
-// submits packet to trade copper (trade window must be open)
-bool PlayerbotAI::TradeCopper(uint32 copper)
-{
-    if (copper > 0)
-    {
-        std::unique_ptr<WorldPacket> packet(new WorldPacket(CMSG_SET_TRADE_GOLD, 4));
-        *packet << copper;
-        m_bot->GetSession()->QueuePacket(std::move(packet));
-        return true;
-    }
-    return false;
-}
-
-bool PlayerbotAI::DoTeleport(WorldObject& /*obj*/)
-{
-    SetIgnoreUpdateTime(6);
-    PlayerbotChatHandler ch(GetMaster());
-    if (!ch.teleport(*m_bot))
-    {
-        m_ignoreAIUpdatesUntilTime = time(0) + 6;
-        PlayerbotChatHandler ch(GetMaster());
-        if (!ch.teleport(*m_bot))
-        {
-            ch.sysmessage(".. could not be teleported ..");
-            // DEBUG_LOG ("[PlayerbotAI]: DoTeleport - %s failed to teleport", m_bot->GetName() );
-            return false;
-        }
-    }
-    return true;
-}
-
-void PlayerbotAI::HandleTeleportAck()
-{
-    SetIgnoreUpdateTime(6);
-    m_bot->GetMotionMaster()->Clear(true);
-    if (m_bot->IsBeingTeleportedNear())
-    {
-        WorldPacket p = WorldPacket(MSG_MOVE_TELEPORT_ACK, 8 + 4 + 4);
-        p << m_bot->GetObjectGuid();
-        p << (uint32) 0; // supposed to be flags? not used currently
-        p << (uint32) CurrentTime(); // time - not currently used
-        m_bot->GetSession()->HandleMoveTeleportAckOpcode(p);
-    }
-    else if (m_bot->IsBeingTeleportedFar())
-        m_bot->GetSession()->HandleMoveWorldportAckOpcode();
-}
-
-// Localization support
-void PlayerbotAI::ItemLocalization(std::string& itemName, const uint32 itemID) const
-{
-    uint32 loc = GetMaster()->GetSession()->GetSessionDbLocaleIndex();
-    std::wstring wnamepart;
-
-    ItemLocale const* pItemInfo = sObjectMgr.GetItemLocale(itemID);
-    if (pItemInfo)
-        if (pItemInfo->Name.size() > loc && !pItemInfo->Name[loc].empty())
-        {
-            const std::string name = pItemInfo->Name[loc];
-            if (Utf8FitTo(name, wnamepart))
-                itemName = name.c_str();
-        }
-}
-
-void PlayerbotAI::QuestLocalization(std::string& questTitle, const uint32 questID) const
-{
-    uint32 loc = GetMaster()->GetSession()->GetSessionDbLocaleIndex();
-    std::wstring wnamepart;
-
-    QuestLocale const* pQuestInfo = sObjectMgr.GetQuestLocale(questID);
-    if (pQuestInfo)
-        if (pQuestInfo->Title.size() > loc && !pQuestInfo->Title[loc].empty())
-        {
-            const std::string title = pQuestInfo->Title[loc];
-            if (Utf8FitTo(title, wnamepart))
-                questTitle = title.c_str();
-        }
-}
-
-void PlayerbotAI::CreatureLocalization(std::string& creatureName, const uint32 entry) const
-{
-    uint32 loc = GetMaster()->GetSession()->GetSessionDbLocaleIndex();
-    std::wstring wnamepart;
-
-    CreatureLocale const* pCreatureInfo = sObjectMgr.GetCreatureLocale(entry);
-    if (pCreatureInfo)
-        if (pCreatureInfo->Name.size() > loc && !pCreatureInfo->Name[loc].empty())
-        {
-            const std::string title = pCreatureInfo->Name[loc];
-            if (Utf8FitTo(title, wnamepart))
-                creatureName = title.c_str();
-        }
-}
-
-void PlayerbotAI::GameObjectLocalization(std::string& gameobjectName, const uint32 entry) const
-{
-    uint32 loc = GetMaster()->GetSession()->GetSessionDbLocaleIndex();
-    std::wstring wnamepart;
-
-    GameObjectLocale const* pGameObjectInfo = sObjectMgr.GetGameObjectLocale(entry);
-    if (pGameObjectInfo)
-        if (pGameObjectInfo->Name.size() > loc && !pGameObjectInfo->Name[loc].empty())
-        {
-            const std::string title = pGameObjectInfo->Name[loc];
-            if (Utf8FitTo(title, wnamepart))
-                gameobjectName = title.c_str();
-        }
-}
-
-// Helper function for automatically selling poor quality items to the vendor
-void PlayerbotAI::_doSellItem(Item* const item, std::ostringstream& report, std::ostringstream& canSell, uint32& TotalCost, uint32& TotalSold)
-{
-    if (!item)
-        return;
-
-    uint8 autosell = 0;
-
-    std::ostringstream mout;
-    if (item->CanBeTraded() && item->GetProto()->Quality == ITEM_QUALITY_POOR) // trash sells automatically.
-        autosell = 1;
-
-    ItemPrototype const* pProto = item->GetProto();
-
-    if (SellWhite == 1) // set this with the command 'sell all'
-    {
-        // here we'll do some checks for other items that are safe to automatically sell such as
-        // white items that are a number of levels lower than anything we could possibly use.
-        // We'll check to make sure its not a tradeskill tool, quest item etc, things that we don't want to lose.
-        if (pProto->SellPrice > 0 && (pProto->Quality == ITEM_QUALITY_NORMAL || pProto->Quality == ITEM_QUALITY_UNCOMMON) && pProto->SubClass != ITEM_SUBCLASS_QUEST)
-        {
-            if (pProto->RequiredLevel < (m_bot->getLevel() - m_mgr->gConfigSellLevelDiff) && pProto->SubClass != ITEM_SUBCLASS_WEAPON_MISC && pProto->FoodType == 0)
-            {
-                if (pProto->Class == ITEM_CLASS_WEAPON)
-                    autosell = 1;
-                if (pProto->Class == ITEM_CLASS_ARMOR)
-                    autosell = 1;
-            }
-            if (pProto->SubClass == ITEM_SUBCLASS_FOOD && (pProto->RequiredLevel < (m_bot->getLevel() - m_mgr->gConfigSellLevelDiff)))
-            {
-                autosell = 1;
-            }
-        }
-    }
-
-    if (autosell == 1) // set this switch above and this item gets sold automatically. Only set this for automatic sales e.g junk etc.
-    {
-        uint32 cost = pProto->SellPrice * item->GetCount();
-
-        // handle spell charge if any
-        for (auto i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
-        {
-            auto const& spell = pProto->Spells[i];
-
-            // if spell charges for this item are negative, it means that the item should be destroyed once the charges are consumed.
-            // it also means that the value of this item is relative to how many charges are remaining.
-            if (spell.SpellId != 0 && spell.SpellCharges < 0)
-            {
-                auto const multiplier = static_cast<float>(item->GetSpellCharges(i)) / spell.SpellCharges;
-                cost *= multiplier;
-                break;
-            }
-        }
-
-        m_bot->MoveItemFromInventory(item->GetBagSlot(), item->GetSlot(), true);
-        m_bot->AddItemToBuyBackSlot(item, cost);
-        m_bot->ModifyMoney(cost);
-
-        ++TotalSold;
-        TotalCost += cost;
-
-        report << "Sold ";
-        MakeItemLink(item, report, true);
-        report << " for " << Cash(cost);
-    }
-    else if (pProto->SellPrice > 0)
-        MakeItemLink(item, canSell, true);
-}
-
-bool PlayerbotAI::Withdraw(const uint32 itemid)
-{
-    Item* pItem = FindItemInBank(itemid);
-    if (pItem)
-    {
-        std::ostringstream report;
-
-        ItemPosCountVec dest;
-        InventoryResult msg = m_bot->CanStoreItem(NULL_BAG, NULL_SLOT, dest, pItem, false);
-        if (msg != EQUIP_ERR_OK)
-        {
-            m_bot->SendEquipError(msg, pItem, nullptr);
-            return false;
-        }
-
-        m_bot->RemoveItem(pItem->GetBagSlot(), pItem->GetSlot(), true);
-        m_bot->StoreItem(dest, pItem, true);
-
-        report << "Withdrawn ";
-        MakeItemLink(pItem, report, true);
-
-        TellMaster(report.str());
-    }
-    return true;
-}
-
-bool PlayerbotAI::Deposit(const uint32 itemid)
-{
-    Item* pItem = FindItem(itemid);
-    if (pItem)
-    {
-        std::ostringstream report;
-
-        ItemPosCountVec dest;
-        InventoryResult msg = m_bot->CanBankItem(NULL_BAG, NULL_SLOT, dest, pItem, false);
-        if (msg != EQUIP_ERR_OK)
-        {
-            m_bot->SendEquipError(msg, pItem, nullptr);
-            return false;
-        }
-
-        m_bot->RemoveItem(pItem->GetBagSlot(), pItem->GetSlot(), true);
-        m_bot->BankItem(dest, pItem, true);
-
-        report << "Deposited ";
-        MakeItemLink(pItem, report, true);
-
-        TellMaster(report.str());
-    }
-    return true;
-}
-
-void PlayerbotAI::BankBalance()
-{
-    std::ostringstream report;
-
-    report << "In my bank\n ";
-    report << "My item slots: ";
-
-    for (uint8 slot = BANK_SLOT_ITEM_START; slot < BANK_SLOT_ITEM_END; ++slot)
-    {
-        Item* const item = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
-        if (item)
-            MakeItemLink(item, report, true);
-    }
-    TellMaster(report.str());
-
-    // and each of my bank bags
-    for (uint8 bag = BANK_SLOT_BAG_START; bag < BANK_SLOT_BAG_END; ++bag)
-    {
-        std::ostringstream goods;
-        const Bag* const pBag = static_cast<Bag*>(m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag));
-        if (pBag)
-        {
-            goods << "\nMy ";
-            const ItemPrototype* const pBagProto = pBag->GetProto();
-            std::string bagName = pBagProto->Name1;
-            ItemLocalization(bagName, pBagProto->ItemId);
-            goods << bagName << " slot: ";
-
-            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
-            {
-                Item* const item = m_bot->GetItemByPos(bag, slot);
-                if (item)
-                    MakeItemLink(item, goods, true);
-            }
-            TellMaster(goods.str());
-        }
-    }
-}
-
-bool PlayerbotAI::Talent(Creature* trainer)
-{
-    if (!(m_bot->resetTalents()))
-    {
-        std::unique_ptr<WorldPacket> packet(new WorldPacket(MSG_TALENT_WIPE_CONFIRM, 8 + 4));    //you do not have any talent
-        *packet << uint64(0);
-        *packet << uint32(0);
-        m_bot->GetSession()->QueuePacket(std::move(packet));
-        return false;
-    }
-
-    trainer->CastSpell(m_bot, 14867, TRIGGERED_OLD_TRIGGERED);                  //spell: "Untalent Visual Effect"
-    return true;
-}
-
-void PlayerbotAI::Repair(const uint32 itemid, Creature* rCreature)
-{
-    uint32 cost = 0;
-    uint8 UseGuild = (m_bot->GetGuildId() != 0) ? uint8(1) : uint8(0);
-    Item* rItem = FindItem(itemid, true); // if item equipped or in bags
-    if (rItem)
-        cost = EstRepair(rItem->GetPos());
-    else
-        cost = EstRepairAll();
-
-    Guild* pGuild = sGuildMgr.GetGuildById(m_bot->GetGuildId());
-
-    if (pGuild)
-    {
-        // Check whether bot can use the guildbank first
-        if (!pGuild->HasRankRight(m_bot->GetRank(), GR_RIGHT_WITHDRAW_REPAIR))
-        {
-            DEBUG_LOG("You do not have rights to withdraw for repairs");
-            UseGuild = 0;
-        }
-
-        if (pGuild->GetGuildBankMoney() < cost)
-        {
-            DEBUG_LOG("There is not enough money in the guild bank");
-            UseGuild = 0;
-        }
-    }
-
-    // If guildbank unavailable, check pockets
-    if (UseGuild == 0)
-        if (m_bot->GetMoney() < cost)
-        {
-            TellMaster("I do not have enough money to repair");
-            return;
-        }
-
-    ObjectGuid itemGuid = (rItem) ? rItem->GetObjectGuid() : ObjectGuid();
-
-    std::unique_ptr<WorldPacket> packet(new WorldPacket(CMSG_REPAIR_ITEM, 8 + 8 + 1));
-    *packet << rCreature->GetObjectGuid();  // repair npc guid
-    *packet << itemGuid; // if item specified then repair this, else repair all
-    *packet << UseGuild;  // guildbank yes=1 no=0
-    m_bot->GetSession()->QueuePacket(std::move(packet));  // queue the packet to get around race condition
-}
-
-bool PlayerbotAI::RemoveAuction(const uint32 auctionid)
-{
-    QueryResult* result = CharacterDatabase.PQuery(
-                              "SELECT houseid,itemguid,item_template,itemowner,buyoutprice,time,buyguid,lastbid,startbid,deposit FROM auction WHERE id = '%u'", auctionid);
-
-    AuctionEntry* auction;
-
-    if (result)
-    {
-        Field* fields = result->Fetch();
-
-        auction = new AuctionEntry;
-        auction->Id = auctionid;
-        uint32 houseid  = fields[0].GetUInt32();
-        auction->itemGuidLow = fields[1].GetUInt32();
-        auction->itemTemplate = fields[2].GetUInt32();
-        auction->owner = fields[3].GetUInt32();
-        auction->buyout = fields[4].GetUInt32();
-        auction->expireTime = fields[5].GetUInt32();
-        auction->bidder = fields[6].GetUInt32();
-        auction->bid = fields[7].GetUInt32();
-        auction->startbid = fields[8].GetUInt32();
-        auction->deposit = fields[9].GetUInt32();
-        auction->auctionHouseEntry = nullptr;                  // init later
-
-        // check if sold item exists for guid
-        // and item_template in fact (GetAItem will fail if problematic in result check in AuctionHouseMgr::LoadAuctionItems)
-        Item* pItem = sAuctionMgr.GetAItem(auction->itemGuidLow);
-        if (!pItem)
-        {
-            auction->DeleteFromDB();
-            sLog.outError("Auction %u has not a existing item : %u, deleted", auction->Id, auction->itemGuidLow);
-            delete auction;
-            delete result;
-            return false;
-        }
-
-        auction->auctionHouseEntry = sAuctionHouseStore.LookupEntry(houseid);
-
-        // Attempt send item back to owner
-        std::ostringstream msgAuctionCanceledOwner;
-        msgAuctionCanceledOwner << auction->itemTemplate << ":0:" << AUCTION_CANCELED << ":0:0";
-
-        // item will deleted or added to received mail list
-        MailDraft(msgAuctionCanceledOwner.str(), "")    // TODO: fix body
-        .AddItem(pItem)
-        .SendMailTo(MailReceiver(ObjectGuid(HIGHGUID_PLAYER, auction->owner)), auction, MAIL_CHECK_MASK_COPIED);
-
-        if (sAuctionMgr.RemoveAItem(auction->itemGuidLow))
-            m_bot->GetSession()->SendAuctionCommandResult(auction, AUCTION_REMOVED, AUCTION_OK);
-
-        auction->DeleteFromDB();
-
-        delete auction;
-        delete result;
-    }
-    return true;
-}
-
-// Subject - 9360:0:2
-// Subject - item:0:MailAuctionAnswer
-// Body - 0:2650:2650:120:132
-// Body - 0:High Bid:Buyout:Deposit:AuctionHouse Cut
-
-std::string PlayerbotAI::AuctionResult(std::string subject, std::string body)
-{
-    std::ostringstream out;
-    std::string winner;
-    int pos;
-
-    subject.append(":");
-    if (body.size() > 0)
-    {
-        pos = body.find_first_not_of(" ");
-        subject.append(body, pos, body.size() - pos);
-        subject.append(":");
-    }
-
-    // DEBUG_LOG("Auctions string (%s)",subject.c_str());
-    pos = 0;
-    uint32 a_info[15];
-    int i = 0;
-    while (true)
-    {
-        int endpos = subject.find(':', pos);
-        if (endpos == -1)
-            break;
-
-        std::string idc = subject.substr(pos, endpos - pos);
-        a_info[i] = atol(idc.c_str());
-        // DEBUG_LOG("a_info[%d] = (%u)",i,a_info[i]);
-        pos = endpos + 1;
-        ++i;
-    }
-
-    if (i == 0)
-    {
-        out << "This mail is empty";
-        return out.str();
-    }
-
-    if (a_info[4] != a_info[5])
-        winner =  "High Bidder";
-    else
-        winner =  "Buyout";
-
-    ItemPrototype const* pProto = ObjectMgr::GetItemPrototype(a_info[0]);
-    if (!pProto)
-        return out.str();
-
-    switch (a_info[2])
-    {
-        case AUCTION_OUTBIDDED:           //= 0,
-            out << "Subject: Outbid on: " << pProto->Name1;
-            break;
-        case AUCTION_WON:                 //= 1,
-            out << "Subject: Auction won: " << pProto->Name1 << "\n";
-            out << "Item Purchased: " << pProto->Name1 << "\n";
-            break;
-        case AUCTION_SUCCESSFUL:          //= 2,
-        {
-            out << "Subject: Auction successful: " << pProto->Name1 << "\n";
-            out << "Item Sold: " << pProto->Name1 << "\n";
-            out << "\n[" << winner << " Sale: " << Cash(a_info[4]) << "]";
-            out << "\n( |cff1eff00Deposit:|cffccffff " << Cash(a_info[6]) << " |cffff0000- Tax:|cffccffff " << Cash(a_info[7]) << " ) |cff1eff00+|cffccffff";
-            break;
-        }
-        case AUCTION_EXPIRED:             //= 3,
-            out << "Subject: Auction expired: " << pProto->Name1;
-            break;
-        case AUCTION_CANCELLED_TO_BIDDER: //= 4,
-            out << "Subject: Auction cancelled to bidder: " << pProto->Name1;
-            break;
-        case AUCTION_CANCELED:            //= 5,
-            out << "Subject: Auction cancelled: " << pProto->Name1;
-            break;
-        case AUCTION_SALE_PENDING:        //= 6
-            out << "Subject: Auction sale pending: " << pProto->Name1;
-            break;
-    }
-    return out.str();
-}
-
-std::string PlayerbotAI::Cash(uint32 copper)
-{
-    using namespace std;
-    std::ostringstream change;
-
-    uint32 gold = uint32(copper / 10000);
-    copper -= (gold * 10000);
-    uint32 silver = uint32(copper / 100);
-    copper -= (silver * 100);
-
-    if (gold > 0)
-        change << gold <<  " |TInterface\\Icons\\INV_Misc_Coin_01:8|t";
-    if (silver > 0)
-        change << std::setfill(' ') << std::setw(2) << silver << " |TInterface\\Icons\\INV_Misc_Coin_03:8|t";
-    change << std::setfill(' ') << std::setw(2) << copper << " |TInterface\\Icons\\INV_Misc_Coin_05:8|t";
-
-    return change.str();
-}
-
-void PlayerbotAI::ListQuests(WorldObject* questgiver)
-{
-    if (!questgiver)
-        return;
-
-    // list all bot quests this NPC has
-    m_bot->PrepareQuestMenu(questgiver->GetObjectGuid());
-    QuestMenu& questMenu = m_bot->PlayerTalkClass->GetQuestMenu();
-    std::ostringstream out;
-    for (uint32 iI = 0; iI < questMenu.MenuItemCount(); ++iI)
-    {
-        QuestMenuItem const& qItem = questMenu.GetItem(iI);
-        uint32 questID = qItem.m_qId;
-        Quest const* pQuest = sObjectMgr.GetQuestTemplate(questID);
-
-        std::string questTitle  = pQuest->GetTitle();
-        QuestLocalization(questTitle, questID);
-
-        if (m_bot->SatisfyQuestStatus(pQuest, false))
-        {
-            if (gQuestFetch != 1)
-            {
-                out << "|cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
-            }
-            else
-            {
-                if (!AddQuest(questID, questgiver))
-                    continue;
-            }
-        }
-    }
-    if (!out.str().empty())
-        TellMaster(out.str());
-}
-
-bool PlayerbotAI::AddQuest(const uint32 entry, WorldObject* questgiver)
-{
-    std::ostringstream out;
-
-    Quest const* qInfo = sObjectMgr.GetQuestTemplate(entry);
-    if (!qInfo)
-    {
-        ChatHandler(GetMaster()).PSendSysMessage(LANG_COMMAND_QUEST_NOTFOUND, entry);
-        return false;
-    }
-
-    if (m_bot->GetQuestStatus(entry) == QUEST_STATUS_COMPLETE)
-    {
-        TellMaster("I already completed that quest.");
-        return false;
-    }
-    else if (!m_bot->CanTakeQuest(qInfo, false))
-    {
-        if (!m_bot->SatisfyQuestStatus(qInfo, false))
-            TellMaster("I already have that quest.");
-        else
-            TellMaster("I can't take that quest.");
-        return false;
-    }
-    else if (!m_bot->SatisfyQuestLog(false))
-    {
-        TellMaster("My quest log is full.");
-        return false;
-    }
-    else if (m_bot->CanAddQuest(qInfo, false))
-    {
-        m_bot->AddQuest(qInfo, questgiver);
-
-        std::string questTitle  = qInfo->GetTitle();
-        QuestLocalization(questTitle, entry);
-
-        out << "|cffffff00Quest taken " << "|cff808080|Hquest:" << entry << ':' << qInfo->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
-
-        if (m_bot->CanCompleteQuest(entry))
-            m_bot->CompleteQuest(entry);
-
-        // build needed items if quest contains any
-        for (int i = 0; i < QUEST_ITEM_OBJECTIVES_COUNT; i++)
-            if (qInfo->ReqItemCount[i] > 0)
-            {
-                SetQuestNeedItems();
-                break;
-            }
-
-        // build needed creatures if quest contains any
-        for (int i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
-            if (qInfo->ReqCreatureOrGOCount[i] > 0)
-            {
-                SetQuestNeedCreatures();
-                break;
-            }
-
-        if (qInfo->GetSrcSpell() > 0)
-            m_bot->CastSpell(m_bot, qInfo->GetSrcSpell(), TRIGGERED_OLD_TRIGGERED);
-
-        TellMaster(out.str());
-        return true;
-    }
-    return false;
-}
-
-void PlayerbotAI::ListAuctions()
-{
-    std::ostringstream report;
-
-    QueryResult* result = CharacterDatabase.PQuery(
-                              "SELECT id,itemguid,item_template,time,buyguid,lastbid FROM auction WHERE itemowner = '%u'", m_bot->GetObjectGuid().GetCounter());
-    if (result)
-    {
-        report << "My active auctions are: \n";
-        do
-        {
-            Field* fields = result->Fetch();
-
-            uint32 Id = fields[0].GetUInt32();
-            uint32 itemGuidLow = fields[1].GetUInt32();
-            uint32 itemTemplate = fields[2].GetUInt32();
-            time_t expireTime = fields[3].GetUInt32();
-            uint32 bidder = fields[4].GetUInt32();
-            uint32 bid = fields[5].GetUInt32();
-
-            time_t remtime = expireTime - CurrentTime();
-
-            tm* aTm = gmtime(&remtime);
-
-            if (expireTime > CurrentTime())
-            {
-                Item* aItem = sAuctionMgr.GetAItem(itemGuidLow);
-                if (aItem)
-                {
-                    // Name
-                    uint32 count = aItem->GetCount();
-                    std::string name = aItem->GetProto()->Name1;
-                    ItemLocalization(name, itemTemplate);
-                    report << "\n|cffffffff|Htitle:" << Id << "|h[" << name;
-                    if (count > 1)
-                        report << "|cff00ff00x" << count << "|cffffffff" << "]|h|r";
-                    else
-                        report << "]|h|r";
-                }
-
-                if (bidder)
-                {
-                    ObjectGuid guid = ObjectGuid(HIGHGUID_PLAYER, bidder);
-                    std::string bidder_name;
-                    if (sObjectMgr.GetPlayerNameByGUID(guid, bidder_name))
-                        report << " " << bidder_name << ": ";
-
-                    report << Cash(bid);
-                }
-                if (aItem)
-                    report << " ends: " << aTm->tm_hour << "|cff0070dd|hH|h|r " << aTm->tm_min << "|cff0070dd|hmin|h|r";
-            }
-        }
-        while (result->NextRow());
-
-        delete result;
-        TellMaster(report.str().c_str());
-    }
-}
-
-void PlayerbotAI::AddAuction(const uint32 itemid, Creature* aCreature)
-{
-    Item* aItem = FindItem(itemid);
-    if (aItem)
-    {
-        std::ostringstream out;
-        srand(CurrentTime());
-        uint32 duration[3] = { 720, 1440, 2880 };  // 720 = 12hrs, 1440 = 24hrs, 2880 = 48hrs
-        uint32 etime = duration[rand() % 3];
-
-        uint32 min = urand(aItem->GetProto()->SellPrice * aItem->GetCount(), aItem->GetProto()->BuyPrice * aItem->GetCount()) * (aItem->GetProto()->Quality + 1);
-        uint32 max = urand(aItem->GetProto()->SellPrice * aItem->GetCount(), aItem->GetProto()->BuyPrice * aItem->GetCount()) * (aItem->GetProto()->Quality + 1);
-
-        out << "Auctioning ";
-        MakeItemLink(aItem, out, true);
-        out << " with " << aCreature->GetCreatureInfo()->Name;
-        TellMaster(out.str().c_str());
-
-        std::unique_ptr<WorldPacket> packet(new WorldPacket(CMSG_AUCTION_SELL_ITEM, 8 + 8 + 4 + 4 + 4));
-        *packet << aCreature->GetObjectGuid();     // auctioneer guid
-        *packet << aItem->GetObjectGuid();         // item guid
-        *packet << uint32((min < max) ? min : max);  // starting bid
-        *packet << uint32((max > min) ? max : min);  // buyout
-        *packet << uint32(etime);  // auction duration
-
-        m_bot->GetSession()->QueuePacket(std::move(packet));  // queue the packet to get around race condition
-    }
-}
-
-void PlayerbotAI::Buy(Creature* vendor, const uint32 itemid)
-{
-    if (!vendor)
-        return;
-
-    // DEBUG_LOG("vendor (%s) itemid (%u)",vendor->GetName(),itemid);
-
-    VendorItemData const* vItems = vendor->GetVendorItems();
-    VendorItemData const* tItems = vendor->GetVendorTemplateItems();
-
-    uint8 customitems = vItems ? vItems->GetItemCount() : 0;
-    uint8 numitems = customitems + (tItems ? tItems->GetItemCount() : 0);
-
-    for (uint8 vendorslot = 0; vendorslot < numitems; ++vendorslot)
-    {
-        VendorItem const* crItem = vendorslot < customitems ? vItems->GetItem(vendorslot) : tItems->GetItem(vendorslot - customitems);
-
-        if (crItem)
-        {
-            if (itemid != crItem->item)
-                continue;
-
-            ItemPrototype const* pProto = ObjectMgr::GetItemPrototype(itemid);
-            if (pProto)
-            {
-                // class wrong item skip only for bindable case
-                if ((pProto->AllowableClass & m_bot->getClassMask()) == 0 && pProto->Bonding == BIND_WHEN_PICKED_UP)
-                    continue;
-
-                if ((pProto->AllowableRace & m_bot->getRaceMask()) == 0)
-                    continue;
-
-                m_bot->BuyItemFromVendor(vendor->GetObjectGuid(), itemid, 1, NULL_BAG, NULL_SLOT);
-                return;
-            }
-        }
-    }
-}
-
-void PlayerbotAI::Sell(const uint32 itemid)
-{
-    Item* pItem = FindItem(itemid);
-    if (pItem)
-    {
-        std::ostringstream report;
-
-        ItemPrototype const* pProto = pItem->GetProto();
-
-        if (!pProto)
-            return;
-
-        uint32 cost = pItem->GetProto()->SellPrice * pItem->GetCount();
-
-        // handle spell charge if any
-        for (auto i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
-        {
-            auto const& spell = pProto->Spells[i];
-
-            // if spell charges for this item are negative, it means that the item should be destroyed once the charges are consumed.
-            // it also means that the value of this item is relative to how many charges are remaining.
-            if (spell.SpellId != 0 && spell.SpellCharges < 0)
-            {
-                auto const multiplier = static_cast<float>(pItem->GetSpellCharges(i)) / spell.SpellCharges;
-                cost *= multiplier;
-                break;
-            }
-        }
-
-        m_bot->MoveItemFromInventory(pItem->GetBagSlot(), pItem->GetSlot(), true);
-        m_bot->AddItemToBuyBackSlot(pItem, cost);
-        m_bot->ModifyMoney(cost);
-
-        report << "Sold ";
-        MakeItemLink(pItem, report, true);
-        report << " for " << Cash(cost);
-
-        TellMaster(report.str());
-    }
-}
-
-void PlayerbotAI::SellGarbage(Player& /*player*/, bool /*bListNonTrash*/, bool bDetailTrashSold, bool bVerbose)
-{
-    uint32 SoldCost = 0;
-    uint32 SoldQuantity = 0;
-    std::ostringstream report, goods;
-    ChatHandler ch(GetMaster());
-
-    // list out items in main backpack
-    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; ++slot)
-    {
-        Item* const item = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
-        if (item)
-            _doSellItem(item, report, goods, SoldCost, SoldQuantity);
-    }
-
-    uint8 notempty = 0;
-    if (goods.str().size() != 0)
-    {
-        notempty = 1;
-        TellMaster("Heres a list of items I can sell:");
-    }
-    // and each of our other packs
-    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag) // check for extra bags
-    {
-        // we want to output the item list to links one bag at a time and clear it, to prevent the list from overloading
-        if (goods.str().size() != 0) // This will be one bag behind in the check. if the previous bag listed anything, llist that now and clear the list
-        {
-            if (notempty == 0)
-            {
-                TellMaster("Heres a list of items I can sell:");
-                notempty = 1; // at least one bag must have had something in it, used at end of this function
-            }
-            else
-            {
-                ch.SendSysMessage(goods.str().c_str()); // previous bags list contents, including main backpack first.
-                goods.str(""); // clear the list for next bag
-            }
-        }
-
-        const Bag* const pBag = static_cast<Bag*>(m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag));
-        if (pBag)
-        {
-            // Very nice, but who cares what bag it's in?
-            //const ItemPrototype* const pBagProto = pBag->GetProto();
-            //std::string bagName = pBagProto->Name1;
-            //ItemLocalization(bagName, pBagProto->ItemId);
-            //goods << "\nIn my " << bagName << ":";
-
-            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
-            {
-                Item* const item = m_bot->GetItemByPos(bag, slot);
-                if (item)
-                    _doSellItem(item, report, goods, SoldCost, SoldQuantity);
-            }
-        }
-    }
-
-    if (goods.str().size() != 0) // This will make sure items in the last bag were output to links
-    {
-        ch.SendSysMessage(goods.str().c_str());
-        goods.str(""); // clear the list
-        notempty = 1; // at least one bag must have had something in it, used at end of this function
-    }
-    if (notempty == 1)
-        TellMaster("All of the above items could be sold"); // links are complete, notify master
-
-    if (!bDetailTrashSold) // no trash got sold
-        report.str(""); // clear ostringstream
-
-    report << "Auto sell is set " << (SellWhite ? "|h|cff1eff00TO|h|r" : "to |h|cffff0000NOT|h|r") << " sell white items. ";
-
-    if (SoldCost > 0)
-    {
-        if (bDetailTrashSold)
-            report << "Sold total " << SoldQuantity << " item(s) for ";
-        else
-            report << "Sold " << SoldQuantity << " trash item(s) for ";
-        report << Cash(SoldCost);
-
-        if (bVerbose)
-            TellMaster(report.str());
-    }
-
-    // For all bags, non-gray sellable items
-    if (bVerbose)
-    {
-        if (SoldQuantity == 0 && notempty == 0)
-            TellMaster("No items to sell, trash or otherwise.");
-    }
-}
-
-std::string PlayerbotAI::DropItem(const uint32 itemid)
-{
-    Item* pItem = FindItem(itemid);
-    if (pItem)
-    {
-        std::ostringstream report;
-
-        // Yea, that's right, get the item info BEFORE you destroy it :)
-        MakeItemText(pItem, report, true);
-
-        m_bot->DestroyItem(pItem->GetBagSlot(), pItem->GetSlot(), true);
-
-        return report.str();
-    }
-
-    return "";
-}
-
-void PlayerbotAI::GetTaxi(ObjectGuid guid, BotTaxiNode& nodes)
-{
-    // DEBUG_LOG("[PlayerbotAI]: GetTaxi - %s node[0] %d node[1] %d", m_bot->GetName(), nodes[0], nodes[1]);
-
-    Creature* unit = m_bot->GetNPCIfCanInteractWith(guid, UNIT_NPC_FLAG_FLIGHTMASTER);
-    if (!unit)
-    {
-        DEBUG_LOG("[PlayerbotAI]: GetTaxi - %s not found or you can't interact with it.", guid.GetString().c_str());
-        return;
-    }
-
-    if (m_bot->m_taxi.IsTaximaskNodeKnown(nodes[0]) ? 0 : 1)
-        return;
-
-    if (m_bot->m_taxi.IsTaximaskNodeKnown(nodes[nodes.size() - 1]) ? 0 : 1)
-        return;
-
-    if (m_bot->GetPlayerbotAI()->GetMovementOrder() != MOVEMENT_STAY)
-    {
-        m_taxiNodes = nodes;
-        m_taxiMaster = guid;
-        SetState(BOTSTATE_FLYING);
-    }
-}
-
-void PlayerbotAI::InspectUpdate()
-{
-    WorldPacket data(CMSG_INSPECT, 8);
-    data << m_bot->GetObjectGuid();
-    GetMaster()->GetSession()->HandleInspectOpcode(data);
-}
-
-// handle commands sent through chat channels
-void PlayerbotAI::HandleCommand(const std::string& text, Player& fromPlayer)
-{
-    // prevent bot task spam
-    m_inventory_full = false;
-    m_tasks.unique();
-    m_findNPC.unique();
-
-    if (m_bDebugCommandChat)
-    {
-        DEBUG_LOG("chat(%s)", text.c_str());
-        TellMaster(text);
-    }
-
-    // ignore any messages from Addons
-    if (text.empty()                                   ||
-            text.find("X-Perl")      != std::wstring::npos ||
-            text.find("HealBot")     != std::wstring::npos ||
-            text.find("HealComm")    != std::wstring::npos ||   // "HealComm    99990094"
-            text.find("LOOT_OPENED") != std::wstring::npos ||
-            text.find("CTRA")        != std::wstring::npos ||
-            text.find("GathX")       == 0)                      // Gatherer
-        return;
-
-    // if message is not from a player in the masters account auto reply and ignore
-    if (!canObeyCommandFrom(fromPlayer))
-    {
-        // only tell the player once instead of endlessly nagging them
-        if (m_ignorePlayersChat.find(fromPlayer.GetObjectGuid()) == m_ignorePlayersChat.end())
-        {
-            std::string msg = "I can't talk to you. Please speak to my master ";
-            msg += GetMaster()->GetName();
-            SendWhisper(msg, fromPlayer);
-            m_bot->HandleEmoteCommand(EMOTE_ONESHOT_NO);
-            m_ignorePlayersChat.insert(fromPlayer.GetObjectGuid());
-        }
-        return;
-    }
-
-    // Passed along to ExtractCommand, if (sub)command is found "input" will only contain the rest of the string (or "")
-    std::string input = text.c_str();
-
-    // if in the middle of a trade, and player asks for an item/money
-    // WARNING: This makes it so you can't use any other commands during a trade!
-    if (m_bot->GetTrader() && m_bot->GetTrader()->GetObjectGuid() == fromPlayer.GetObjectGuid())
-    {
-        uint32 copper = extractMoney(text);
-        if (copper > 0)
-            TradeCopper(copper);
-
-        std::list<uint32> itemIds;
-        extractItemIds(text, itemIds);
-        if (itemIds.size() == 0)
-            SendWhisper("Show me what item you want by shift clicking the item in the chat window.", fromPlayer);
-        else if (!strncmp(text.c_str(), "nt ", 3))
-        {
-            if (itemIds.size() > 1)
-                SendWhisper("There is only one 'Will not be traded' slot. Shift-click just one item, please!", fromPlayer);
-            else
-            {
-                std::list<Item*> itemList;
-                findItemsInEquip(itemIds, itemList);
-                findItemsInInv(itemIds, itemList);
-                if (itemList.size() > 0)
-                    TradeItem((**itemList.begin()), TRADE_SLOT_NONTRADED);
-                else
-                    SendWhisper("I do not have this item equipped or in my bags!", fromPlayer);
-            }
-        }
-        else
-        {
-            std::list<Item*> itemList;
-            findItemsInInv(itemIds, itemList);
-            for (std::list<Item*>::iterator it = itemList.begin(); it != itemList.end(); ++it)
-                TradeItem(**it);
-        }
-    }
-
-    else if (ExtractCommand("help", input))
-        _HandleCommandHelp(input, fromPlayer);
-
-    else if (fromPlayer.GetSession()->GetSecurity() > SEC_PLAYER && ExtractCommand("gm", input))
-        _HandleCommandGM(input, fromPlayer);
-
-    else if (ExtractCommand("reset", input))
-        _HandleCommandReset(input, fromPlayer);
-    else if (ExtractCommand("orders", input))
-        _HandleCommandOrders(input, fromPlayer);
-    else if (ExtractCommand("follow", input) || ExtractCommand("come", input))
-        _HandleCommandFollow(input, fromPlayer);
-    else if (ExtractCommand("stay", input) || ExtractCommand("stop", input))
-        _HandleCommandStay(input, fromPlayer);
-    else if (ExtractCommand("attack", input))
-        _HandleCommandAttack(input, fromPlayer);
-    else if (ExtractCommand("pull", input))
-        _HandleCommandPull(input, fromPlayer);
-
-    else if (ExtractCommand("neutralize", input) || ExtractCommand("neutral", input))
-        _HandleCommandNeutralize(input, fromPlayer);
-
-    else if (ExtractCommand("cast", input, true)) // true -> "cast" OR "c"
-        _HandleCommandCast(input, fromPlayer);
-
-    else if (ExtractCommand("sell", input))
-        _HandleCommandSell(input, fromPlayer);
-
-    else if (ExtractCommand("buy", input))
-        _HandleCommandBuy(input, fromPlayer);
-
-    else if (ExtractCommand("drop", input))
-        _HandleCommandDrop(input, fromPlayer);
-
-    else if (ExtractCommand("repair", input))
-        _HandleCommandRepair(input, fromPlayer);
-
-    else if (ExtractCommand("auction", input))
-        _HandleCommandAuction(input, fromPlayer);
-
-    else if (ExtractCommand("mail", input))
-        _HandleCommandMail(input, fromPlayer);
-
-    else if (ExtractCommand("bank", input))
-        _HandleCommandBank(input, fromPlayer);
-
-    else if (ExtractCommand("talent", input))
-        _HandleCommandTalent(input, fromPlayer);
-
-    else if (ExtractCommand("use", input, true)) // true -> "use" OR "u"
-        _HandleCommandUse(input, fromPlayer);
-
-    else if (ExtractCommand("equip", input, true)) // true -> "equip" OR "e"
-        _HandleCommandEquip(input, fromPlayer);
-
-    else if (ExtractCommand("resumeorders", input)) // restore previous combat orders if any
-        BotDataRestore();
-
-    // find project: 20:50 02/12/10 rev.4 item in world and wait until ordered to follow
-    else if (ExtractCommand("find", input, true)) // true -> "find" OR "f"
-        _HandleCommandFind(input, fromPlayer);
-
-    // get project: 20:50 02/12/10 rev.4 compact edition, handles multiple linked gameobject & improves visuals
-    else if (ExtractCommand("get", input, true)) // true -> "get" OR "g"
-        _HandleCommandGet(input, fromPlayer);
-
-    // Handle all collection related commands here
-    else if (ExtractCommand("collect", input))
-        _HandleCommandCollect(input, fromPlayer);
-
-    else if (ExtractCommand("quest", input))
-        _HandleCommandQuest(input, fromPlayer);
-
-    else if (ExtractCommand("craft", input))
-        _HandleCommandCraft(input, fromPlayer);
-
-    else if (ExtractCommand("enchant", input))
-        _HandleCommandEnchant(input, fromPlayer);
-
-    else if (ExtractCommand("process", input))
-        _HandleCommandProcess(input, fromPlayer);
-
-    else if (ExtractCommand("pet", input))
-        _HandleCommandPet(input, fromPlayer);
-
-    else if (ExtractCommand("spells", input))
-        _HandleCommandSpells(input, fromPlayer);
-
-    // survey project: 20:50 02/12/10 rev.4 compact edition
-    else if (ExtractCommand("survey", input))
-        _HandleCommandSurvey(input, fromPlayer);
-
-    // Handle class & professions training:
-    else if (ExtractCommand("skill", input))
-        _HandleCommandSkill(input, fromPlayer);
-
-    // stats project: 11:30 15/12/10 rev.2 display bot statistics
-    else if (ExtractCommand("stats", input))
-        _HandleCommandStats(input, fromPlayer);
-
-    else
-    {
-        // if this looks like an item link, reward item it completed quest and talking to NPC
-        std::list<uint32> itemIds;
-        extractItemIds(text, itemIds);
-        if (!itemIds.empty())
-        {
-            uint32 itemId = itemIds.front();
-            bool wasRewarded = false;
-            ObjectGuid questRewarderGUID = m_bot->GetSelectionGuid();
-            Object* const pNpc = (WorldObject*) m_bot->GetObjectByTypeMask(questRewarderGUID, TYPEMASK_CREATURE_OR_GAMEOBJECT);
-            if (!pNpc)
-                return;
-
-            QuestMenu& questMenu = m_bot->PlayerTalkClass->GetQuestMenu();
-            for (uint32 iI = 0; !wasRewarded && iI < questMenu.MenuItemCount(); ++iI)
-            {
-                QuestMenuItem const& qItem = questMenu.GetItem(iI);
-
-                uint32 questID = qItem.m_qId;
-                Quest const* pQuest = sObjectMgr.GetQuestTemplate(questID);
-                QuestStatus status = m_bot->GetQuestStatus(questID);
-
-                // if quest is complete, turn it in
-                if (status == QUEST_STATUS_COMPLETE &&
-                        !m_bot->GetQuestRewardStatus(questID) &&
-                        pQuest->GetRewChoiceItemsCount() > 1 &&
-                        m_bot->CanRewardQuest(pQuest, false))
-                    for (uint8 rewardIdx = 0; !wasRewarded && rewardIdx < pQuest->GetRewChoiceItemsCount(); ++rewardIdx)
-                    {
-                        ItemPrototype const* const pRewardItem = sObjectMgr.GetItemPrototype(pQuest->RewChoiceItemId[rewardIdx]);
-                        if (itemId == pRewardItem->ItemId)
-                        {
-                            m_bot->RewardQuest(pQuest, rewardIdx, pNpc, false);
-
-                            std::string questTitle  = pQuest->GetTitle();
-                            m_bot->GetPlayerbotAI()->QuestLocalization(questTitle, questID);
-                            std::string itemName = pRewardItem->Name1;
-                            m_bot->GetPlayerbotAI()->ItemLocalization(itemName, pRewardItem->ItemId);
-
-                            std::ostringstream out;
-                            out << "|cffffffff|Hitem:" << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r rewarded";
-                            SendWhisper(out.str(), fromPlayer);
-                            wasRewarded = true;
-                        }
-                    }
-            }
-        }
-        else
-        {
-            // TODO: make this only in response to direct whispers (chatting in party chat can in fact be between humans)
-            std::string msg = "What? For a list of commands, ask for 'help'.";
-            SendWhisper(msg, fromPlayer);
-            m_bot->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
-        }
-    }
-}
-
-/**
-* ExtractCommand looks for a command in a text string
-* sLookingFor       - string you're looking for (e.g. "help")
-* text              - string which may or may not start with sLookingFor
-* bUseShort         - does this command accept the shorthand command? If true, "help" would ALSO look for "h"
-*
-* returns true if the string has been found
-* returns false if the string has not been found
-*/
-bool PlayerbotAI::ExtractCommand(const std::string sLookingFor, std::string& text, bool bUseShort)
-{
-    // ("help" + " ") < "help X"  AND  text's start (as big as sLookingFor) == sLookingFor
-    // Recommend AGAINST adapting this for non-space situations (thinking MangosZero)
-    // - unknown would risk being (short for "use") 'u' + "nknown"
-    if (sLookingFor.size() + 1 < text.size() && text.at(sLookingFor.size()) == ' '
-            && 0 == text.substr(0, sLookingFor.size()).compare(sLookingFor))
-    {
-        text = text.substr(sLookingFor.size() + 1);
-        return true;
-    }
-
-    if (0 == text.compare(sLookingFor))
-    {
-        text = "";
-        return true;
-    }
-
-    if (bUseShort)
-    {
-        if (text.size() > 1 && sLookingFor.at(0) == text.at(0) && text.at(1) == ' ')
-        {
-            text = text.substr(2);
-            return true;
-        }
-        else if (text.size() == 1 && sLookingFor.at(0) == text.at(0))
-        {
-            text = "";
-            return true;
-        }
-    }
-
-    return false;
-}
-
-void PlayerbotAI::_HandleCommandReset(std::string& text, Player& fromPlayer)
-{
-    if (text != "")
-    {
-        SendWhisper("reset does not have a subcommand.", fromPlayer);
-        return;
-    }
-    SetState(BOTSTATE_NORMAL);
-    MovementReset();
-    SetQuestNeedItems();
-    SetQuestNeedCreatures();
-    UpdateAttackerInfo();
-    m_lootTargets.clear();
-    m_lootCurrent = ObjectGuid();
-    m_targetCombat = 0;
-}
-
-void PlayerbotAI::_HandleCommandOrders(std::string& text, Player& fromPlayer)
-{
-    if (ExtractCommand("delay", text))
-    {
-        uint32 gdelay;
-        sscanf(text.c_str(), "%d", &gdelay);
-        if (gdelay <= 10)
-        {
-            m_DelayAttack = gdelay;
-            TellMaster("Combat delay is now '%u' ", m_DelayAttack);
-            CharacterDatabase.DirectPExecute("UPDATE playerbot_saved_data SET combat_delay = '%u' WHERE guid = '%u'", m_DelayAttack, m_bot->GetGUIDLow());
-            return;
-        }
-        else
-            SendWhisper("Invalid delay. choose a number between 0 and 10", fromPlayer);
-        return;
-    }
-    else if (ExtractCommand("resume", text))
-        CombatOrderRestore();
-    else if (ExtractCommand("combat", text, true))
-    {
-        Unit* target = nullptr;
-
-        if (text == "")
-        {
-            SendWhisper("|cffff0000Syntax error:|cffffffff orders combat <botName> <reset | tank | heal | passive><assist | protect [targetPlayer]>", fromPlayer);
-            return;
-        }
-
-        QueryResult* resultlvl = CharacterDatabase.PQuery("SELECT guid FROM playerbot_saved_data WHERE guid = '%u'", m_bot->GetObjectGuid().GetCounter());
-        if (!resultlvl)
-            CharacterDatabase.DirectPExecute("INSERT INTO playerbot_saved_data (guid,combat_order,primary_target,secondary_target,pname,sname,combat_delay) VALUES ('%u',0,0,0,'','',0)", m_bot->GetObjectGuid().GetCounter());
-        else
-            delete resultlvl;
-
-        size_t protect = text.find("protect");
-        size_t assist = text.find("assist");
-
-        if (ExtractCommand("protect", text) || ExtractCommand("assist", text))
-        {
-            ObjectGuid targetGUID = fromPlayer.GetSelectionGuid();
-            if (text == "" && !targetGUID)
-            {
-                SendWhisper("|cffff0000Combat orders protect and assist expect a target either by selection or by giving target player in command string!", fromPlayer);
-                return;
-            }
-
-            if (text != "")
-            {
-                ObjectGuid targ_guid = sObjectMgr.GetPlayerGuidByName(text.c_str());
-                targetGUID.Set(targ_guid.GetRawValue());
-            }
-            target = ObjectAccessor::GetUnit(fromPlayer, targetGUID);
-            if (!target)
-                return SendWhisper("|cffff0000Invalid target for combat order protect or assist!", fromPlayer);
-
-            if (protect != std::string::npos)
-                SetCombatOrder(ORDERS_PROTECT, target);
-            else if (assist != std::string::npos)
-                SetCombatOrder(ORDERS_ASSIST, target);
-        }
-        else
-            SetCombatOrderByStr(text, target);
-    }
-    else if (text != "")
-    {
-        SendWhisper("See help for details on using 'orders'.", fromPlayer);
-        return;
-    }
-    SendOrders(*GetMaster());
-}
-
-void PlayerbotAI::_HandleCommandFollow(std::string& text, Player& fromPlayer)
-{
-    if (ExtractCommand("auto", text)) // switch to automatic follow distance
-    {
-        if (text != "")
-        {
-            SendWhisper("Invalid subcommand for 'follow'", fromPlayer);
-            return;
-        }
-        DistOverRide = 0; // this resets follow distance to config default
-        IsUpOrDown = 0;
-        std::ostringstream msg;
-        gTempDist = 1;
-        gTempDist2 = 2;
-
-        if (m_FollowAutoGo != FOLLOWAUTOGO_SET)
-        {
-            m_FollowAutoGo = FOLLOWAUTOGO_INIT;
-            msg << "Automatic Follow Distance is now |h|cff1eff00ON|h|r";
-            SendWhisper(msg.str(), fromPlayer);
-        }
-        else
-        {
-            m_FollowAutoGo = FOLLOWAUTOGO_OFF;
-            msg << "Automatic Follow Distance is now |h|cffff0000OFF|h|r";
-            SendWhisper(msg.str(), fromPlayer);
-        }
-        CharacterDatabase.DirectPExecute("UPDATE playerbot_saved_data SET auto_follow = '%u' WHERE guid = '%u'", m_FollowAutoGo, m_bot->GetGUIDLow());
-    }
-    else if (ExtractCommand("reset", text)) // switch to reset follow distance
-    {
-        if (text != "")
-        {
-            SendWhisper("Invalid subcommand for 'follow'", fromPlayer);
-            return;
-        }
-        DistOverRide = 0; // this resets follow distance to config default
-        IsUpOrDown = 0;
-        std::ostringstream msg;
-        gTempDist = 1;
-        gTempDist2 = 2;
-        msg << "Bit crowded isn't it?";
-        SendWhisper(msg.str(), fromPlayer);
-    }
-    else if (ExtractCommand("far", text)) // switch to increment follow distance
-    {
-        if (text != "")
-        {
-            SendWhisper("Invalid subcommand for 'follow'", fromPlayer);
-            return;
-        }
-        DistOverRide = (DistOverRide + 1); // this increments follow distance
-        std::ostringstream msg;
-        msg << "Increasing My follow distance";
-        SendWhisper(msg.str(), fromPlayer);
-    }
-    else if (ExtractCommand("near", text)) // switch to increment follow distance
-    {
-        if (text != "")
-        {
-            SendWhisper("Invalid subcommand for 'follow'", fromPlayer);
-            return;
-        }
-        if (DistOverRide > 0)
-            DistOverRide = (DistOverRide - 1); // this increments follow distance,
-
-        std::ostringstream msg;
-        if (DistOverRide == 0)
-        {
-            IsUpOrDown = 0;
-            DistOverRide = 0;
-            gTempDist = 1;
-            gTempDist2 = 2;
-            msg << "I'm NOT getting any closer than this";
-        }
-        if (DistOverRide != 0)
-            msg << "Decreasing My follow distance";
-        SendWhisper(msg.str(), fromPlayer);
-    }
-    else if (ExtractCommand("info", text))
-    {
-        std::ostringstream msg;
-
-        msg << "Automatic Follow Distance is ";
-
-        switch (DistOverRide)
-        {
-            case 0: msg << "|h|cffff0000" << m_bot->GetDistance(GetMaster()) << "|h|r"; break; //red
-            case 1: msg << "|h|cffff8000" << m_bot->GetDistance(GetMaster()) << "|h|r"; break; //yellow
-            case 2: msg << "|h|cffe6cc80" << m_bot->GetDistance(GetMaster()) << "|h|r"; break; //orange
-            case 3: msg << "|h|cff1eff00" << m_bot->GetDistance(GetMaster()) << "|h|r"; break; //green
-            case 4:
-            default: msg << "|h|cff0070dd" << m_bot->GetDistance(GetMaster()) << "|h|r"; break; //blue
-        }
-
-        m_FollowAutoGo ?  SendWhisper(msg.str(), fromPlayer) : SendWhisper("Automatic Follow Distance is |h|cffff0000OFF|h|r", fromPlayer);
-        return;
-    }
-    else if (text != "")
-    {
-        SendWhisper("see help for details on using follow.", fromPlayer);
-        return;
-    }
-    SetMovementOrder(MOVEMENT_FOLLOW, GetMaster());
-}
-
-void PlayerbotAI::_HandleCommandStay(std::string& text, Player& fromPlayer)
-{
-    if (text != "")
-    {
-        SendWhisper("stay cannot have a subcommand.", fromPlayer);
-        return;
-    }
-    SetMovementOrder(MOVEMENT_STAY);
-}
-
-void PlayerbotAI::_HandleCommandAttack(std::string& text, Player& fromPlayer)
-{
-    if (text != "")
-    {
-        SendWhisper("attack cannot have a subcommand.", fromPlayer);
-        return;
-    }
-    ObjectGuid attackOnGuid = fromPlayer.GetSelectionGuid();
-    if (attackOnGuid)
-    {
-        if (Unit* thingToAttack = ObjectAccessor::GetUnit(*m_bot, attackOnGuid))
-        {
-            if (m_bot->CanAttack(thingToAttack))
-            {
-                if (!m_bot->IsWithinLOSInMap(thingToAttack))
-                    DoTeleport(*m_followTarget);
-                if (m_bot->IsWithinLOSInMap(thingToAttack))
-                    Attack(thingToAttack);
-            }
-        }
-    }
-    else
-    {
-        SendWhisper("No target is selected.", fromPlayer);
-        m_bot->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
-    }
-}
-
-void PlayerbotAI::_HandleCommandPull(std::string& text, Player& fromPlayer)
-{
-    bool bReadyCheck = false;
-
-    if (!m_bot) return;
-
-    if (ExtractCommand("test", text)) // switch to automatic follow distance
-    {
-        if (CanPull(fromPlayer))
-            SendWhisper("Looks like I am capable of pulling. Ask me 'pull ready' with a target for a more precise check.", fromPlayer);
-        return;
-    }
-    if (ExtractCommand("ready", text)) // switch to automatic follow distance
-    {
-        bReadyCheck = true;
-    }
-    else if (text != "")
-    {
-        SendWhisper("See 'help pull' for details on using the pull command.", fromPlayer);
-        return;
-    }
-
-    // This function also takes care of error reporting
-    if (!CanPull(fromPlayer))
-        return;
-
-    // Check for valid target
-    m_bot->SetSelectionGuid(fromPlayer.GetSelectionGuid());
-    ObjectGuid attackOnGuid = m_bot->GetSelectionGuid();
-    if (!attackOnGuid)
-    {
-        SendWhisper("No target is selected.", fromPlayer);
-        return;
-    }
-
-    Unit* thingToAttack = ObjectAccessor::GetUnit(*m_bot, attackOnGuid);
-    if (!thingToAttack)
-    {
-        SendWhisper("No target is selected.", fromPlayer);
-        return;
-    }
-
-    if (m_bot->CanAssist(thingToAttack))
-    {
-        SendWhisper("Where I come from we don't attack our friends.", fromPlayer);
-        return;
-    }
-    // TODO: Okay, this one should actually be fixable. InMap should return, but LOS (Line of Sight) should result in moving, well, into LoS.
-    if (!m_bot->IsWithinLOSInMap(thingToAttack))
-    {
-        SendWhisper("I can't see that target!", fromPlayer);
-        return;
-    }
-    GetCombatTarget(thingToAttack);
-    if (!GetCurrentTarget())
-    {
-        SendWhisper("Failed to set target, cause unknown.", fromPlayer);
-        return;
-    }
-    if (bReadyCheck)
-    {
-        SendWhisper("All checks have been passed and I am ready to pull! ... Are you sure you wouldn't like a smaller target?", fromPlayer);
-        return;
-    }
-
-    // All healers which have it available will cast any applicable HoT (Heal over Time) spell on the tank
-    GroupHoTOnTank();
-
-    /* Technically the tank should wait a bit if/until the HoT has been applied
-       but the above function immediately casts it rather than wait for an UpdateAI tick
-
-       There is no need to take into account that GroupHoTOnTank() may fail due to global cooldown. Either you're prepared for a difficult
-       pull in which case it won't fail due to global cooldown, or you're chaining easy pulls in which case you don't care.
-       */
-    /* So have the group wait for the tank to take action (and aggro) - this way it will be easy to see if tank has aggro or not without having to
-       worry about tank not being the first to have UpdateAI() called
-       */
-
-    // Need to have a group and a tank, both checked in "CanPull()" call above
-    //if (!(GetGroupTank()->GetPlayerbotAI()->GetClassAI()->Pull()))
-    // I've been told to pull and a check was done above whether I'm actually a tank, so *I* will try to pull:
-    if (!CastPull())
-    {
-        SendWhisper("I did my best but I can't actually pull. How odd.", fromPlayer);
-        return;
-    }
-
-    // Sets Combat Orders to PULL
-    SetGroupCombatOrder(ORDERS_TEMP_WAIT_TANKAGGRO);
-
-    SetGroupIgnoreUpdateTime(2);
-
-    // Set all group members (save this tank) to wait 10 seconds. They will wait until the tank says so, until any non-tank gains aggro or 10 seconds - whichever is shortest
-    if (m_bot->GetGroup()) // one last sanity check, should be unnecessary
-    {
-        Group::MemberSlotList const& groupSlot = m_bot->GetGroup()->GetMemberSlots();
-        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
-        {
-            Player* groupMember = sObjectMgr.GetPlayer(itr->guid);
-            if (!groupMember || !groupMember->GetPlayerbotAI() || groupMember == m_bot)
-                continue;
-            groupMember->GetPlayerbotAI()->GetClassAI()->SetWait(10);
-        }
-    }
-
-    //(4a) if tank, deactivate any attack (such as 'shoot (bow/gun)' for warriors), wait until in melee range, attack
-    //(4b) if dps, wait until the target is in melee range of the tank +2seconds or until tank no longer holds aggro
-    //(4c) if healer, do healing checks
-    //(5) when target is in melee range of tank, wait 2 seconds (healers continue to do group heal checks, all do self-heal checks), then return to normal functioning
-}
-
-void PlayerbotAI::_HandleCommandNeutralize(std::string& text, Player& fromPlayer)
-{
-    if (!m_bot) return;
-
-    if (text != "")
-    {
-        SendWhisper("See 'help neutralize' for details on using the neutralize command.", fromPlayer);
-        return;
-    }
-
-    // Check for valid target
-    m_bot->SetSelectionGuid(fromPlayer.GetSelectionGuid());
-    ObjectGuid selectOnGuid = m_bot->GetSelectionGuid();
-    if (!selectOnGuid)
-    {
-        SendWhisper("No target is selected.", fromPlayer);
-        return;
-    }
-
-    Unit* thingToNeutralize = ObjectAccessor::GetUnit(*m_bot, selectOnGuid);
-    if (!thingToNeutralize)
-    {
-        SendWhisper("No valid target is selected.", fromPlayer);
-        return;
-    }
-
-    if (m_bot->CanAssist(thingToNeutralize))
-    {
-        SendWhisper("I can't neutralize that target: this is a friend to me.", fromPlayer);
-        return;
-    }
-
-    if (!m_bot->IsWithinLOSInMap(thingToNeutralize))
-    {
-        SendWhisper("I can't see that target!", fromPlayer);
-        return;
-    }
-
-    if (IsNeutralized(thingToNeutralize))
-    {
-        SendWhisper("Target is already neutralized.", fromPlayer);
-        return;
-    }
-
-    m_targetGuidCommand = selectOnGuid;
-
-    // All checks passed: call the Neutralize function of each bot class
-    // to define what spellid to use if available and if creature type is correct
-    // m_spellIdCommand will be defined there and UpdateAI will then handle the cast
-    if (!CastNeutralize())
-    {
-        SendWhisper("Something went wrong: I can't neutralize that target.", fromPlayer);
-        return;
-    }
-}
-
-void PlayerbotAI::_HandleCommandCast(std::string& text, Player& fromPlayer)
-{
-    if (text == "")
-    {
-        SendWhisper("cast must be used with a single spell link (shift + click the spell).", fromPlayer);
-        return;
-    }
-
-    std::string spellStr = text;
-    uint32 spellId = (uint32) atol(spellStr.c_str());
-
-    // try and get spell ID by name
-    if (spellId == 0)
-    {
-        spellId = getSpellId(spellStr.c_str(), true);
-
-        // try link if text NOT (spellid OR spellname)
-        if (spellId == 0)
-            extractSpellId(text, spellId);
-    }
-
-    if (m_bot->HasAura(spellId))
-    {
-        m_bot->RemoveAurasByCasterSpell(spellId, m_bot->GetObjectGuid());
-        return;
-    }
-
-    ObjectGuid castOnGuid = fromPlayer.GetSelectionGuid();
-    if (spellId != 0 && m_bot->HasSpell(spellId))
-    {
-        m_spellIdCommand = spellId;
-        if (castOnGuid)
-            m_targetGuidCommand = castOnGuid;
-        else
-            m_targetGuidCommand = m_bot->GetObjectGuid();
-    }
-}
-
-// _HandleCommandSell: Handle selling items
-// sell [Item Link][Item Link] .. -- Sells bot(s) items from inventory
-void PlayerbotAI::_HandleCommandSell(std::string& text, Player& fromPlayer)
-{
-    FollowAutoReset();
-    if (ExtractCommand("all", text)) // switch to auto sell low level white items
-    {
-        std::ostringstream msg;
-        if (text != "")
-        {
-            SendWhisper("Invalid subcommand for 'sell all'", fromPlayer);
-            return;
-        }
-        SellWhite = !SellWhite;
-        msg << "I will " << (SellWhite ? "" : "no longer ") << "sell my low level normal items.";
-        SendWhisper(msg.str(), fromPlayer);
-        return;
-    }
-    if (text == "")
-    {
-        SendWhisper("sell must be used with one or more item links (shift + click the item).", fromPlayer);
-        return;
-    }
-
-    std::list<uint32> itemIds;
-    extractItemIds(text, itemIds);
-    for (std::list<uint32>::iterator it = itemIds.begin(); it != itemIds.end(); ++it)
-        m_tasks.push_back(std::pair<enum TaskFlags, uint32>(SELL_ITEMS, *it));
-    m_findNPC.push_back(VENDOR_MASK);
-}
-
-// _HandleCommandBuy: Handle buying items
-// buy [Item Link][Item Link] .. -- Buys items from vendor
-void PlayerbotAI::_HandleCommandBuy(std::string& text, Player& fromPlayer)
-{
-    if (text == "")
-    {
-        SendWhisper("buy must be used with one or more item links (shift + click the item).", fromPlayer);
-        return;
-    }
-
-    FollowAutoReset();
-    /*    ObjectGuid vendorguid = fromPlayer.GetSelectionGuid();
-        if (!vendorguid)
-        {
-            SendWhisper("No vendor is selected.", fromPlayer);
-            m_bot->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
-            return;
-        }*/
-
-    std::list<uint32> itemIds;
-    extractItemIds(text, itemIds);
-    for (std::list<uint32>::iterator it = itemIds.begin(); it != itemIds.end(); ++it)
-        m_tasks.push_back(std::pair<enum TaskFlags, uint32>(BUY_ITEMS, *it));
-    m_findNPC.push_back(VENDOR_MASK);
-}
-
-// _HandleCommandDrop: Handle dropping items
-// drop [Item Link][Item Link] .. -- Drops item(s) from bot's inventory
-void PlayerbotAI::_HandleCommandDrop(std::string& text, Player& fromPlayer)
-{
-    if (text == "")
-    {
-        SendWhisper("drop must be used with one or more item links (shift + click the item).", fromPlayer);
-        return;
-    }
-
-    std::ostringstream report;
-    std::list<uint32> itemIds;
-    extractItemIds(text, itemIds);
-    report << "Dropped ";
-    for (std::list<uint32>::iterator it = itemIds.begin(); it != itemIds.end(); ++it)
-        report << DropItem(*it);
-
-    if (report.str() == "Dropped ")
-    {
-        SendWhisper("No items were dropped. It would appear something has gone hinky.", fromPlayer);
-        return;
-    }
-    SetQuestNeedItems();
-    report << ".";
-    SendWhisper(report.str(), fromPlayer);
-}
-
-// _HandleCommandRepair: Handle repair items
-// repair  all                      -- repair all bot(s) items
-// repair [Item Link][Item Link] .. -- repair select bot(s) items
-void PlayerbotAI::_HandleCommandRepair(std::string& text, Player& fromPlayer)
-{
-    FollowAutoReset();
-    if (ExtractCommand("all", text))
-    {
-        if (text != "")
-        {
-            SendWhisper("Invalid subcommand for 'repair all'", fromPlayer);
-            return;
-        }
-        m_tasks.push_back(std::pair<enum TaskFlags, uint32>(REPAIR_ITEMS, 0));
-        m_findNPC.push_back(UNIT_NPC_FLAG_REPAIR);
-        return;
-    }
-
-    std::list<uint32> itemIds;
-    extractItemIds(text, itemIds);
-
-    for (std::list<uint32>::iterator it = itemIds.begin(); it != itemIds.end(); it++)
-    {
-        m_tasks.push_back(std::pair<enum TaskFlags, uint32>(REPAIR_ITEMS, *it));
-        m_findNPC.push_back(UNIT_NPC_FLAG_REPAIR);
-    }
-}
-
-// _HandleCommandAuction: Handle auctions:
-// auction                                        -- Lists bot(s) active auctions.
-// auction add [Item Link][Item Link] ..          -- Create bot(s) active auction.
-// auction remove [Auction Link][Auction Link] .. -- Cancel bot(s) active auction. ([Auction Link] from auction)
-void PlayerbotAI::_HandleCommandAuction(std::string& text, Player& fromPlayer)
-{
-    FollowAutoReset();
-    if (text == "")
-    {
-        m_tasks.push_back(std::pair<enum TaskFlags, uint32>(LIST_AUCTION, 0));
-        m_findNPC.push_back(UNIT_NPC_FLAG_AUCTIONEER); // list all bot auctions
-    }
-    else if (ExtractCommand("add", text))
-    {
-        std::list<uint32> itemIds;
-        extractItemIds(text, itemIds);
-        for (std::list<uint32>::iterator it = itemIds.begin(); it != itemIds.end(); ++it)
-            m_tasks.push_back(std::pair<enum TaskFlags, uint32>(ADD_AUCTION, *it));
-        m_findNPC.push_back(UNIT_NPC_FLAG_AUCTIONEER);
-    }
-    else if (ExtractCommand("remove", text))
-    {
-        std::list<uint32> auctionIds;
-        extractAuctionIds(text, auctionIds);
-        for (std::list<uint32>::iterator it = auctionIds.begin(); it != auctionIds.end(); ++it)
-            m_tasks.push_back(std::pair<enum TaskFlags, uint32>(REMOVE_AUCTION, *it));
-        m_findNPC.push_back(UNIT_NPC_FLAG_AUCTIONEER);
-    }
-    else
-    {
-        SendWhisper("I don't understand what you're trying to do", fromPlayer);
-    }
-}
-
-void PlayerbotAI::_HandleCommandMail(std::string& text, Player& fromPlayer)
-{
-    ChatHandler ch(&fromPlayer);
-
-    if (text == "")
-    {
-        ch.SendSysMessage("Syntax: mail <inbox [Mailbox] | getcash [mailid].. | getitem [mailid].. | delete [mailid]..>");
-        return;
-    }
-    else if (ExtractCommand("inbox", text))
-    {
-        uint32 mail_count = 0;
-        extractGOinfo(text, m_lootTargets);
-
-        if (m_lootTargets.empty())
-        {
-            ch.SendSysMessage("Syntax: mail <inbox [Mailbox]>");
-            return;
-        }
-
-        ObjectGuid m_mailboxGuid = m_lootTargets.front();
-        m_lootTargets.pop_front();
-        m_lootTargets.clear();
-
-        if (!m_bot->GetGameObjectIfCanInteractWith(m_mailboxGuid, GAMEOBJECT_TYPE_MAILBOX))
-        {
-            Announce(CANT_USE_TOO_FAR);
-            return;
-        }
-
-        TellMaster("Inbox:\n");
-
-        for (PlayerMails::reverse_iterator itr = m_bot->GetMailRBegin(); itr != m_bot->GetMailREnd(); ++itr)
-        {
-            std::ostringstream msg;
-            ++mail_count;
-            std::string body = "";
-
-            QueryResult* result = CharacterDatabase.PQuery("SELECT text FROM item_text WHERE id = '%u'", (*itr)->itemTextId);
-            if (result)
-            {
-                Field* fields = result->Fetch();
-
-                body  = fields[0].GetString();
-            }
-            delete result;
-
-            msg  << "|cffffcccc|Hmail:" << (*itr)->messageID << "|h[" << (*itr)->messageID << "]|h|r ";
-
-            switch ((*itr)->messageType)
-            {
-                case MAIL_NORMAL:
-                {
-                    msg << "|cffffffff"; // white
-                    if ((*itr)->subject != "")
-                        msg << "Subject: " << (*itr)->subject << "\n";
-
-                    if (body != "")
-                        msg << body << "\n";
-                    break;
-                }
-                case MAIL_CREATURE:
-                    msg << "|cffccffccMAIL_CREATURE\n"; // green
-                    break;
-                case MAIL_GAMEOBJECT:
-                    msg << "|cffccffccMAIL_GAMEOBJECT\n"; // green
-                    break;
-                case MAIL_AUCTION:
-                {
-                    msg << "|cffccffff"; // blue
-                    msg << AuctionResult((*itr)->subject, body) << "\n";
-                    break;
-                }
-                case MAIL_ITEM:
-                    msg << "|cffccffccMAIL_ITEM\n"; // green
-                    break;
-            }
-
-            std::string subject = (*itr)->subject;
-            subject.append(":");
-
-            int pos = 0, i = 0;
-            uint32 element[10];
-            while (true)
-            {
-                int endpos = subject.find(':', pos);
-                if (endpos == -1)
-                    break;
-
-                std::string idc = subject.substr(pos, endpos - pos);
-                element[i] = atol(idc.c_str());
-                DEBUG_LOG("element[%d] = (%u)", i, element[i]);
-                pos = endpos + 1;
-                ++i;
-            }
-
-            if (element[2] == 6) // mail pending
-            {
-                tm* timeinfo;
-                time_t eta = (*itr)->deliver_time + HOUR;
-                timeinfo = gmtime(&eta);
-
-                msg << "Estimated delivery time " << asctime(timeinfo);
-            }
-
-            if ((*itr)->money)
-                msg << "[To Collect: " << Cash((*itr)->money) << " ]\n";
-
-            uint8 item_count = (*itr)->items.size(); // max count is MAX_MAIL_ITEMS (12)
-            if (item_count > 0)
-            {
-                msg << "Items: ";
-                for (uint8 i = 0; i < item_count; ++i)
-                {
-                    Item* item = m_bot->GetMItem((*itr)->items[i].item_guid);
-                    if (item)
-                        MakeItemLink(item, msg, true);
-                }
-            }
-            msg << "\n";
-            ch.SendSysMessage(msg.str().c_str());
-        }
-
-        if (mail_count == 0)
-            ch.SendSysMessage("|cff009900My inbox is empty.");
-    }
-    else if (ExtractCommand("getcash", text))
-    {
-        std::ostringstream msg;
-        std::list<uint32> mailIds;
-        extractMailIds(text, mailIds);
-        mailIds.unique();
-        mailIds.sort();
-        uint32 total = 0;
-
-        if (mailIds.empty())
-        {
-            ch.SendSysMessage("Syntax: mail <getcash [mailId]..>");
-            return;
-        }
-
-        for (std::list<uint32>::iterator it = mailIds.begin(); it != mailIds.end(); ++it)
-        {
-            Mail* m = m_bot->GetMail(*it);
-            if (!m || m->state == MAIL_STATE_DELETED || m->deliver_time > CurrentTime())
-            {
-                m_bot->SendMailResult(*it, MAIL_MONEY_TAKEN, MAIL_ERR_INTERNAL_ERROR);
-                return;
-            }
-
-            m_bot->SendMailResult(*it, MAIL_MONEY_TAKEN, MAIL_OK);
-            m_bot->ModifyMoney(m->money);
-            total += m->money;
-            m->money = 0;
-            m->state = MAIL_STATE_CHANGED;
-            m_bot->m_mailsUpdated = true;
-            m_bot->UpdateMail();
-        }
-        if (total > 0)
-        {
-            msg << "|cff009900" << "I received: |r" << Cash(total);
-            ch.SendSysMessage(msg.str().c_str());
-        }
-    }
-    else if (ExtractCommand("getitem", text))
-    {
-        std::list<uint32> mailIds;
-        extractMailIds(text, mailIds);
-        mailIds.unique();
-        mailIds.sort();
-
-        if (mailIds.empty())
-        {
-            ch.SendSysMessage("Syntax: mail <getitem [mailId]..>");
-            return;
-        }
-
-        for (std::list<uint32>::iterator it = mailIds.begin(); it != mailIds.end(); it++)
-        {
-            Mail* m = m_bot->GetMail(*it);
-            if (!m || m->state == MAIL_STATE_DELETED || m->deliver_time > CurrentTime())
-            {
-                m_bot->SendMailResult(*it, MAIL_ITEM_TAKEN, MAIL_ERR_INTERNAL_ERROR);
-                return;
-            }
-
-            // prevent cheating with skip client money check
-            if (m_bot->GetMoney() < m->COD)
-            {
-                m_bot->SendMailResult(*it, MAIL_ITEM_TAKEN, MAIL_ERR_NOT_ENOUGH_MONEY);
-                return;
-            }
-
-            if (m->HasItems())
-            {
-                bool has_items = true;
-                std::ostringstream msg;
-
-                msg << "|cff009900" << "I received item: |r";
-                for (MailItemInfoVec::const_iterator itr = m->items.begin(); itr != m->items.end();)
-                {
-                    has_items = true;
-                    Item* item = m_bot->GetMItem(itr->item_guid);
-                    if (!item)
-                    {
-                        ch.SendSysMessage("item not found");
-                        return;
-                    }
-
-                    ItemPosCountVec dest;
-
-                    InventoryResult res = m_bot->CanStoreItem(NULL_BAG, NULL_SLOT, dest, item, false);
-                    if (res == EQUIP_ERR_OK)
-                    {
-                        m->removedItems.push_back(itr->item_guid);
-
-                        if (m->COD > 0)  // if there is COD, take COD money from player and send them to sender by mail
-                        {
-                            ObjectGuid sender_guid = ObjectGuid(HIGHGUID_PLAYER, m->sender);
-                            Player* sender = sObjectMgr.GetPlayer(sender_guid);
-
-                            uint32 sender_accId = 0;
-
-                            if (GetMaster()->GetSession()->GetSecurity() > SEC_PLAYER && sWorld.getConfig(CONFIG_BOOL_GM_LOG_TRADE))
-                            {
-                                std::string sender_name;
-                                if (sender)
-                                {
-                                    sender_accId = sender->GetSession()->GetAccountId();
-                                    sender_name = sender->GetName();
-                                }
-                                else if (sender_guid)
-                                {
-                                    // can be calculated early
-                                    sender_accId = sObjectMgr.GetPlayerAccountIdByGUID(sender_guid);
-
-                                    if (!sObjectMgr.GetPlayerNameByGUID(sender_guid, sender_name))
-                                        sender_name = sObjectMgr.GetMangosStringForDBCLocale(LANG_UNKNOWN);
-                                }
-                                sLog.outCommand(GetMaster()->GetSession()->GetAccountId(), "GM %s (Account: %u) receive mail item: %s (Entry: %u Count: %u) and send COD money: %u to player: %s (Account: %u)",
-                                                GetMaster()->GetSession()->GetPlayerName(), GetMaster()->GetSession()->GetAccountId(), item->GetProto()->Name1, item->GetEntry(), item->GetCount(), m->COD, sender_name.c_str(), sender_accId);
-                            }
-                            else if (!sender)
-                                sender_accId = sObjectMgr.GetPlayerAccountIdByGUID(sender_guid);
-
-                            // check player existence
-                            if (sender || sender_accId)
-                            {
-                                MailDraft(m->subject, "")
-                                .SetMoney(m->COD)
-                                .SendMailTo(MailReceiver(sender, sender_guid), m_bot, MAIL_CHECK_MASK_COD_PAYMENT);
-                            }
-
-                            m_bot->ModifyMoney(-int32(m->COD));
-                        }
-                        m->COD = 0;
-                        m->state = MAIL_STATE_CHANGED;
-                        m_bot->m_mailsUpdated = true;
-                        m_bot->RemoveMItem(item->GetGUIDLow());
-
-                        uint32 count = item->GetCount(); // save counts before store and possible merge with deleting
-                        m_bot->MoveItemToInventory(dest, item, true);
-                        m_bot->UpdateMail();
-                        m_bot->SendMailResult(*it, MAIL_ITEM_TAKEN, MAIL_OK, 0, itr->item_guid, count);
-                        if (m->RemoveItem(itr->item_guid))
-                        {
-                            MakeItemLink(item, msg, true);
-                            has_items = false;
-                        }
-                    }
-                    else
-                        m_bot->SendMailResult(*it, MAIL_ITEM_TAKEN, MAIL_ERR_EQUIP_ERROR, res);
-                }
-
-                if (!has_items)
-                {
-                    CharacterDatabase.BeginTransaction();
-                    CharacterDatabase.PExecute("UPDATE mail SET has_items = 0 WHERE id = %u", *it);
-                    CharacterDatabase.CommitTransaction();
-                }
-                msg << "\n";
-                ch.SendSysMessage(msg.str().c_str());
-            }
-        }
-    }
-    else if (ExtractCommand("delete", text))
-    {
-        std::ostringstream msg;
-        std::list<uint32> mailIds;
-        extractMailIds(text, mailIds);
-        mailIds.unique();
-        mailIds.sort();
-
-        if (mailIds.empty())
-        {
-            ch.SendSysMessage("Syntax: mail <delete [mailId]..>");
-            return;
-        }
-
-        msg << "|cff009900Mail ";
-        for (std::list<uint32>::iterator it = mailIds.begin(); it != mailIds.end(); ++it)
-        {
-            m_bot->m_mailsUpdated = true;
-
-            Mail* m = m_bot->GetMail(*it);
-
-            if (m)
-            {
-                // delete shouldn't show up for COD mails
-                if (m->COD)
-                {
-                    m_bot->SendMailResult(*it, MAIL_DELETED, MAIL_ERR_INTERNAL_ERROR);
-                    return;
-                }
-                m->state = MAIL_STATE_DELETED;
-
-                m_bot->SendMailResult(*it, MAIL_DELETED, MAIL_OK);
-                CharacterDatabase.BeginTransaction();
-                CharacterDatabase.PExecute("DELETE FROM mail WHERE id = '%u'", *it);
-                CharacterDatabase.PExecute("DELETE FROM mail_items WHERE mail_id = '%u'", *it);
-                CharacterDatabase.PExecute("DELETE FROM item_text WHERE id = '%u'", m->itemTextId);
-                CharacterDatabase.CommitTransaction();
-                m_bot->RemoveMail(*it);
-                msg << "|cffffcccc|h[" << *it << "]|h|r";
-            }
-        }
-        msg << "|cff009900 has been deleted..";
-        ch.SendSysMessage(msg.str().c_str());
-    }
-}
-
-// _HandleCommandBank: Handle bank:
-// bank                                        -- Lists bot(s) bank balance.
-// bank deposit [Item Link][Item Link] ..      -- Deposit item(s) in bank.
-// bank withdraw [Item Link][Item Link] ..     -- Withdraw item(s) from bank. ([Item Link] from bank)
-void PlayerbotAI::_HandleCommandBank(std::string& text, Player& fromPlayer)
-{
-    FollowAutoReset();
-    if (text == "")
-    {
-        m_tasks.push_back(std::pair<enum TaskFlags, uint32>(BANK_BALANCE, 0));
-        m_findNPC.push_back(UNIT_NPC_FLAG_BANKER); // list all bot balance
-    }
-    else if (ExtractCommand("deposit", text))
-    {
-        std::list<uint32> itemIds;
-        extractItemIds(text, itemIds);
-        for (std::list<uint32>::iterator it = itemIds.begin(); it != itemIds.end(); ++it)
-            m_tasks.push_back(std::pair<enum TaskFlags, uint32>(BANK_DEPOSIT, *it));
-        m_findNPC.push_back(UNIT_NPC_FLAG_BANKER);
-    }
-    else if (ExtractCommand("withdraw", text))
-    {
-        std::list<uint32> itemIds;
-        extractItemIds(text, itemIds);
-        for (std::list<uint32>::iterator it = itemIds.begin(); it != itemIds.end(); ++it)
-            m_tasks.push_back(std::pair<enum TaskFlags, uint32>(BANK_WITHDRAW, *it));
-        m_findNPC.push_back(UNIT_NPC_FLAG_BANKER);
-    }
-    else
-    {
-        SendWhisper("I don't understand what you're trying to do", fromPlayer);
-    }
-}
-
-// _HandleCommandTalent: Handle talents:
-// talent                           -- Lists bot(s) unspent points & cost to reset
-// talent learn                     -- Lists available bot talents [TALENT LINK], as long as the bot has unspent points.
-// talent learn [TALENT LINK] ..    -- Learn selected talent [TALENT LINK] from 'talent learn' output (shift click icon/link)
-// talent reset                     -- Resets all talents (Must visit a suitable class trainer to reset talents)
-void PlayerbotAI::_HandleCommandTalent(std::string& text, Player& fromPlayer)
-{
-    std::ostringstream out;
-    uint32 CurTalentPoints = m_bot->GetFreeTalentPoints();
-
-    if (ExtractCommand("learn", text))
-    {
-        if (text.size() > 0)
-        {
-
-            std::list<talentPair>talents;
-            extractTalentIds(text, talents);
-
-            for (std::list<talentPair>::iterator itr = talents.begin(); itr != talents.end(); itr++)
-            {
-                uint32 talentid;
-                uint32 rank;
-
-                talentid = itr->first;
-                rank = itr->second;
-
-                m_bot->learnSpell(talentid, false);
-
-                if (m_bot->HasSpell(talentid))
-                {
-                    WorldPacket data(SMSG_PLAY_SPELL_IMPACT, 12);            // visual effect on player
-                    data << m_bot->GetObjectGuid();
-                    data << uint32(0x016A);                                 // index from SpellVisualKit.dbc
-                    GetMaster()->GetSession()->SendPacket(data);
-
-                    InspectUpdate();
-                }
-
-                // DEBUG_LOG("TalentID: %u Rank: %u\n", talentid, rank);
-            }
-        }
-        // Handle: List class or profession skills, spells & abilities for selected trainer
-        else
-        {
-            if (CurTalentPoints == 0)
-            {
-                out << "I have no free talent points to spend!";
-                SendWhisper(out.str(), fromPlayer);
-                return;
-            }
-            else
-                out << "I have " << CurTalentPoints << " free talent points to spend\r";
-
-            out << "The talents I can learn:\r";
-
-            // find class talent tabs (all players have 3 talent tabs)
-            uint32 const* talentTabIds = GetTalentTabPages(m_bot->getClass());
-
-            for (uint32 i = 0; i < 3; ++i)
-            {
-                uint32 talentTabId = talentTabIds[i];
-                uint32 classMask = m_bot->getClassMask();
-
-                for (uint32 ts = 0; ts < sTalentStore.GetNumRows(); ++ts)
-                {
-                    TalentEntry const* talentInfo = sTalentStore.LookupEntry(ts);
-                    if (!talentInfo)
-                        continue;
-
-                    TalentTabEntry const* talentTabInfo = sTalentTabStore.LookupEntry(talentInfo->TalentTab);
-                    if (!talentTabInfo)
-                        continue;
-
-                    // if talent not right for bot class, continue
-                    if ((classMask & talentTabInfo->ClassMask) == 0)
-                        continue;
-
-                    // if talent not on same tab, continue
-                    if (talentInfo->TalentTab != talentTabId)
-                        continue;
-                    // find current max talent rank
-                    int curtalent_maxrank = 0;
-                    for (int k = MAX_TALENT_RANK - 1; k > -1; --k)
-                    {
-                        if (talentInfo->RankID[k] && m_bot->HasSpell(talentInfo->RankID[k]))
-                        {
-                            curtalent_maxrank = k + 1;
-                            break;
-                        }
-                    }
-
-                    // Check if it requires another previous talent
-                    if (talentInfo->DependsOn > 0)
-                    {
-                        if (TalentEntry const* depTalentInfo = sTalentStore.LookupEntry(talentInfo->DependsOn))
-                        {
-                            bool hasEnoughRank = false;
-                            for (int dor = talentInfo->DependsOnRank; dor < MAX_TALENT_RANK; ++dor)
-                            {
-                                if (depTalentInfo->RankID[dor] != 0)
-                                    if (m_bot->HasSpell(depTalentInfo->RankID[dor]))
-                                        hasEnoughRank = true;
-                            }
-
-                            if (!hasEnoughRank)
-                                continue;
-                        }
-                    }
-
-                    // Check if it requires spell
-                    if (talentInfo->DependsOnSpell && !m_bot->HasSpell(talentInfo->DependsOnSpell))
-                        continue;
-
-                    // Find out how many points we have in this field
-                    uint32 spentPoints = 0;
-
-                    uint32 tTab = talentInfo->TalentTab;
-                    if (talentInfo->Row > 0)
-                    {
-                        unsigned int numRows = sTalentStore.GetNumRows();
-                        for (unsigned int i = 0; i < numRows; ++i)          // Loop through all talents.
-                        {
-                            // Someday, someone needs to revamp
-                            const TalentEntry* tmpTalent = sTalentStore.LookupEntry(i);
-                            if (tmpTalent)                                  // the way talents are tracked
-                            {
-                                if (tmpTalent->TalentTab == tTab)
-                                {
-                                    for (int j = 0; j < MAX_TALENT_RANK; ++j)
-                                    {
-                                        if (tmpTalent->RankID[j] != 0)
-                                        {
-                                            if (m_bot->HasSpell(tmpTalent->RankID[j]))
-                                                spentPoints += j + 1;
-                                        }
-                                    }
-                                }
-                            }
-                        }
-                    }
-
-                    // not have required min points spent in talent tree
-                    if (spentPoints < (talentInfo->Row * MAX_TALENT_RANK))
-                        continue;
-
-                    SpellEntry const* spellInfo = sSpellTemplate.LookupEntry<SpellEntry>(talentInfo->RankID[curtalent_maxrank]);
-                    if (!spellInfo || !SpellMgr::IsSpellValid(spellInfo, m_bot, false))
-                        continue;
-
-                    out << "|cff4e96f7|Htalent:" << talentInfo->RankID[curtalent_maxrank] << ":" << curtalent_maxrank << "|h[" << spellInfo->SpellName[GetMaster()->GetSession()->GetSessionDbcLocale()] << "]|h|r";
-                }
-            }
-            SendWhisper(out.str(), fromPlayer);
-        }
-    }
-    else if (ExtractCommand("reset", text))
-    {
-        FollowAutoReset();
-        m_tasks.push_back(std::pair<enum TaskFlags, uint32>(RESET_TALENTS, 0));
-        m_findNPC.push_back(UNIT_NPC_FLAG_TRAINER);
-    }
-    else
-    {
-        uint32 gold = uint32(m_bot->resetTalentsCost() / 10000);
-
-        out << "I have " << CurTalentPoints << " free talent points to spend.\r";
-
-        if (gold > 0)
-            out << "Cost to reset all Talents is " << gold << " |TInterface\\Icons\\INV_Misc_Coin_01:8|t";
-
-        SendWhisper(out.str(), fromPlayer);
-    }
-}
-
-void PlayerbotAI::_HandleCommandProcess(std::string& text, Player& fromPlayer)
-{
-    uint32 spellId;
-
-    if (ExtractCommand("disenchant", text, true)) // true -> "process disenchant" OR "process d"
-    {
-        if (m_bot->HasSkill(SKILL_ENCHANTING))
-        {
-            spellId = DISENCHANTING_1;
-        }
-        else
-        {
-            SendWhisper("|cffff0000I can't disenchant, I don't have the skill.", fromPlayer);
-            return;
-        }
-    }
-    else if (ExtractCommand("prospect", text, true)) // true -> "process prospect" OR "process p"
-    {
-        if (m_bot->HasSkill(SKILL_JEWELCRAFTING) && m_bot->GetSkillValuePure(SKILL_JEWELCRAFTING) >= 20)
-        {
-            spellId = PROSPECTING_1;
-        }
-        else
-        {
-            SendWhisper("|cffff0000I can't prospect, I don't have the skill.", fromPlayer);
-            return;
-        }
-    }
-    else
-        return;
-
-    std::list<uint32> itemIds;
-    std::list<Item*> itemList;
-    extractItemIds(text, itemIds);
-    findItemsInInv(itemIds, itemList);
-
-    if (itemList.empty())
-    {
-        SendWhisper("|cffff0000I can't process that!", fromPlayer);
-        return;
-    }
-
-    Item* reagent = itemList.back();
-    itemList.pop_back();
-
-    SpellEntry const* spellInfo = sSpellTemplate.LookupEntry<SpellEntry>(spellId);
-    if (!spellInfo)
-        return;
-
-    if (reagent)
-    {
-        SpellCastTargets targets;
-        m_itemTarget = reagent->GetProto()->ItemId;
-        targets.setItemTarget(reagent);
-        Spell* spell = new Spell(m_bot, spellInfo, false);
-        spell->SpellStart(&targets);
-    }
-}
-
-void PlayerbotAI::_HandleCommandUse(std::string& text, Player& fromPlayer)
-{
-    std::list<uint32> itemIds;
-    std::list<Item*> itemList;
-    extractItemIds(text, itemIds);
-    findItemsInInv(itemIds, itemList);
-
-    if (itemList.empty())
-    {
-        SendWhisper("|cffff0000I can't use that!", fromPlayer);
-        return;
-    }
-
-    Item* tool = itemList.back();
-    itemList.pop_back();
-    if (tool)
-    {
-        // set target
-        Unit* unit = ObjectAccessor::GetUnit(*m_bot, fromPlayer.GetSelectionGuid());
-        findItemsInEquip(itemIds, itemList);
-        extractGOinfo(text, m_lootTargets);
-        // DEBUG_LOG("tool (%s)",tool->GetProto()->Name1);
-
-        if (!itemList.empty())
-        {
-            Item* itarget = itemList.back();
-            if (itarget)
-            {
-                // DEBUG_LOG("target (%s)",itarget->GetProto()->Name1);
-                UseItem(tool, _findItemSlot(itarget)); // on equipped item
-                SetState(BOTSTATE_DELAYED);
-                SetIgnoreUpdateTime(1);
-            }
-        }
-        else if (!m_lootTargets.empty())
-        {
-            ObjectGuid gotarget = m_lootTargets.front();
-            m_lootTargets.pop_front();
-
-            GameObject* go = m_bot->GetMap()->GetGameObject(gotarget);
-            if (go)
-            {
-                // DEBUG_LOG("tool (%s) on target gameobject (%s)",tool->GetProto()->Name1,go->GetGOInfo()->name);
-                UseItem(tool, TARGET_FLAG_OBJECT, gotarget); // on gameobject
-            }
-        }
-        else if (unit)
-        {
-            // DEBUG_LOG("tool (%s) on selected target unit",tool->GetProto()->Name1);
-            UseItem(tool, unit); // on unit
-        }
-        else
-        {
-            // DEBUG_LOG("tool (%s) on self",tool->GetProto()->Name1);
-            UseItem(tool); // on self
-            SetIgnoreUpdateTime(3);
-        }
-    }
-    return;
-}
-
-void PlayerbotAI::_HandleCommandEquip(std::string& text, Player& fromPlayer)
-{
-    if (ExtractCommand("auto", text))
-    {
-        bool bOnce = false;
-        bool bWasToggleOn = m_AutoEquipToggle;
-
-        // run autoequip cycle once - right now - turning off after
-        if (ExtractCommand("once", text))
-        {
-            bWasToggleOn = m_AutoEquipToggle;
-            m_AutoEquipToggle = true;
-            bOnce = true;
-        }
-        else if (ExtractCommand("on", text))
-            m_AutoEquipToggle = true;
-        else if (ExtractCommand("off", text))
-            m_AutoEquipToggle = false;
-        else // subcommand not found, assume toggle
-            m_AutoEquipToggle = !m_AutoEquipToggle;
-
-        CharacterDatabase.DirectPExecute("UPDATE playerbot_saved_data SET autoequip = '%u' WHERE guid = '%u'", m_AutoEquipToggle, m_bot->GetGUIDLow());
-
-        if (m_AutoEquipToggle)
-            AutoUpgradeEquipment();
-
-        // feedback
-        if (bOnce)
-        {
-            if (bWasToggleOn)
-                SendWhisper("Equip Auto has run once, switching it off.", fromPlayer);
-            else
-                SendWhisper("Running Equip Auto once.", fromPlayer);
-
-            m_AutoEquipToggle = false;
-        }
-        else if (m_AutoEquipToggle)
-        {
-            SendWhisper("Equip Auto has run and is |h|cff1eff00ON|h|r", fromPlayer);
-        }
-        else
-            SendWhisper("Equip Auto is |h|cffff0000OFF|h|r", fromPlayer);
-        return;
-    }
-    else if (ExtractCommand("info", text))
-    {
-        m_AutoEquipToggle ?  SendWhisper("Auto Equip is |h|cff1eff00ON|h|r", fromPlayer) : SendWhisper("Auto Equip is |h|cffff0000OFF|h|r", fromPlayer);
-        return;
-    }
-
-    // handle 'equip' command, expected in the form of 'equip [ITEM(s)]'
-    std::list<uint32> itemIds;
-    std::list<Item*> itemList;
-    extractItemIds(text, itemIds);
-    findItemsInInv(itemIds, itemList);
-    for (std::list<Item*>::iterator it = itemList.begin(); it != itemList.end(); ++it)
-        EquipItem(*it);
-    SendNotEquipList(*m_bot);
-}
-
-void PlayerbotAI::_HandleCommandFind(std::string& text, Player& /*fromPlayer*/)
-{
-    extractGOinfo(text, m_lootTargets);
-
-    if (m_lootTargets.empty())
-        return;
-
-    m_lootCurrent = m_lootTargets.front();
-    m_lootTargets.pop_front();
-
-    GameObject* go = m_bot->GetMap()->GetGameObject(m_lootCurrent);
-    if (!go)
-    {
-        m_lootTargets.clear();
-        m_lootCurrent = ObjectGuid();
-        return;
-    }
-
-    SetMovementOrder(MOVEMENT_STAY);
-    m_bot->GetMotionMaster()->MovePoint(go->GetMapId(), go->GetPositionX(), go->GetPositionY(), go->GetPositionZ());
-    m_lootTargets.clear();
-    m_lootCurrent = ObjectGuid();
-}
-
-void PlayerbotAI::_HandleCommandGet(std::string& text, Player& fromPlayer)
-{
-    if (text != "")
-    {
-        extractGOinfo(text, m_lootTargets);
-        SetState(BOTSTATE_LOOTING);
-        return;
-    }
-
-    // get a selected lootable corpse
-    ObjectGuid getOnGuid = fromPlayer.GetSelectionGuid();
-    if (getOnGuid)
-    {
-        Creature* c = m_bot->GetMap()->GetCreature(getOnGuid);
-        if (!c)
-            return;
-
-        uint32 skillId = 0;
-        if (c->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE))
-            skillId = c->GetCreatureInfo()->GetRequiredLootSkill();
-
-        if (c->HasFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE) ||
-                (c->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE) && m_bot->HasSkill(skillId)))
-        {
-            m_lootTargets.push_back(getOnGuid);
-            SetState(BOTSTATE_LOOTING);
-        }
-        else
-            SendWhisper("Target is not lootable by me.", fromPlayer);
-    }
-    else
-    {
-        SendWhisper("No target is selected.", fromPlayer);
-        m_bot->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
-    }
-}
-
-void PlayerbotAI::_HandleCommandCollect(std::string& text, Player& fromPlayer)
-{
-    while (text.size() > 0)
-    {
-        if (ExtractCommand("combat", text))
-            SetCollectFlag(COLLECT_FLAG_COMBAT);
-        else if (ExtractCommand("loot", text))
-            SetCollectFlag(COLLECT_FLAG_LOOT);
-        else if (ExtractCommand("quest", text))
-            SetCollectFlag(COLLECT_FLAG_QUEST);
-        else if (ExtractCommand("profession", text) || ExtractCommand("skill", text))
-            SetCollectFlag(COLLECT_FLAG_PROFESSION);
-        else if (ExtractCommand("skin", text) && m_bot->HasSkill(SKILL_SKINNING)) // removes skin even if bot does not have skill
-            SetCollectFlag(COLLECT_FLAG_SKIN);
-        else if (ExtractCommand("objects", text) || ExtractCommand("nearby", text))
-        {
-            SetCollectFlag(COLLECT_FLAG_NEAROBJECT);
-            if (!HasCollectFlag(COLLECT_FLAG_NEAROBJECT))
-                m_collectObjects.clear();
-        }
-        else if (ExtractCommand("distance:", text))
-        {
-            uint32 distance;
-            sscanf(text.c_str(), "distance:%u", &distance);
-            if (distance > 0 && distance <= m_mgr->m_confCollectDistanceMax)
-            {
-                m_collectDist = distance;
-                std::ostringstream oss;
-                oss << "I will now collect items within " << m_collectDist << " yards.";
-                SendWhisper(oss.str(), fromPlayer);
-            }
-            else
-            {
-                m_collectDist = m_mgr->m_confCollectDistanceMax;
-                std::stringstream oss;
-                oss << "I will now collect items within " << m_mgr->m_confCollectDistanceMax << " yards. " << distance << " yards is just too far away.",
-                    SendWhisper(oss.str(), fromPlayer);
-            }
-        }
-        else if (ExtractCommand("none", text) || ExtractCommand("nothing", text))
-        {
-            m_collectionFlags = 0;
-            m_collectObjects.clear();
-            break;  // because none is an exclusive choice
-        }
-        else
-        {
-            std::ostringstream oss;
-            oss << "Collect <collectable(s)>: none | distance:<1-" << m_mgr->m_confCollectDistanceMax << ">, combat, loot, quest, profession, objects";
-            if (m_bot->HasSkill(SKILL_SKINNING))
-                oss << ", skin";
-            // TODO: perhaps change the command syntax, this way may be lacking in ease of use
-            SendWhisper(oss.str(), fromPlayer);
-            break;
-        }
-    }
-
-    std::string collset = "";
-    if (HasCollectFlag(COLLECT_FLAG_LOOT))
-        collset += ", all loot";
-    if (HasCollectFlag(COLLECT_FLAG_PROFESSION))
-        collset += ", profession";
-    if (HasCollectFlag(COLLECT_FLAG_QUEST))
-        collset += ", quest";
-    if (HasCollectFlag(COLLECT_FLAG_SKIN))
-        collset += ", skin";
-    if (collset.length() > 1)
-    {
-        if (HasCollectFlag(COLLECT_FLAG_COMBAT))
-            collset += " items after combat";
-        else
-            collset += " items";
-    }
-
-    if (HasCollectFlag(COLLECT_FLAG_NEAROBJECT))
-    {
-        if (collset.length() > 1)
-            collset += " and ";
-        else
-            collset += " ";    // padding for substr
-        collset += "nearby objects (";
-        if (!m_collectObjects.empty())
-        {
-            std::string strobjects = "";
-            for (BotEntryList::iterator itr = m_collectObjects.begin(); itr != m_collectObjects.end(); ++itr)
-            {
-                uint32 objectentry = *(itr);
-                GameObjectInfo const* gInfo = ObjectMgr::GetGameObjectInfo(objectentry);
-                strobjects += ", ";
-                strobjects += gInfo->name;
-            }
-            collset += strobjects.substr(2);
-        }
-        else
-            collset += "use survey and get to set";
-        collset += ")";
-    }
-
-    if (collset.length() > 1)
-        SendWhisper("I'm collecting " + collset.substr(2), fromPlayer);
-    else
-        SendWhisper("I'm collecting nothing.", fromPlayer);
-}
-
-void PlayerbotAI::_HandleCommandEnchant(std::string& text, Player& fromPlayer)
-{
-    // DEBUG_LOG("Enchant (%s)",text.c_str());
-
-    if (!m_bot->HasSkill(SKILL_ENCHANTING))
-    {
-        SendWhisper("|cffff0000I can't enchant, I don't have the skill.", fromPlayer);
-        return;
-    }
-
-    if (text.size() > 0)
-    {
-        uint32 spellId;
-        extractSpellId(text, spellId);
-
-        SpellEntry const* spellInfo = sSpellTemplate.LookupEntry<SpellEntry>(spellId);
-        if (!spellInfo)
-            return;
-
-        std::list<uint32> itemIds;
-        std::list<Item*> itemList;
-        extractItemIds(text, itemIds);
-        findItemsInEquip(itemIds, itemList);
-        findItemsInInv(itemIds, itemList);
-
-        if (itemList.empty())
-        {
-            SendWhisper("|cffff0000I can't enchant that!", fromPlayer);
-            return;
-        }
-
-        Item* iTarget = itemList.back();
-        itemList.pop_back();
-
-        if (iTarget)
-        {
-            SpellCastTargets targets;
-            targets.setItemTarget(iTarget);
-            Spell* spell = new Spell(m_bot, spellInfo, false);
-            spell->SpellStart(&targets);
-            SetState(BOTSTATE_DELAYED);
-            SetIgnoreUpdateTime(1);
-        }
-        return;
-    }
-    else
-    {
-        std::ostringstream msg;
-        uint32 charges;
-        uint32 linkcount = 0;
-
-        m_spellsToLearn.clear();
-        m_bot->skill(m_spellsToLearn);
-        SendWhisper("I can enchant:\n", fromPlayer);
-        ChatHandler ch(&fromPlayer);
-        for (std::list<uint32>::iterator it = m_spellsToLearn.begin(); it != m_spellsToLearn.end(); ++it)
-        {
-            SkillLineEntry const* SkillLine = sSkillLineStore.LookupEntry(*it);
-
-            if (SkillLine->categoryId == SKILL_CATEGORY_PROFESSION && *it == SKILL_ENCHANTING)
-            {
-                for (uint32 j = 0; j < sSkillLineAbilityStore.GetNumRows(); ++j)
-                {
-                    SkillLineAbilityEntry const* SkillAbility = sSkillLineAbilityStore.LookupEntry(j);
-                    if (!SkillAbility)
-                        continue;
-
-                    SpellEntry const* spellInfo = sSpellTemplate.LookupEntry<SpellEntry>(SkillAbility->spellId);
-                    if (!spellInfo)
-                        continue;
-
-                    if (IsPrimaryProfessionSkill(*it) && spellInfo->Effect[EFFECT_INDEX_0] != SPELL_EFFECT_ENCHANT_ITEM)
-                        continue;
-
-                    if (SkillAbility->skillId == *it && m_bot->HasSpell(SkillAbility->spellId) && SkillAbility->forward_spellid == 0 && ((SkillAbility->classmask & m_bot->getClassMask()) == 0))
-                    {
-                        MakeSpellLink(spellInfo, msg);
-                        ++linkcount;
-                        if ((charges = GetSpellCharges(SkillAbility->spellId)) > 0)
-                            msg << "[" << charges << "]";
-                        if (linkcount >= 10)
-                        {
-                            ch.SendSysMessage(msg.str().c_str());
-                            linkcount = 0;
-                            msg.str("");
-                        }
-                    }
-                }
-            }
-        }
-        m_noToolList.unique();
-        for (std::list<uint32>::iterator it = m_noToolList.begin(); it != m_noToolList.end(); it++)
-            HasTool(*it);
-        ch.SendSysMessage(msg.str().c_str());
-        m_noToolList.clear();
-        m_spellsToLearn.clear();
-    }
-}
-
-void PlayerbotAI::_HandleCommandCraft(std::string& text, Player& fromPlayer)
-{
-    DEBUG_LOG("Craft (%s)", text.c_str());
-
-    std::ostringstream msg;
-    uint32 charges;
-    uint32 skill;
-    int32 category;
-    uint32 linkcount = 0;
-    m_CraftSpellId = 0;
-
-    if (ExtractCommand("alchemy", text, true)) // true -> "craft alchemy" OR "craft a"
-    {
-        if (m_bot->HasSkill(SKILL_ALCHEMY))
-        {
-            skill = SKILL_ALCHEMY;
-            category = SKILL_CATEGORY_PROFESSION;
-        }
-        else
-            return;
-    }
-    else if (ExtractCommand("blacksmithing", text, true)) // true -> "craft blacksmithing" OR "craft b"
-    {
-        if (m_bot->HasSkill(SKILL_BLACKSMITHING))
-        {
-            skill = SKILL_BLACKSMITHING;
-            category = SKILL_CATEGORY_PROFESSION;
-        }
-        else
-            return;
-    }
-    else if (ExtractCommand("cooking", text, true)) // true -> "craft cooking" OR "craft c"
-    {
-        if (m_bot->HasSkill(SKILL_COOKING))
-        {
-            skill = SKILL_COOKING;
-            category = SKILL_CATEGORY_SECONDARY;
-        }
-        else
-            return;
-    }
-    else if (ExtractCommand("engineering", text, true)) // true -> "craft engineering" OR "craft e"
-    {
-        if (m_bot->HasSkill(SKILL_ENGINEERING))
-        {
-            skill = SKILL_ENGINEERING;
-            category = SKILL_CATEGORY_PROFESSION;
-        }
-        else
-            return;
-    }
-    else if (ExtractCommand("firstaid", text, true)) // true -> "craft firstaid" OR "craft f"
-    {
-        if (m_bot->HasSkill(SKILL_FIRST_AID))
-        {
-            skill = SKILL_FIRST_AID;
-            category = SKILL_CATEGORY_SECONDARY;
-        }
-        else
-            return;
-    }
-    else if (ExtractCommand("jewelcrafting", text, true)) // true -> "craft jewelcrafting" OR "craft j"
-    {
-        if (m_bot->HasSkill(SKILL_JEWELCRAFTING))
-        {
-            skill = SKILL_JEWELCRAFTING;
-            category = SKILL_CATEGORY_PROFESSION;
-        }
-        else
-            return;
-    }
-    else if (ExtractCommand("leatherworking", text, true)) // true -> "craft leatherworking" OR "craft l"
-    {
-        if (m_bot->HasSkill(SKILL_LEATHERWORKING))
-        {
-            skill = SKILL_LEATHERWORKING;
-            category = SKILL_CATEGORY_PROFESSION;
-        }
-        else
-            return;
-    }
-    else if (ExtractCommand("magic", text, true)) // true -> "craft magic" OR "craft m"
-    {
-        if (m_bot->HasSkill(SKILL_ENCHANTING))
-        {
-            skill = SKILL_ENCHANTING;
-            category = SKILL_CATEGORY_PROFESSION;
-        }
-        else
-            return;
-    }
-    else if (ExtractCommand("smelting", text, true)) // true -> "craft smelting" OR "craft s"
-    {
-        if (m_bot->HasSkill(SKILL_MINING))
-        {
-            skill = SKILL_MINING;
-            category = SKILL_CATEGORY_PROFESSION;
-        }
-        else
-            return;
-    }
-    else if (ExtractCommand("tailoring", text, true)) // true -> "craft tailoring" OR "craft t"
-    {
-        if (m_bot->HasSkill(SKILL_TAILORING))
-        {
-            skill = SKILL_TAILORING;
-            category = SKILL_CATEGORY_PROFESSION;
-        }
-        else
-            return;
-    }
-    else
-    {
-        uint32 spellId;
-        extractSpellId(text, spellId);
-
-        if (!m_bot->HasSpell(spellId))
-        {
-            SendWhisper("|cffff0000I don't have that spell.", fromPlayer);
-            return;
-        }
-
-        SpellEntry const* spellInfo = sSpellTemplate.LookupEntry<SpellEntry>(spellId);
-        if (!spellInfo)
-            return;
-
-        SpellCastTargets targets;
-        Spell* spell = new Spell(m_bot, spellInfo, false);
-
-        if (text.find("all", 0) != std::string::npos)
-        {
-            SpellCastResult result = spell->CheckCast(true);
-
-            if (result != SPELL_CAST_OK)
-            {
-                spell->SendCastResult(result);
-            }
-            else
-            {
-                spell->SpellStart(&targets);
-                m_CraftSpellId = spellId;
-                SetState(BOTSTATE_DELAYED);
-                SetIgnoreUpdateTime(6);
-            }
-        }
-        else
-            spell->SpellStart(&targets);
-        return;
-    }
-
-    m_spellsToLearn.clear();
-    m_bot->skill(m_spellsToLearn);
-    SendWhisper("I can create:\n", fromPlayer);
-    ChatHandler ch(&fromPlayer);
-    for (std::list<uint32>::iterator it = m_spellsToLearn.begin(); it != m_spellsToLearn.end(); ++it)
-    {
-        SkillLineEntry const* SkillLine = sSkillLineStore.LookupEntry(*it);
-
-        if (SkillLine->categoryId == category && *it == skill)
-        {
-            for (uint32 j = 0; j < sSkillLineAbilityStore.GetNumRows(); ++j)
-            {
-                SkillLineAbilityEntry const* SkillAbility = sSkillLineAbilityStore.LookupEntry(j);
-                if (!SkillAbility)
-                    continue;
-
-                SpellEntry const* spellInfo = sSpellTemplate.LookupEntry<SpellEntry>(SkillAbility->spellId);
-                if (!spellInfo)
-                    continue;
-
-                if (IsPrimaryProfessionSkill(*it) && spellInfo->Effect[EFFECT_INDEX_0] != SPELL_EFFECT_CREATE_ITEM)
-                    continue;
-
-                if (SkillAbility->skillId == *it && m_bot->HasSpell(SkillAbility->spellId) && SkillAbility->forward_spellid == 0 && ((SkillAbility->classmask & m_bot->getClassMask()) == 0))
-                {
-                    MakeSpellLink(spellInfo, msg);
-                    ++linkcount;
-                    if ((charges = GetSpellCharges(SkillAbility->spellId)) > 0)
-                        msg << "[" << charges << "]";
-                    if (linkcount >= 10)
-                    {
-                        ch.SendSysMessage(msg.str().c_str());
-                        linkcount = 0;
-                        msg.str("");
-                    }
-                }
-            }
-        }
-    }
-    m_noToolList.unique();
-    for (std::list<uint32>::iterator it = m_noToolList.begin(); it != m_noToolList.end(); it++)
-        HasTool(*it);
-    ch.SendSysMessage(msg.str().c_str());
-    m_noToolList.clear();
-    m_spellsToLearn.clear();
-}
-
-void PlayerbotAI::_HandleCommandQuest(std::string& text, Player& fromPlayer)
-{
-    std::ostringstream msg;
-
-    if (ExtractCommand("add", text, true)) // true -> "quest add" OR "quest a"
-    {
-        FollowAutoReset();
-        std::list<uint32> questIds;
-        extractQuestIds(text, questIds);
-        for (std::list<uint32>::iterator it = questIds.begin(); it != questIds.end(); it++)
-            m_tasks.push_back(std::pair<enum TaskFlags, uint32>(TAKE_QUEST, *it));
-        m_findNPC.push_back(UNIT_NPC_FLAG_QUESTGIVER);
-    }
-    else if (ExtractCommand("drop", text, true)) // true -> "quest drop" OR "quest d"
-    {
-        fromPlayer.SetSelectionGuid(m_bot->GetObjectGuid());
-        PlayerbotChatHandler ch(GetMaster());
-        int8 linkStart = text.find("|");
-        if (text.find("|") != std::string::npos)
-        {
-            if (!ch.dropQuest((char*) text.substr(linkStart).c_str()))
-            {
-                ch.sysmessage("ERROR: could not drop quest");
-            }
-            else
-            {
-                SetQuestNeedItems();
-                SetQuestNeedCreatures();
-            }
-        }
-    }
-    else if (ExtractCommand("fetch", text, true)) // true -> "quest fetch"
-    {
-        FollowAutoReset();
-        gQuestFetch = 1;
-        m_tasks.push_back(std::pair<enum TaskFlags, uint32>(LIST_QUEST, 0));
-        m_findNPC.push_back(UNIT_NPC_FLAG_QUESTGIVER);
-    }
-    else if (ExtractCommand("list", text, true)) // true -> "quest list" OR "quest l"
-    {
-        FollowAutoReset();
-        m_tasks.push_back(std::pair<enum TaskFlags, uint32>(LIST_QUEST, 0));
-        m_findNPC.push_back(UNIT_NPC_FLAG_QUESTGIVER);
-    }
-    else if (ExtractCommand("report", text))
-    {
-        SendQuestNeedList();
-    }
-    else if (ExtractCommand("end", text, true)) // true -> "quest end" OR "quest e"
-    {
-        FollowAutoReset();
-        m_tasks.push_back(std::pair<enum TaskFlags, uint32>(END_QUEST, 0));
-        m_findNPC.push_back(UNIT_NPC_FLAG_QUESTGIVER);
-    }
-    else
-    {
-        bool hasIncompleteQuests = false;
-        std::ostringstream incomout;
-        incomout << "my incomplete quests are:";
-        bool hasCompleteQuests = false;
-        std::ostringstream comout;
-        comout << "my complete quests are:";
-        for (int slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
-        {
-            if (uint32 questId = m_bot->GetQuestSlotQuestId(slot))
-            {
-                Quest const* pQuest = sObjectMgr.GetQuestTemplate(questId);
-
-                std::string questTitle  = pQuest->GetTitle();
-                m_bot->GetPlayerbotAI()->QuestLocalization(questTitle, questId);
-
-                if (m_bot->GetQuestStatus(questId) == QUEST_STATUS_COMPLETE)
-                {
-                    hasCompleteQuests = true;
-                    comout << " |cFFFFFF00|Hquest:" << questId << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
-                }
-                else
-                {
-                    Item* qitem = FindItem(pQuest->GetSrcItemId());
-                    if (qitem)
-                        incomout << " use " << "|cffffffff|Hitem:" << qitem->GetProto()->ItemId << ":0:0:0:0:0:0:0" << "|h[" << qitem->GetProto()->Name1 << "]|h|r" << " on ";
-                    hasIncompleteQuests = true;
-                    incomout << " |cFFFFFF00|Hquest:" << questId << ':' << pQuest->GetQuestLevel() << "|h[" <<  questTitle << "]|h|r";
-                }
-            }
-        }
-        if (hasCompleteQuests)
-            SendWhisper(comout.str(), fromPlayer);
-        if (hasIncompleteQuests)
-            SendWhisper(incomout.str(), fromPlayer);
-        if (!hasCompleteQuests && !hasIncompleteQuests)
-            SendWhisper("I have no quests.", fromPlayer);
-    }
-}
-
-void PlayerbotAI::_HandleCommandPet(std::string& text, Player& fromPlayer)
-{
-    if (ExtractCommand("tame", text))
-    {
-        if (m_bot->GetPetGuid())
-        {
-            SendWhisper("I already have a pet!", fromPlayer);
-            return;
-        }
-
-        ObjectGuid castOnGuid = fromPlayer.GetSelectionGuid();
-        if (castOnGuid && m_bot->HasSpell(TAME_BEAST_1))
-        {
-            if (ASPECT_OF_THE_MONKEY > 0 && !m_bot->HasAura(ASPECT_OF_THE_MONKEY, EFFECT_INDEX_0))
-                CastSpell(ASPECT_OF_THE_MONKEY, *m_bot);
-            m_targetGuidCommand = castOnGuid;
-            SetState(BOTSTATE_TAME);
-        }
-        else
-            SendWhisper("I can't tame that!", fromPlayer);
-        return;
-    }
-
-    Pet* pet = m_bot->GetPet();
-    if (!pet)
-    {
-        SendWhisper("I have no pet.", fromPlayer);
-        return;
-    }
-
-    if (ExtractCommand("abandon", text))
-    {
-        // abandon pet
-        std::unique_ptr<WorldPacket> packet(new WorldPacket(CMSG_PET_ABANDON, 8));
-        *packet << pet->GetObjectGuid();
-        m_bot->GetSession()->QueuePacket(std::move(packet));
-
-    }
-    else if (ExtractCommand("react", text))
-    {
-        if (ExtractCommand("aggressive", text, true))
-            pet->AI()->SetReactState(REACT_AGGRESSIVE);
-        else if (ExtractCommand("defensive", text, true))
-            pet->AI()->SetReactState(REACT_DEFENSIVE);
-        else if (ExtractCommand("passive", text, true))
-            pet->AI()->SetReactState(REACT_PASSIVE);
-        else
-            _HandleCommandHelp("pet react", fromPlayer);
-    }
-    else if (ExtractCommand("state", text))
-    {
-        if (text != "")
-        {
-            SendWhisper("'pet state' does not support subcommands.", fromPlayer);
-            return;
-        }
-
-        std::string state;
-        switch (pet->GetCharmInfo()->GetAI()->GetReactState())
-        {
-            case REACT_AGGRESSIVE:
-                SendWhisper("My pet is aggressive.", fromPlayer);
-                break;
-            case REACT_DEFENSIVE:
-                SendWhisper("My pet is defensive.", fromPlayer);
-                break;
-            case REACT_PASSIVE:
-                SendWhisper("My pet is passive.", fromPlayer);
-        }
-    }
-    else if (ExtractCommand("cast", text))
-    {
-        if (text == "")
-        {
-            _HandleCommandHelp("pet cast", fromPlayer);
-            return;
-        }
-
-        uint32 spellId = (uint32) atol(text.c_str());
-
-        if (spellId == 0)
-        {
-            spellId = getPetSpellId(text.c_str());
-            if (spellId == 0)
-                extractSpellId(text, spellId);
-        }
-
-        if (spellId != 0 && pet->HasSpell(spellId))
-        {
-            if (pet->HasAura(spellId))
-            {
-                pet->RemoveAurasByCasterSpell(spellId, pet->GetObjectGuid());
-                return;
-            }
-
-            ObjectGuid castOnGuid = fromPlayer.GetSelectionGuid();
-            Unit* pTarget = ObjectAccessor::GetUnit(*m_bot, castOnGuid);
-            CastPetSpell(spellId, pTarget);
-        }
-    }
-    else if (ExtractCommand("toggle", text))
-    {
-        if (text == "")
-        {
-            _HandleCommandHelp("pet toggle", fromPlayer);
-            return;
-        }
-
-        uint32 spellId = (uint32) atol(text.c_str());
-
-        if (spellId == 0)
-        {
-            spellId = getPetSpellId(text.c_str());
-            if (spellId == 0)
-                extractSpellId(text, spellId);
-        }
-
-        if (spellId != 0 && pet->HasSpell(spellId))
-        {
-            PetSpellMap::iterator itr = pet->m_spells.find(spellId);
-            if (itr != pet->m_spells.end())
-            {
-                if (itr->second.active == ACT_ENABLED)
-                {
-                    pet->ToggleAutocast(spellId, false);
-                    if (pet->HasAura(spellId))
-                        pet->RemoveAurasByCasterSpell(spellId, pet->GetObjectGuid());
-                }
-                else
-                    pet->ToggleAutocast(spellId, true);
-            }
-        }
-    }
-    else if (ExtractCommand("spells", text))
-    {
-        if (text != "")
-        {
-            SendWhisper("'pet spells' does not support subcommands.", fromPlayer);
-            return;
-        }
-
-        int loc = GetMaster()->GetSession()->GetSessionDbcLocale();
-
-        std::ostringstream posOut;
-        std::ostringstream negOut;
-
-        for (PetSpellMap::iterator itr = pet->m_spells.begin(); itr != pet->m_spells.end(); ++itr)
-        {
-            const uint32 spellId = itr->first;
-
-            if (itr->second.state == PETSPELL_REMOVED || IsPassiveSpell(spellId))
-                continue;
-
-            const SpellEntry* const pSpellInfo = sSpellTemplate.LookupEntry<SpellEntry>(spellId);
-            if (!pSpellInfo)
-                continue;
-
-            std::string color;
-            switch (itr->second.active)
-            {
-                case ACT_ENABLED:
-                    color = "cff35d22d"; // Some flavor of green
-                    break;
-                default:
-                    color = "cffffffff";
-            }
-
-            if (IsPositiveSpell(spellId))
-                posOut << " |" << color << "|Hspell:" << spellId << "|h["
-                       << pSpellInfo->SpellName[loc] << "]|h|r";
-            else
-                negOut << " |" << color << "|Hspell:" << spellId << "|h["
-                       << pSpellInfo->SpellName[loc] << "]|h|r";
-        }
-
-        ChatHandler ch(&fromPlayer);
-        SendWhisper("Here's my pet's non-attack spells:", fromPlayer);
-        ch.SendSysMessage(posOut.str().c_str());
-        SendWhisper("and here's my pet's attack spells:", fromPlayer);
-        ch.SendSysMessage(negOut.str().c_str());
-    }
-}
-
-void PlayerbotAI::_HandleCommandSpells(std::string& /*text*/, Player& fromPlayer)
-{
-    int loc = GetMaster()->GetSession()->GetSessionDbcLocale();
-
-    std::ostringstream posOut;
-    std::ostringstream negOut;
-
-    typedef std::map<std::string, uint32> spellMap;
-
-    spellMap posSpells, negSpells;
-    std::string spellName;
-
-    uint32 ignoredSpells[] = {1843, 5019, 2479, 6603, 3365, 8386, 21651, 21652, 6233, 6246, 6247,
-                              61437, 22810, 22027, 45927, 7266, 7267, 6477, 6478, 7355, 68398
-                             };
-    uint32 ignoredSpellsCount = sizeof(ignoredSpells) / sizeof(uint32);
-
-    for (PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
-    {
-        const uint32 spellId = itr->first;
-
-        if (itr->second.state == PLAYERSPELL_REMOVED || itr->second.disabled || IsPassiveSpell(spellId))
-            continue;
-
-        const SpellEntry* const pSpellInfo = sSpellTemplate.LookupEntry<SpellEntry>(spellId);
-        if (!pSpellInfo)
-            continue;
-
-        spellName = pSpellInfo->SpellName[loc];
-
-        SkillLineAbilityMapBounds const bounds = sSpellMgr.GetSkillLineAbilityMapBoundsBySpellId(spellId);
-
-        bool isProfessionOrRidingSpell = false;
-        for (SkillLineAbilityMap::const_iterator skillIter = bounds.first; skillIter != bounds.second; ++skillIter)
-        {
-            if (IsProfessionOrRidingSkill(skillIter->second->skillId) && skillIter->first == spellId)
-            {
-                isProfessionOrRidingSpell = true;
-                break;
-            }
-        }
-        if (isProfessionOrRidingSpell)
-            continue;
-
-        bool isIgnoredSpell = false;
-        for (uint8 i = 0; i < ignoredSpellsCount; ++i)
-        {
-            if (spellId == ignoredSpells[i])
-            {
-                isIgnoredSpell = true;
-                break;
-            }
-        }
-        if (isIgnoredSpell)
-            continue;
-
-        if (IsPositiveSpell(spellId))
-        {
-            if (posSpells.find(spellName) == posSpells.end())
-                posSpells[spellName] = spellId;
-            else if (posSpells[spellName] < spellId)
-                posSpells[spellName] = spellId;
-        }
-        else
-        {
-            if (negSpells.find(spellName) == negSpells.end())
-                negSpells[spellName] = spellId;
-            else if (negSpells[spellName] < spellId)
-                negSpells[spellName] = spellId;
-        }
-    }
-
-    for (spellMap::const_iterator iter = posSpells.begin(); iter != posSpells.end(); ++iter)
-    {
-        posOut << " |cffffffff|Hspell:" << iter->second << "|h[" << iter->first << "]|h|r";
-    }
-
-    for (spellMap::const_iterator iter = negSpells.begin(); iter != negSpells.end(); ++iter)
-    {
-        negOut << " |cffffffff|Hspell:" << iter->second << "|h[" << iter->first << "]|h|r";
-    }
-
-    ChatHandler ch(&fromPlayer);
-    SendWhisper("here's my non-attack spells:", fromPlayer);
-    ch.SendSysMessage(posOut.str().c_str());
-    SendWhisper("and here's my attack spells:", fromPlayer);
-    ch.SendSysMessage(negOut.str().c_str());
-}
-
-void PlayerbotAI::_HandleCommandSurvey(std::string& /*text*/, Player& fromPlayer)
-{
-    uint32 count = 0;
-    std::ostringstream detectout;
-    QueryResult* result;
-    GameEventMgr::ActiveEvents const& activeEventsList = sGameEventMgr.GetActiveEventList();
-    std::ostringstream eventFilter;
-    eventFilter << " AND (event IS NULL ";
-    bool initString = true;
-
-    for (GameEventMgr::ActiveEvents::const_iterator itr = activeEventsList.begin(); itr != activeEventsList.end(); ++itr)
-    {
-        if (initString)
-        {
-            eventFilter <<  "OR event IN (" << *itr;
-            initString = false;
-        }
-        else
-            eventFilter << "," << *itr;
-    }
-
-    if (!initString)
-        eventFilter << "))";
-    else
-        eventFilter << ")";
-
-    result = WorldDatabase.PQuery("SELECT gameobject.guid, id, position_x, position_y, position_z, map, "
-                                  "(POW(position_x - %f, 2) + POW(position_y - %f, 2) + POW(position_z - %f, 2)) AS order_ FROM gameobject "
-                                  "LEFT OUTER JOIN game_event_gameobject on gameobject.guid=game_event_gameobject.guid WHERE map = '%i' %s ORDER BY order_ ASC LIMIT 10",
-                                  m_bot->GetPositionX(), m_bot->GetPositionY(), m_bot->GetPositionZ(), m_bot->GetMapId(), eventFilter.str().c_str());
-
-    if (result)
-    {
-        do
-        {
-            Field* fields = result->Fetch();
-            uint32 guid = fields[0].GetUInt32();
-            uint32 entry = fields[1].GetUInt32();
-
-            GameObject* go = m_bot->GetMap()->GetGameObject(ObjectGuid(HIGHGUID_GAMEOBJECT, entry, guid));
-            if (!go)
-                continue;
-
-            if (!go->IsSpawned())
-                continue;
-
-            detectout << "|cFFFFFF00|Hfound:" << guid << ":" << entry  << ":" <<  "|h[" << go->GetGOInfo()->name << "]|h|r";
-            ++count;
-        }
-        while (result->NextRow());
-
-        delete result;
-    }
-    SendWhisper(detectout.str().c_str(), fromPlayer);
-}
-
-// _HandleCommandSkill: Handle class & professions training:
-// skill                           -- Lists bot(s) Primary profession skills & weapon skills
-// skill learn                     -- List available class or profession (Primary or Secondary) skills, spells & abilities from selected trainer.
-// skill learn all                 -- Learn all skills and spells available from selected trainer.
-// skill learn [HLINK][HLINK] ..   -- Learn selected skill and spells, from selected trainer ([HLINK] from skill learn).
-// skill unlearn [HLINK][HLINK] .. -- Unlearn selected primary profession skill(s) and all associated spells ([HLINK] from skill)
-void PlayerbotAI::_HandleCommandSkill(std::string& text, Player& fromPlayer)
-{
-    uint32 rank[8] = {0, 75, 150, 225, 300, 375, 450, 525};
-
-    std::ostringstream msg;
-    if (ExtractCommand("learn", text))
-    {
-        uint32 totalCost = 0;
-
-        Unit* unit = ObjectAccessor::GetUnit(*m_bot, fromPlayer.GetSelectionGuid());
-        if (!unit)
-        {
-            SendWhisper("Please select the trainer!", fromPlayer);
-            return;
-        }
-
-        if (!unit->isTrainer())
-        {
-            SendWhisper("This is not a trainer!", fromPlayer);
-            return;
-        }
-
-        Creature* creature =  m_bot->GetMap()->GetCreature(fromPlayer.GetSelectionGuid());
-        if (!creature)
-            return;
-
-        if (!creature->IsTrainerOf(m_bot, false))
-        {
-            SendWhisper("This trainer can not teach me anything!", fromPlayer);
-            return;
-        }
-
-        // check present spell in trainer spell list
-        TrainerSpellData const* cSpells = creature->GetTrainerSpells();
-        TrainerSpellData const* tSpells = creature->GetTrainerTemplateSpells();
-        TrainerSpellMap allSpells;
-
-        if (cSpells && tSpells)
-        {
-            allSpells.insert(cSpells->spellList.begin(), cSpells->spellList.end());
-            allSpells.insert(tSpells->spellList.begin(), tSpells->spellList.end());
-        }
-        else if (cSpells)
-            allSpells.insert(cSpells->spellList.begin(), cSpells->spellList.end());
-        else if (tSpells)
-            allSpells.insert(tSpells->spellList.begin(), tSpells->spellList.end());
-        else
-        {
-            SendWhisper("No spells can be learnt from this trainer", fromPlayer);
-            return;
-        }
-
-        // reputation discount
-        float fDiscountMod =  m_bot->GetReputationPriceDiscount(creature);
-
-        // Handle: Learning class or profession (primary or secondary) skill & spell(s) for selected trainer, skill learn [HLINK][HLINK][HLINK].. ([HLINK] from skill train)
-        if (text.size() > 0)
-        {
-            msg << "I have learned the following spells:\n";
-            uint32 totalSpellLearnt = 0;
-            bool visuals = true;
-            m_spellsToLearn.clear();
-            if (ExtractCommand("all", text))
-            {
-                for (TrainerSpellMap::const_iterator itr =  allSpells.begin(); itr !=  allSpells.end(); ++itr)
-                {
-                    TrainerSpell const* trainer_spell = &itr->second;
-
-                    uint32 spellId = trainer_spell->spell;
-
-                    if (!spellId)
-                        break;
-
-                    // apply reputation discount
-                    uint32 cost = uint32(floor(trainer_spell->spellCost * fDiscountMod));
-                    if (!_HandleCommandSkillLearnHelper(trainer_spell, spellId, cost))
-                        continue;
-
-                    ++totalSpellLearnt;
-                    totalCost += cost;
-                    const SpellEntry* const pSpellInfo =  sSpellTemplate.LookupEntry<SpellEntry>(spellId);
-                    if (!pSpellInfo)
-                        continue;
-
-                    if (visuals)
-                    {
-                        visuals = false;
-                        WorldPacket data(SMSG_PLAY_SPELL_VISUAL, 12);           // visual effect on trainer
-                        data << ObjectGuid(fromPlayer.GetSelectionGuid());
-                        data << uint32(0xB3);                                   // index from SpellVisualKit.dbc
-                        GetMaster()->GetSession()->SendPacket(data);
-
-                        data.Initialize(SMSG_PLAY_SPELL_IMPACT, 12);            // visual effect on player
-                        data << m_bot->GetObjectGuid();
-                        data << uint32(0x016A);                                 // index from SpellVisualKit.dbc
-                        GetMaster()->GetSession()->SendPacket(data);
-                    }
-
-                    WorldPacket data(SMSG_TRAINER_BUY_SUCCEEDED, 12);
-                    data << ObjectGuid(fromPlayer.GetSelectionGuid());
-                    data << uint32(spellId);                                // should be same as in packet from client
-                    GetMaster()->GetSession()->SendPacket(data);
-                    MakeSpellLink(pSpellInfo, msg);
-                    msg << " ";
-                    msg << Cash(cost) << " ";
-                }
-            }
-            else
-            {
-                extractSpellIdList(text, m_spellsToLearn);
-
-                for (std::list<uint32>::iterator it = m_spellsToLearn.begin(); it != m_spellsToLearn.end(); it++)
-                {
-                    uint32 spellId = *it;
-
-                    if (!spellId)
-                        break;
-
-                    // Try find spell in npc_trainer
-                    TrainerSpell const* trainer_spell = cSpells ? cSpells->Find(spellId) : nullptr;
-
-                    // Not found, try find in npc_trainer_template
-                    if (!trainer_spell && tSpells)
-                        trainer_spell = tSpells->Find(spellId);
-
-                    // apply reputation discount
-                    uint32 cost = uint32(floor(trainer_spell->spellCost * fDiscountMod));
-
-                    if (!_HandleCommandSkillLearnHelper(trainer_spell, spellId, cost))
-                        continue;
-
-                    ++totalSpellLearnt;
-                    totalCost += cost;
-                    const SpellEntry* const pSpellInfo =  sSpellTemplate.LookupEntry<SpellEntry>(spellId);
-                    if (!pSpellInfo)
-                        continue;
-
-                    if (visuals)
-                    {
-                        visuals = false;
-                        WorldPacket data(SMSG_PLAY_SPELL_VISUAL, 12);           // visual effect on trainer
-                        data << ObjectGuid(fromPlayer.GetSelectionGuid());
-                        data << uint32(0xB3);                                   // index from SpellVisualKit.dbc
-                        GetMaster()->GetSession()->SendPacket(data);
-
-                        data.Initialize(SMSG_PLAY_SPELL_IMPACT, 12);            // visual effect on player
-                        data << m_bot->GetObjectGuid();
-                        data << uint32(0x016A);                                 // index from SpellVisualKit.dbc
-                        GetMaster()->GetSession()->SendPacket(data);
-                    }
-
-                    WorldPacket data(SMSG_TRAINER_BUY_SUCCEEDED, 12);
-                    data << ObjectGuid(fromPlayer.GetSelectionGuid());
-                    data << uint32(spellId);                                // should be same as in packet from client
-                    GetMaster()->GetSession()->SendPacket(data);
-                    MakeSpellLink(pSpellInfo, msg);
-                    msg << " ";
-                    msg << Cash(cost) << " ";
-                }
-            }
-            ReloadAI();
-            if (totalSpellLearnt == 0) msg.clear();
-            else msg << "\n";
-            msg << "Total of " << totalSpellLearnt << " spell";
-            if (totalSpellLearnt != 1) msg << "s";
-            msg << " learnt, ";
-            msg << Cash(totalCost) << " spent.";
-        }
-        // Handle: List class or profession skills, spells & abilities for selected trainer
-        else
-        {
-            msg << "The spells I can learn and their cost:\r";
-
-            for (TrainerSpellMap::const_iterator itr =  allSpells.begin(); itr !=  allSpells.end(); ++itr)
-            {
-                TrainerSpell const* tSpell = &itr->second;
-
-                if (!tSpell)
-                    break;
-
-                uint32 reqLevel = 0;
-                if (!tSpell->learnedSpell && !m_bot->IsSpellFitByClassAndRace(tSpell->learnedSpell, &reqLevel))
-                    continue;
-
-                if (sSpellMgr.IsPrimaryProfessionFirstRankSpell(tSpell->learnedSpell) && m_bot->HasSpell(tSpell->learnedSpell))
-                    continue;
-
-                reqLevel = tSpell->isProvidedReqLevel ? tSpell->reqLevel : std::max(reqLevel, tSpell->reqLevel);
-
-                TrainerSpellState state =  m_bot->GetTrainerSpellState(tSpell, reqLevel);
-                if (state != TRAINER_SPELL_GREEN)
-                    continue;
-
-                uint32 spellId = tSpell->spell;
-                const SpellEntry* const pSpellInfo =  sSpellTemplate.LookupEntry<SpellEntry>(spellId);
-                if (!pSpellInfo)
-                    continue;
-                uint32 cost = uint32(floor(tSpell->spellCost *  fDiscountMod));
-                totalCost += cost;
-                MakeSpellLink(pSpellInfo, msg);
-                msg << " ";
-                msg << Cash(cost) << " ";
-            }
-
-            if (totalCost == 0)
-            {
-                msg.clear();
-                msg << "I have learned all I can from this trainer. Perhaps I can learn more once I grow stronger.";
-            }
-            else
-            {
-                int32 moneyDiff = m_bot->GetMoney() - totalCost;
-                if (moneyDiff >= 0)
-                    msg << "\n" << Cash(moneyDiff) << " left after learning all the spells.";
-                else
-                {
-                    Announce(CANT_AFFORD);
-                    moneyDiff *= -1;
-                    msg << "\nI need " << Cash(moneyDiff) << " more to learn all the spells!";
-                }
-            }
-        }
-    }
-    // Handle: Unlearning selected primary profession skill(s) and all associated spells, skill unlearn [HLINK][HLINK].. ([HLINK] from skill)
-    else if (ExtractCommand("unlearn", text))
-    {
-        m_spellsToLearn.clear();
-        extractSpellIdList(text, m_spellsToLearn);
-        for (std::list<uint32>::iterator it = m_spellsToLearn.begin(); it != m_spellsToLearn.end(); ++it)
-        {
-            if (sSpellMgr.IsPrimaryProfessionSpell(*it))
-            {
-                SpellLearnSkillNode const* spellLearnSkill = sSpellMgr.GetSpellLearnSkill(*it);
-
-                uint32 prev_spell = sSpellMgr.GetPrevSpellInChain(*it);
-                if (!prev_spell)                                    // first rank, remove skill
-                    GetPlayer()->SetSkill(spellLearnSkill->skill, 0, 0);
-                else
-                {
-                    // search prev. skill setting by spell ranks chain
-                    SpellLearnSkillNode const* prevSkill = sSpellMgr.GetSpellLearnSkill(prev_spell);
-                    while (!prevSkill && prev_spell)
-                    {
-                        prev_spell = sSpellMgr.GetPrevSpellInChain(prev_spell);
-                        prevSkill = sSpellMgr.GetSpellLearnSkill(sSpellMgr.GetFirstSpellInChain(prev_spell));
-                    }
-                    if (!prevSkill)                                 // not found prev skill setting, remove skill
-                        GetPlayer()->SetSkill(spellLearnSkill->skill, 0, 0);
-                }
-            }
-        }
-    }
-    // Handle: Lists bot(s) primary profession skills & weapon skills.
-    else
-    {
-        m_spellsToLearn.clear();
-        m_bot->skill(m_spellsToLearn);
-        msg << "My Primary Professions: ";
-        for (std::list<uint32>::iterator it = m_spellsToLearn.begin(); it != m_spellsToLearn.end(); ++it)
-        {
-            if (IsPrimaryProfessionSkill(*it))
-                for (uint32 j = 0; j < sSkillLineAbilityStore.GetNumRows(); ++j)
-                {
-                    SkillLineAbilityEntry const* skillLine = sSkillLineAbilityStore.LookupEntry(j);
-                    if (!skillLine)
-                        continue;
-
-                    // has skill
-                    if (skillLine->skillId == *it && skillLine->learnOnGetSkill == 0)
-                    {
-                        uint32 SpellId;
-                        m_bot->HasSpell(skillLine->forward_spellid) ? SpellId = skillLine->forward_spellid : SpellId = skillLine->spellId;
-
-                        SpellEntry const* spellInfo = sSpellTemplate.LookupEntry<SpellEntry>(SpellId);
-                        if (!spellInfo)
-                            continue;
-
-                        if (m_bot->GetSkillValue(*it) <= rank[sSpellMgr.GetSpellRank(SpellId)] && m_bot->HasSpell(SpellId))
-                        {
-                            // DEBUG_LOG ("[PlayerbotAI]: HandleCommand - skill (%u)(%u)(%u):",skillLine->spellId, rank[sSpellMgr.GetSpellRank(skillLine->spellId)], m_bot->GetSkillValue(*it));
-                            msg << "\n[" << m_bot->GetSkillValue(*it) << " / " << rank[sSpellMgr.GetSpellRank(SpellId)] << "]: ";
-                            MakeSpellLink(spellInfo, msg);
-                            break;
-                        }
-                    }
-                }
-        }
-
-        msg << "\nMy Weapon skills: ";
-        for (std::list<uint32>::iterator it = m_spellsToLearn.begin(); it != m_spellsToLearn.end(); ++it)
-        {
-            SkillLineEntry const* SkillLine = sSkillLineStore.LookupEntry(*it);
-            // has weapon skill
-            if (SkillLine->categoryId == SKILL_CATEGORY_WEAPON)
-            {
-                for (uint32 j = 0; j < sSkillLineAbilityStore.GetNumRows(); ++j)
-                {
-                    SkillLineAbilityEntry const* skillLine = sSkillLineAbilityStore.LookupEntry(j);
-                    if (!skillLine)
-                        continue;
-
-                    SpellEntry const* spellInfo = sSpellTemplate.LookupEntry<SpellEntry>(skillLine->spellId);
-                    if (!spellInfo)
-                        continue;
-
-                    if (skillLine->skillId == *it && spellInfo->Effect[0] == SPELL_EFFECT_WEAPON)
-                        MakeWeaponSkillLink(spellInfo, msg, *it);
-                }
-            }
-        }
-    }
-    SendWhisper(msg.str(), fromPlayer);
-    m_spellsToLearn.clear();
-    m_bot->GetPlayerbotAI()->GetClassAI();
-}
-
-bool PlayerbotAI::_HandleCommandSkillLearnHelper(TrainerSpell const* tSpell, uint32 spellId, uint32 cost)
-{
-    // Not found anywhere, cheating?
-    if (!tSpell)
-        return false;
-
-    uint32 reqLevel = 0;
-    if (!tSpell->learnedSpell && !m_bot->IsSpellFitByClassAndRace(tSpell->learnedSpell, &reqLevel))
-        return false;
-
-    if (sSpellMgr.IsPrimaryProfessionFirstRankSpell(tSpell->learnedSpell) && m_bot->HasSpell(tSpell->learnedSpell))
-        return false;
-
-    reqLevel = tSpell->isProvidedReqLevel ? tSpell->reqLevel : std::max(reqLevel, tSpell->reqLevel);
-
-    TrainerSpellState state =  m_bot->GetTrainerSpellState(tSpell, reqLevel);
-    if (state != TRAINER_SPELL_GREEN)
-        return false;
-
-    // check money requirement
-    if (m_bot->GetMoney() < cost)
-    {
-        Announce(CANT_AFFORD);
-        return false;
-    }
-
-    m_bot->ModifyMoney(-int32(cost));
-    // learn explicitly
-    m_bot->learnSpell(spellId, false);
-
-    return true;
-}
-
-void PlayerbotAI::_HandleCommandStats(std::string& text, Player& fromPlayer)
-{
-    if (text != "")
-    {
-        SendWhisper("'stats' does not have subcommands", fromPlayer);
-        return;
-    }
-
-    std::ostringstream out;
-
-    uint32 totalfree = GetFreeBagSpace();
-
-    // estimate how much item damage the bot has
-    out << "|cffffffff[|h|cff00ffff" << m_bot->GetName() << "|h|cffffffff] has |cff00ff00";
-    out << totalfree << " |h|cffffffff bag slots,|h" << " |cff00ff00";
-    out << Cash(EstRepairAll());
-
-    // calculate how much money bot has
-    uint32 copper = m_bot->GetMoney();
-    out << "|h|cffffffff item damage & has " << "|r|cff00ff00";
-    out << Cash(copper);
-    ChatHandler ch(&fromPlayer);
-    ch.SendSysMessage(out.str().c_str());
-}
-
-void PlayerbotAI::_HandleCommandGM(std::string& text, Player& fromPlayer)
-{
-    // Check should happen OUTSIDE this function, but this is account security we're talking about, so let's be doubly sure
-    if (fromPlayer.GetSession()->GetSecurity() <= SEC_PLAYER)
-        return;  // no excuses, no warning
-
-    if (text == "")
-    {
-        SendWhisper("gm must have a subcommand.", fromPlayer);
-        return;
-    }
-    else if (ExtractCommand("target", text))
-    {
-        if (ExtractCommand("combat", text))
-        {
-            for (AttackerInfoList::iterator i = m_attackerInfo.begin(); i != m_attackerInfo.end(); ++i)
-                DEBUG_LOG("[Attacker]:{ %s, victim:%s, threat:%.2f, highest-threat:%.2f, count:%d }",
-                          i->second.attacker->GetName(),
-                          i->second.victim->GetName(),
-                          i->second.threat,
-                          i->second.threat2,
-                          i->second.count);
-            DEBUG_LOG("[Attacker]:{ };");
-        }
-        else if (ExtractCommand("loot", text))
-        {
-            for (std::list<ObjectGuid>::iterator it = m_lootTargets.begin(); it != m_lootTargets.end(); ++it)
-                DEBUG_LOG("[Looter]:{ %s loots [%s] }", m_bot->GetName(), (*it).GetString().c_str());
-            DEBUG_LOG("[Looter]:{ }");
-        }
-        else
-            SendWhisper("'gm target' does not have that subcommand.", fromPlayer);
-    }
-    else if (ExtractCommand("chat", text))
-    {
-        m_bDebugCommandChat = !m_bDebugCommandChat;
-        if (m_bDebugCommandChat)
-            SendWhisper("I will now output all commands received.", fromPlayer);
-        else
-            SendWhisper("I will no longer output commands received.", fromPlayer);
-    }
-    else
-        SendWhisper("'gm' does not have that subcommand.", fromPlayer);
-}
-
-void PlayerbotAI::_HandleCommandHelp(std::string& text, Player& fromPlayer)
-{
-    ChatHandler ch(&fromPlayer);
-
-    // "help help"? Seriously?
-    if (ExtractCommand("help", text))
-    {
-        ch.SendSysMessage(_HandleCommandHelpHelper("help", "Lists all the things you can order me to do... But it's up to me whether to follow your orders... Or not.").c_str());
-        return;
-    }
-
-    bool bMainHelp = (text == "") ? true : false;
-    const std::string sInvalidSubcommand = "That's not a valid subcommand.";
-    std::string msg = "";
-    // All of these must contain the 'bMainHelp' clause -> help lists all major commands
-    // Further indented 'ExtractCommand("subcommand")' conditionals make sure these aren't printed for basic "help"
-    if (bMainHelp || ExtractCommand("attack", text))
-    {
-        ch.SendSysMessage(_HandleCommandHelpHelper("attack", "Attack the selected target. Which would, of course, require a valid target.", HL_TARGET).c_str());
-
-        if (!bMainHelp)
-        {
-            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
-            return;
-        }
-    }
-    if (bMainHelp || ExtractCommand("pull", text))
-    {
-        ch.SendSysMessage(_HandleCommandHelpHelper("pull", "Pull the target in a coordinated party/raid manner.", HL_TARGET).c_str());
-
-        if (!bMainHelp)
-        {
-            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
-            return;
-        }
-    }
-    if (bMainHelp || ExtractCommand("pull", text))
-    {
-        SendWhisper(_HandleCommandHelpHelper("pull", "Pull the target in a coordinated party/raid manner.", HL_TARGET), fromPlayer);
-
-        if (!bMainHelp)
-        {
-            SendWhisper(_HandleCommandHelpHelper("pull test", "I'll tell you if I could pull at all. Can be used anywhere."), fromPlayer);
-            SendWhisper(_HandleCommandHelpHelper("pull ready", "I'll tell you if I'm ready to pull *right now*. To be used on location with valid target."), fromPlayer);
-            if (text != "") SendWhisper(sInvalidSubcommand, fromPlayer);
-            return;
-        }
-    }
-    if (bMainHelp || ExtractCommand("neutralize", text))
-    {
-        SendWhisper(_HandleCommandHelpHelper("neutralize|neutral", "The bot will try to put its master's target out of combat with crowd control abilities like polymorph, banish, hibernate, shackles and the like.", HL_TARGET), fromPlayer);
-
-        if (!bMainHelp)
-        {
-            if (text != "") SendWhisper(sInvalidSubcommand, fromPlayer);
-            return;
-        }
-    }
-    if (bMainHelp || ExtractCommand("follow", text))
-    {
-        ch.SendSysMessage(_HandleCommandHelpHelper("follow", "I will follow you - this also revives me if dead and teleports me if I'm far away.").c_str());
-        ch.SendSysMessage(_HandleCommandHelpHelper("follow auto", "Toggles Automatic Follow Distance (ON/OFF).").c_str());
-        ch.SendSysMessage(_HandleCommandHelpHelper("follow info", "I will show my Automatic Follow Distance, toggle status (ON/OFF).").c_str());
-        ch.SendSysMessage(_HandleCommandHelpHelper("follow far", "I will follow at a father distance away from you.").c_str());
-        ch.SendSysMessage(_HandleCommandHelpHelper("follow near", "I will follow at a closer distance to you.").c_str());
-        ch.SendSysMessage(_HandleCommandHelpHelper("follow reset", "I will reset my follow distance to its original state.").c_str());
-
-        if (!bMainHelp)
-        {
-            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
-            return;
-        }
-    }
-    if (bMainHelp || ExtractCommand("stay", text))
-    {
-        ch.SendSysMessage(_HandleCommandHelpHelper("stay", "I will stay put until told otherwise.").c_str());
-
-        if (!bMainHelp)
-        {
-            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
-            return;
-        }
-    }
-    if (bMainHelp || ExtractCommand("assist", text))
-    {
-        ch.SendSysMessage(_HandleCommandHelpHelper("assist", "I will assist the character listed, attacking as they attack.", HL_NAME).c_str());
-
-        if (!bMainHelp)
-        {
-            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
-            return;
-        }
-    }
-    if (bMainHelp || ExtractCommand("spells", text))
-    {
-        ch.SendSysMessage(_HandleCommandHelpHelper("spells", "I will list all the spells I know.").c_str());
-
-        if (!bMainHelp)
-        {
-            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
-            return;
-        }
-    }
-    if (bMainHelp || ExtractCommand("craft", text))
-    {
-        ch.SendSysMessage(_HandleCommandHelpHelper("craft", "I will create a single specified recipe", HL_RECIPE).c_str());
-        ch.SendSysMessage(_HandleCommandHelpHelper("craft [RECIPE] all", "I will create all specified recipes").c_str());
-
-        if (!bMainHelp)
-        {
-            ch.SendSysMessage(_HandleCommandHelpHelper("craft < alchemy | a >", "List all learnt alchemy recipes").c_str());
-            ch.SendSysMessage(_HandleCommandHelpHelper("craft < blacksmithing | b >", "List all learnt blacksmith recipes").c_str());
-            ch.SendSysMessage(_HandleCommandHelpHelper("craft < cooking | c >", "List all learnt cooking recipes").c_str());
-            ch.SendSysMessage(_HandleCommandHelpHelper("craft < engineering | e >", "List all learnt engineering recipes").c_str());
-            ch.SendSysMessage(_HandleCommandHelpHelper("craft < firstaid | f >", "List all learnt firstaid recipes").c_str());
-            ch.SendSysMessage(_HandleCommandHelpHelper("craft < jewelcrafting | j >", "List all learnt jewelcrafting recipes").c_str());
-            ch.SendSysMessage(_HandleCommandHelpHelper("craft < leatherworking | l >", "List all learnt leatherworking recipes").c_str());
-            ch.SendSysMessage(_HandleCommandHelpHelper("craft < magic | m >", "List all learnt enchanting recipes").c_str());
-            ch.SendSysMessage(_HandleCommandHelpHelper("craft < smelting | s >", "List all learnt mining recipes").c_str());
-            ch.SendSysMessage(_HandleCommandHelpHelper("craft < tailoring | t >", "List all learnt tailoring recipes").c_str());
-            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
-            return;
-        }
-    }
-    if (bMainHelp || ExtractCommand("process", text))
-    {
-        ch.SendSysMessage(_HandleCommandHelpHelper("process < disenchant | d >", "Disenchants a green coloured [ITEM] or better", HL_ITEM).c_str());
-        ch.SendSysMessage(_HandleCommandHelpHelper("process < prospect | p >", "Searches 5 metal ore [ITEM] for precious gems", HL_ITEM).c_str());
-
-        if (!bMainHelp)
-        {
-            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
-            return;
-        }
-    }
-    if (bMainHelp || ExtractCommand("enchant", text))
-    {
-        ch.SendSysMessage(_HandleCommandHelpHelper("enchant", "Lists all enchantments [SPELL] learnt by the bot").c_str());
-        ch.SendSysMessage(_HandleCommandHelpHelper("enchant [SPELL]", "Enchants selected tradable [ITEM] either equipped or in bag", HL_ITEM).c_str());
-
-        if (!bMainHelp)
-        {
-            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
-            return;
-        }
-    }
-    if (bMainHelp || ExtractCommand("cast", text))
-    {
-        ch.SendSysMessage(_HandleCommandHelpHelper("cast", "I will cast the spell or ability listed.", HL_SPELL).c_str());
-
-        if (!bMainHelp)
-        {
-            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
-            return;
-        }
-    }
-    if (bMainHelp || ExtractCommand("use", text))
-    {
-        ch.SendSysMessage(_HandleCommandHelpHelper("use", "I will use the linked item.", HL_ITEM).c_str());
-
-        if (!bMainHelp)
-        {
-            ch.SendSysMessage(_HandleCommandHelpHelper("use [ITEM]", "I will use the first linked item on a selected TARGET.", HL_TARGET).c_str());
-            ch.SendSysMessage(_HandleCommandHelpHelper("use [ITEM]", "I will use the first linked item on an equipped linked item.", HL_ITEM).c_str());
-            ch.SendSysMessage(_HandleCommandHelpHelper("use [ITEM]", "I will use the first linked item on a linked gameobject.", HL_GAMEOBJECT).c_str());
-
-            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
-            return;
-        }
-    }
-    if (bMainHelp || ExtractCommand("equip", text))
-    {
-        ch.SendSysMessage(_HandleCommandHelpHelper("equip auto", "I will automatically equip items I acquire if they are better than what I'm wearing. Acts as toggle (ON/OFF) if used without subcommand. Fashion sense not included.", HL_ITEM, true).c_str());
-        ch.SendSysMessage(_HandleCommandHelpHelper("equip info", "I will tell you my equip auto toggle status (ON/OFF).").c_str());
-        ch.SendSysMessage(_HandleCommandHelpHelper("equip", "I will equip the linked item(s).", HL_ITEM, true).c_str());
-
-        if (!bMainHelp || ExtractCommand("auto", text))
-        {
-            ch.SendSysMessage(_HandleCommandHelpHelper("equip auto on", "Turns auto equip ON, also does an immediate check (like once).").c_str());
-            ch.SendSysMessage(_HandleCommandHelpHelper("equip auto off", "Turns auto equip OFF.").c_str());
-            ch.SendSysMessage(_HandleCommandHelpHelper("equip auto once", "Runs auto equip once, then turns it off.").c_str());
-
-            // Catches all valid subcommands, also placeholders for potential future sub-subcommands
-            if (ExtractCommand("on", text, true)) {}
-            else if (ExtractCommand("off", text, true)) {}
-            else if (ExtractCommand("once", text, true)) {}
-
-            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
-            return;
-        }
-    }
-    if (bMainHelp || ExtractCommand("reset", text))
-    {
-        ch.SendSysMessage(_HandleCommandHelpHelper("reset", "I will reset all my states, orders, loot list, talent spec, ... Hey, that's kind of like memory loss.").c_str());
-
-        if (!bMainHelp)
-        {
-            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
-            return;
-        }
-    }
-    if (bMainHelp || ExtractCommand("stats", text))
-    {
-        ch.SendSysMessage(_HandleCommandHelpHelper("stats", "This will inform you of my wealth, free bag slots and estimated equipment repair costs.").c_str());
-
-        if (!bMainHelp)
-        {
-            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
-            return;
-        }
-    }
-    if (bMainHelp || ExtractCommand("survey", text))
-    {
-        ch.SendSysMessage(_HandleCommandHelpHelper("survey", "Lists all available game objects near me.").c_str());
-
-        if (!bMainHelp)
-        {
-            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
-            return;
-        }
-    }
-    if (bMainHelp || ExtractCommand("find", text))
-    {
-        ch.SendSysMessage(_HandleCommandHelpHelper("find", "I will find said game object, walk right up to it, and wait.", HL_GAMEOBJECT).c_str());
-
-        if (!bMainHelp)
-        {
-            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
-            return;
-        }
-    }
-    if (bMainHelp || ExtractCommand("get", text))
-    {
-        ch.SendSysMessage(_HandleCommandHelpHelper("get", "I will get said game object and return to your side.", HL_GAMEOBJECT).c_str());
-
-        if (!bMainHelp)
-        {
-            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
-            return;
-        }
-    }
-    if (bMainHelp || ExtractCommand("quest", text))
-    {
-        ch.SendSysMessage(_HandleCommandHelpHelper("quest", "Lists my current quests.").c_str());
-
-        if (!bMainHelp)
-        {
-            ch.SendSysMessage(_HandleCommandHelpHelper("quest add", "Adds this quest to my quest log.", HL_QUEST).c_str());
-            ch.SendSysMessage(_HandleCommandHelpHelper("quest drop", "Removes this quest from my quest log.", HL_QUEST).c_str());
-            ch.SendSysMessage(_HandleCommandHelpHelper("quest end", "Turns in my completed quests.").c_str());
-            ch.SendSysMessage(_HandleCommandHelpHelper("quest list", "Lists the quests offered to me by this target.").c_str());
-            ch.SendSysMessage(_HandleCommandHelpHelper("quest report", "This will give you a full report of all the items, creatures or gameobjects I still need to finish my quests.", HL_QUEST).c_str());
-
-            // Catches all valid subcommands, also placeholders for potential future sub-subcommands
-            if (ExtractCommand("add", text, true)) {}
-            else if (ExtractCommand("drop", text, true)) {}
-            else if (ExtractCommand("end", text, true)) {}
-            else if (ExtractCommand("list", text, true)) {}
-            else if (ExtractCommand("report", text, true)) {}
-
-            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
-            return;
-        }
-    }
-    if (bMainHelp || ExtractCommand("orders", text))
-    {
-        ch.SendSysMessage(_HandleCommandHelpHelper("orders", "Shows you my orders. Free will is overrated, right?").c_str());
-
-        if (!bMainHelp)
-        {
-            SendWhisper(_HandleCommandHelpHelper("orders combat <tank | heal | assist | protect | reset> [targetPlayer]", "Sets general orders I should follow. Assist and Protect require a target."), fromPlayer);
-            SendWhisper(_HandleCommandHelpHelper("orders delay <0-10>", "Activates a delay before I start fighting."), fromPlayer);
-            SendWhisper(_HandleCommandHelpHelper("orders resume", "Resume combat orders to what they were before logout."), fromPlayer);
-
-            // Catches all valid subcommands, also placeholders for potential future sub-subcommands
-            if (ExtractCommand("combat", text, true))
-            {
-                SendWhisper(_HandleCommandHelpHelper("orders combat tank", "Order me to tank. Best used on paladins, warriors or druids."), fromPlayer);
-                SendWhisper(_HandleCommandHelpHelper("orders combat heal", "Order me to heal. Best used on shamans, priests, druids or paladins."), fromPlayer);
-                SendWhisper(_HandleCommandHelpHelper("orders combat assist", "Assist the linked target focusing our killing power.", HL_TARGET), fromPlayer);
-                SendWhisper(_HandleCommandHelpHelper("orders combat protect", "Protect the listed target, attempting to keep aggro away from the target.", HL_TARGET), fromPlayer);
-                SendWhisper(_HandleCommandHelpHelper("orders combat reset", "Resets my combat orders as though you'd never given me any at all."), fromPlayer);
-
-                if (ExtractCommand("tank", text, true)) {}
-                else if (ExtractCommand("heal", text, true)) {}
-                else if (ExtractCommand("assist", text, true)) {}
-                else if (ExtractCommand("protect", text, true)) {}
-                else if (ExtractCommand("reset", text, true)) {}
-
-                else if (text != "") SendWhisper(sInvalidSubcommand.c_str(), fromPlayer);
-            }
-            else if (ExtractCommand("delay", text, true)) {}
-            else if (ExtractCommand("resume", text, true)) {}
-
-            else if (text != "") SendWhisper(sInvalidSubcommand.c_str(), fromPlayer);
-            return;
-        }
-    }
-    if (bMainHelp || ExtractCommand("pet", text))
-    {
-        if (bMainHelp)
-            ch.SendSysMessage(_HandleCommandHelpHelper("pet", "Helps command my pet. Must always be used with a subcommand.").c_str());
-        else if (text == "") // not "help" AND "help pet"
-            ch.SendSysMessage(_HandleCommandHelpHelper("pet", "This by itself is not a valid command. Just so you know. To be used with a subcommand, such as...").c_str());
-
-        if (!bMainHelp)
-        {
-            ch.SendSysMessage(_HandleCommandHelpHelper("pet abandon", "Abandons active hunter pet.").c_str());
-            ch.SendSysMessage(_HandleCommandHelpHelper("pet cast", "Has my pet cast this spell. May require a treat. Or at least ask nicely.", HL_SPELL).c_str());
-            ch.SendSysMessage(_HandleCommandHelpHelper("pet react", "Sets my pet's aggro mode.", HL_PETAGGRO).c_str());
-            ch.SendSysMessage(_HandleCommandHelpHelper("pet spells", "Shows you the spells my pet knows.").c_str());
-            ch.SendSysMessage(_HandleCommandHelpHelper("pet state", "Shows my pet's aggro mode.").c_str());
-            ch.SendSysMessage(_HandleCommandHelpHelper("pet tame", "Allows a hunter to acquire a pet.", HL_TARGET).c_str());
-            ch.SendSysMessage(_HandleCommandHelpHelper("pet toggle", "Toggles autocast for this spell.", HL_SPELL).c_str());
-
-            // Catches all valid subcommands, also placeholders for potential future sub-subcommands
-            if (ExtractCommand("spells", text)) {}
-            else if (ExtractCommand("tame", text)) {}
-            else if (ExtractCommand("abandon", text)) {}
-            else if (ExtractCommand("cast", text)) {}
-            else if (ExtractCommand("toggle", text)) {}
-            else if (ExtractCommand("state", text)) {}
-            else if (ExtractCommand("react", text))
-            {
-                ch.SendSysMessage(_HandleCommandHelpHelper("pet react", "has three modes.").c_str());
-                ch.SendSysMessage(_HandleCommandHelpHelper("aggressive", "sets it so my precious attacks everything in sight.", HL_NONE, false, true).c_str());
-                ch.SendSysMessage(_HandleCommandHelpHelper("defensive", "sets it so it automatically attacks anything that attacks me, or anything I attack.", HL_NONE, false, true).c_str());
-                ch.SendSysMessage(_HandleCommandHelpHelper("passive", "makes it so my pet won't attack anything unless directly told to.", HL_NONE, false, true).c_str());
-
-                // Catches all valid subcommands, also placeholders for potential future sub-subcommands
-                if (ExtractCommand("aggressive", text, true)) {}
-                else if (ExtractCommand("defensive", text, true)) {}
-                else if (ExtractCommand("passive", text, true)) {}
-                if (text != "")
-                    ch.SendSysMessage(sInvalidSubcommand.c_str());
-            }
-
-            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
-            return;
-        }
-    }
-    if (bMainHelp || ExtractCommand("collect", text))
-    {
-        ch.SendSysMessage(_HandleCommandHelpHelper("collect", "Tells you what my current collect status is. Also lists possible options.").c_str());
-        ch.SendSysMessage(_HandleCommandHelpHelper("collect", "Sets what I collect. Obviously the 'none' option should be used alone, but all the others can be mixed.", HL_OPTION, true).c_str());
-
-        if (!bMainHelp)
-        {
-            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
-            return;
-        }
-    }
-    if (bMainHelp || ExtractCommand("sell", text))
-    {
-        ch.SendSysMessage(_HandleCommandHelpHelper("sell", "Adds this to my 'for sale' list.", HL_ITEM, true).c_str());
-        ch.SendSysMessage(_HandleCommandHelpHelper("sell all", "The next time you sell, I'll sell all my low level white items.").c_str());
-        ch.SendSysMessage(_HandleCommandHelpHelper("sell all", "This command must be called each time before you sell, OR I won't auto sell white items.").c_str());
-        if (!bMainHelp)
-        {
-            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
-            return;
-        }
-    }
-    if (bMainHelp || ExtractCommand("buy", text))
-    {
-        ch.SendSysMessage(_HandleCommandHelpHelper("buy", "Adds this to my 'purchase' list.", HL_ITEM, true).c_str());
-
-        if (!bMainHelp)
-        {
-            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
-            return;
-        }
-    }
-    if (bMainHelp || ExtractCommand("drop", text))
-    {
-        ch.SendSysMessage(_HandleCommandHelpHelper("drop", "Drops the linked item(s). Permanently.", HL_ITEM, true).c_str());
-
-        if (!bMainHelp)
-        {
-            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
-            return;
-        }
-    }
-    if (bMainHelp || ExtractCommand("auction", text))
-    {
-        ch.SendSysMessage(_HandleCommandHelpHelper("auction", "Lists all my active auctions. With pretty little links and such. Hi hi hi... I'm gonna be sooo rich!").c_str());
-
-        if (!bMainHelp)
-        {
-            ch.SendSysMessage(_HandleCommandHelpHelper("auction add", "Adds the item to my 'auction off later' list. I have a lot of lists, you see...", HL_ITEM).c_str());
-            ch.SendSysMessage(_HandleCommandHelpHelper("auction remove", "Adds the item to my 'Don't auction after all' list. Hope it hasn't sold by then!", HL_AUCTION).c_str());
-
-            // Catches all valid subcommands, also placeholders for potential future sub-subcommands
-            if (ExtractCommand("add", text, true)) {}
-            else if (ExtractCommand("remove", text, true)) {}
-
-            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
-            return;
-        }
-    }
-    if (bMainHelp || ExtractCommand("repair", text))
-    {
-        if (!bMainHelp && text == "")
-            ch.SendSysMessage(_HandleCommandHelpHelper("repair", "This by itself is not a valid command. Just so you know. To be used with a subcommand, such as...").c_str());
-
-        if (!bMainHelp)
-        {
-            ch.SendSysMessage(_HandleCommandHelpHelper("repair", "Has me find an armorer and repair the items you listed.", HL_ITEM).c_str());
-            ch.SendSysMessage(_HandleCommandHelpHelper("repair all", "Has me find an armorer and repair all my items, be they equipped or just taking up bagspace.").c_str());
-
-            // Catches all valid subcommands, also placeholders for potential future sub-subcommands
-            if (ExtractCommand("all", text)) {}
-
-            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
-            return;
-        }
-    }
-    if (bMainHelp || ExtractCommand("talent", text))
-    {
-        msg = _HandleCommandHelpHelper("talent", "Lists unspent talent points and the cost to reset all talents.");
-        msg = _HandleCommandHelpHelper("talent learn", "Lists linked talents, that can be learnt with unspent talent points");
-        ch.SendSysMessage(msg.c_str());
-
-        if (!bMainHelp)
-        {
-            ch.SendSysMessage(_HandleCommandHelpHelper("talent learn", "Has me learn the linked talent.", HL_TALENT).c_str());
-            ch.SendSysMessage(_HandleCommandHelpHelper("talent reset", "Resets my talents. Assuming I have the appropriate amount of sparkly gold, shiny silver, and... unrusted copper.").c_str());
-
-            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
-            return;
-        }
-        if (!bMainHelp) return;
-    }
-    if (bMainHelp || ExtractCommand("bank", text))
-    {
-        ch.SendSysMessage(_HandleCommandHelpHelper("bank", "Gives you my bank balance. I thought that was private.").c_str());
-
-        if (!bMainHelp)
-        {
-            ch.SendSysMessage(_HandleCommandHelpHelper("bank deposit", "Deposits the listed items in my bank.", HL_ITEM, true).c_str());
-            ch.SendSysMessage(_HandleCommandHelpHelper("bank withdraw", "Withdraw the listed items from my bank.", HL_ITEM, true).c_str());
-
-            // Catches all valid subcommands, also placeholders for potential future sub-subcommands
-            if (ExtractCommand("deposit", text)) {}
-            else if (ExtractCommand("withdraw", text)) {}
-
-            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
-            return;
-        }
-    }
-    if (bMainHelp || ExtractCommand("skill", text))
-    {
-        msg = _HandleCommandHelpHelper("skill", "Lists my primary professions & weapon skills.");
-        ch.SendSysMessage(msg.c_str());
-
-        if (!bMainHelp)
-        {
-            ch.SendSysMessage(_HandleCommandHelpHelper("skill learn", "Lists the things this trainer can teach me. If you've targeted a trainer, that is.", HL_TARGET).c_str());
-            ch.SendSysMessage(_HandleCommandHelpHelper("skill learn", "Have me learn this skill from the selected trainer.", HL_SKILL).c_str());
-            ch.SendSysMessage(_HandleCommandHelpHelper("skill unlearn", "Unlearn the linked (primary) profession and everything that goes with it.", HL_PROFESSION).c_str());
-
-            // Catches all valid subcommands, also placeholders for potential future sub-subcommands
-            if (ExtractCommand("learn", text))
-            {
-                ch.SendSysMessage(_HandleCommandHelpHelper("skill learn all", "Learn everything this trainer can teach me.", HL_TARGET).c_str());
-                if (ExtractCommand("all", text)) {}
-            }
-            else if (ExtractCommand("unlearn", text)) {}
-
-            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
-            return;
-        }
-    }
-    if (fromPlayer.GetSession()->GetSecurity() > SEC_PLAYER && (bMainHelp || ExtractCommand("gm", text)))
-    {
-        msg = _HandleCommandHelpHelper("gm", "Lists actions available to GM account level and up.");
-        ch.SendSysMessage(msg.c_str());
-
-        if (!bMainHelp)
-        {
-            ch.SendSysMessage(_HandleCommandHelpHelper("gm target", "Lists target items that can be monitored.").c_str());
-            ch.SendSysMessage(_HandleCommandHelpHelper("gm chat", "Outputs all commands the bot receives - including those it feels it can't obey.").c_str());
-
-            // Catches all valid subcommands, also placeholders for potential future sub-subcommands
-            if (ExtractCommand("target", text))
-            {
-                ch.SendSysMessage(_HandleCommandHelpHelper("gm target combat", "Lists current attacking targets.").c_str());
-                ch.SendSysMessage(_HandleCommandHelpHelper("gm target loot", "Lists current lootable targets.").c_str());
-            }
-            if (ExtractCommand("chat", text)) {}
-
-            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
-            return;
-        }
-    }
-    if (bMainHelp || ExtractCommand("mail", text))
-    {
-        ch.SendSysMessage(_HandleCommandHelpHelper("mail inbox |cFFFFFF00|h[Mailbox]|h|r", "Lists all bot mail from selected [Mailbox]").c_str());
-
-        if (!bMainHelp)
-        {
-            ch.SendSysMessage(_HandleCommandHelpHelper("mail getcash", "Gets money from all selected [Mailid]..", HL_MAIL, true).c_str());
-            ch.SendSysMessage(_HandleCommandHelpHelper("mail getitem", "Gets items from all selected [Mailid]..", HL_MAIL, true).c_str());
-            ch.SendSysMessage(_HandleCommandHelpHelper("mail delete", "Delete all selected [Mailid]..", HL_MAIL, true).c_str());
-
-            // Catches all valid subcommands, also placeholders for potential future sub-subcommands
-            if (ExtractCommand("inbox", text, true)) {}
-            else if (ExtractCommand("getcash", text, true)) {}
-            else if (ExtractCommand("getitem", text, true)) {}
-            else if (ExtractCommand("delete", text, true)) {}
-
-            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
-            return;
-        }
-    }
-
-    if (bMainHelp)
-        ch.SendSysMessage(_HandleCommandHelpHelper("help", "Gives you this listing of main commands... But then, you know that already don't you.").c_str());
-
-    if (text != "")
-        ch.SendSysMessage("Either that is not a valid command, or someone forgot to add it to my help journal. I mean seriously, they can't expect me to remember *all* this stuff, can they?");
-}
-
-std::string PlayerbotAI::_HandleCommandHelpHelper(std::string sCommand, std::string sExplain, HELPERLINKABLES reqLink, bool bReqLinkMultiples, bool bCommandShort)
-{
-    if (sCommand == "")
-    {
-        DEBUG_LOG("[PlayerbotAI] _HandleCommandHelpHelper called with an empty sCommand. Ignoring call.");
-        return "";
-    }
-
-    std::ostringstream oss;
-    oss << "'|cffffffff";
-    if (bCommandShort)
-        oss << "(" << sCommand.at(0) << ")" << sCommand.substr(1);
-    else
-        oss << sCommand;
-
-    if (reqLink != HL_NONE)
-    {
-        if (reqLink == HL_PROFESSION)
-        {
-            oss << " [PROFESSION]";
-            if (bReqLinkMultiples)
-                oss << " [PROFESSION] ..";
-        }
-        else if (reqLink == HL_ITEM)
-        {
-            oss << " [ITEM]";
-            if (bReqLinkMultiples)
-                oss << " [ITEM] ..";
-        }
-        else if (reqLink == HL_TALENT)
-        {
-            oss << " [TALENT]";
-            if (bReqLinkMultiples)
-                oss << " [TALENT] ..";
-        }
-        else if (reqLink == HL_SKILL)
-        {
-            oss << " [SKILL]";
-            if (bReqLinkMultiples)
-                oss << " [SKILL] ..";
-        }
-        else if (reqLink == HL_OPTION)
-        {
-            oss << " <OPTION>";
-            if (bReqLinkMultiples)
-                oss << " <OPTION> ..";
-        }
-        else if (reqLink == HL_PETAGGRO)
-        {
-            oss << " <(a)ggressive | (d)efensive | (p)assive>";
-            if (bReqLinkMultiples)
-                DEBUG_LOG("[PlayerbotAI] _HandleCommandHelpHelper: sCommand \"pet\" with bReqLinkMultiples \"true\". ... Why? Bug, surely.");
-        }
-        else if (reqLink == HL_QUEST)
-        {
-            oss << " [QUEST]";
-            if (bReqLinkMultiples)
-                oss << " [QUEST] ..";
-        }
-        else if (reqLink == HL_GAMEOBJECT)
-        {
-            oss << " [GAMEOBJECT]";
-            if (bReqLinkMultiples)
-                oss << " [GAMEOBJECT] ..";
-        }
-        else if (reqLink == HL_SPELL)
-        {
-            oss << " <Id# | (part of) name | [SPELL]>";
-            if (bReqLinkMultiples)
-                oss << " <Id# | (part of) name | [SPELL]> ..";
-        }
-        else if (reqLink == HL_TARGET)
-        {
-            oss << " (TARGET)";
-            if (bReqLinkMultiples)
-                oss << " (TARGET) ..";
-        }
-        else if (reqLink == HL_NAME)
-        {
-            oss << " <NAME>";
-            if (bReqLinkMultiples)
-                oss << " <NAME> ..";
-        }
-        else if (reqLink == HL_AUCTION)
-        {
-            oss << " [AUCTION]";
-            if (bReqLinkMultiples)
-                oss << " [AUCTION] ..";
-        }
-        else if (reqLink == HL_RECIPE)
-        {
-            oss << " [RECIPE]";
-            if (bReqLinkMultiples)
-                oss << " [RECIPE] ..";
-        }
-        else if (reqLink == HL_MAIL)
-        {
-            oss << " [MAILID]";
-            if (bReqLinkMultiples)
-                oss << " [MAILID] ..";
-        }
-        else
-        {
-            oss << " {unknown}";
-            if (bReqLinkMultiples)
-                oss << " {unknown} ..";
-            DEBUG_LOG("[PlayerbotAI]: _HandleCommandHelpHelper - Uncaught case");
-        }
-    }
-
-    oss << "|r': " << sExplain;
-
-    return oss.str();
-}
diff --git a/src/game/PlayerBot/Base/PlayerbotAI.h b/src/game/PlayerBot/Base/PlayerbotAI.h
deleted file mode 100644
index 4848cd0a0..000000000
--- a/src/game/PlayerBot/Base/PlayerbotAI.h
+++ /dev/null
@@ -1,803 +0,0 @@
-/*
- * This file is part of the CMaNGOS Project. See AUTHORS file for Copyright information
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _PLAYERBOTAI_H
-#define _PLAYERBOTAI_H
-
-#include "Common.h"
-#include "../../Entities/Creature.h"
-#include "../../Entities/ObjectGuid.h"
-#include "../../Entities/Unit.h"
-#include "../../GameEvents/GameEventMgr.h"
-#include "../../Quests/QuestDef.h"
-
-class WorldPacket;
-class WorldObject;
-class Player;
-class Unit;
-class Object;
-class Item;
-class PlayerbotClassAI;
-class PlayerbotMgr;
-
-enum RacialTraits
-{
-    ARCANE_TORRENT_MANA_CLASSES    = 28730,
-    ARCANE_TORRENT_ROGUE           = 25046,
-    BERSERKING_ALL                 = 26297,
-    BLOOD_FURY_MELEE_CLASSES       = 20572,
-    BLOOD_FURY_WARLOCK             = 33702,
-    BLOOD_FURY_SHAMAN              = 33697,
-    ESCAPE_ARTIST_ALL              = 20589,
-    GIFT_OF_THE_NAARU_ALL          = 28880,
-    PERCEPTION_ALL                 = 20600,
-    SHADOWMELD_ALL                 = 20580,
-    GIFT_OF_THE_NAARU_WARRIOR      = 28880,
-    STONEFORM_ALL                  = 20594,
-    WAR_STOMP_ALL                  = 20549,
-    WILL_OF_THE_FORSAKEN_ALL       = 7744
-};
-
-enum ProfessionSpells
-{
-    ALCHEMY_1                      = 2259,
-    BLACKSMITHING_1                = 2018,
-    COOKING_1                      = 2550,
-    ENCHANTING_1                   = 7411,
-    ENGINEERING_1                  = 4036,
-    FIRST_AID_1                    = 3273,
-    FISHING_1                      = 7620,
-    HERB_GATHERING_1               = 2366,
-    JEWELCRAFTING_1                = 25229,
-    MINING_1                       = 2575,
-    SKINNING_1                     = 8613,
-    TAILORING_1                    = 3908,
-    DISENCHANTING_1                = 13262,
-    PROSPECTING_1                  = 31252
-};
-
-enum NotableItems
-{
-    // Skeleton Keys
-    SILVER_SKELETON_KEY            = 15869,
-    GOLDEN_SKELETON_KEY            = 15870,
-    TRUESILVER_SKELETON_KEY        = 15871,
-    ARCANITE_SKELETON_KEY          = 15872,
-    // Lock Charges
-    SMALL_SEAFORIUM_CHARGE         = 4367,
-    LARGE_SEAFORIUM_CHARGE         = 4398,
-    POWERFUL_SEAFORIUM_CHARGE      = 18594,
-    ELEMENTAL_SEAFORIUM_CHARGE     = 23819
-};
-
-enum SharpeningStoneDisplayId
-{
-    ROUGH_SHARPENING_DISPLAYID          = 24673,
-    COARSE_SHARPENING_DISPLAYID         = 24674,
-    HEAVY_SHARPENING_DISPLAYID          = 24675,
-    SOLID_SHARPENING_DISPLAYID          = 24676,
-    DENSE_SHARPENING_DISPLAYID          = 24677,
-    CONSECRATED_SHARPENING_DISPLAYID    = 24674,    // will not be used because bot can not know if it will face undead targets
-    ELEMENTAL_SHARPENING_DISPLAYID      = 21072,
-    FEL_SHARPENING_DISPLAYID            = 39192,
-    ADAMANTITE_SHARPENING_DISPLAYID     = 39193,
-};
-
-enum WeightStoneDisplayId
-{
-    ROUGH_WEIGHTSTONE_DISPLAYID         = 24683,
-    COARSE_WEIGHTSTONE_DISPLAYID        = 24684,
-    HEAVY_WEIGHTSTONE_DISPLAYID         = 24685,
-    SOLID_WEIGHTSTONE_DISPLAYID         = 24686,
-    DENSE_WEIGHTSTONE_DISPLAYID         = 24687,
-    FEL_WEIGHTSTONE_DISPLAYID           = 39548,
-    ADAMANTITE_WEIGHTSTONE_DISPLAYID    = 39549,
-};
-
-enum ManaPotionsId
-{
-    MINOR_MANA_POTION                   = 15715,
-    LESSER_MANA_POTION                  = 15716,
-    MANA_POTION                         = 15717,
-    GREATER_MANA_POTION                 = 15718,
-    SUPERIOR_MANA_POTION                = 24151,
-    MAJOR_MANA_POTION                   = 21672,
-    SUPER_MANA_POTION                   = 37808,
-    UNSTABLE_MANA_POTION                = 23731,
-    FEL_MANA_POTION                     = 44295,
-    CRYSTAL_MANA_POTION                 = 47133,
-    AUCHENAI_MANA_POTION                = 37808,
-    MINOR_REJUVENATION_POTION           = 2345,
-    MAJOR_REJUVENATION_POTION           = 18253
-};
-
-enum ManaRunesId
-{
-    DEMONIC_RUNE                        = 22952,
-    DARK_RUNE                           = 32905
-};
-
-enum HealingItemDisplayId
-{
-    MAJOR_HEALING_POTION                = 24152,
-    WHIPPER_ROOT_TUBER                  = 21974,
-    NIGHT_DRAGON_BREATH                 = 21975,
-    LIMITED_INVULNERABILITY_POTION      = 24213,
-    GREATER_DREAMLESS_SLEEP_POTION      = 17403,
-    SUPERIOR_HEALING_POTION             = 15714,
-    CRYSTAL_RESTORE                     = 2516,
-    DREAMLESS_SLEEP_POTION              = 17403,
-    GREATER_HEALING_POTION              = 15713,
-    HEALING_POTION                      = 15712,
-    LESSER_HEALING_POTION               = 15711,
-    DISCOLORED_HEALING_POTION           = 15736,
-    MINOR_HEALING_POTION                = 15710,
-    VOLATILE_HEALING_POTION             = 24212,
-    SUPER_HEALING_POTION                = 37807,
-    CRYSTAL_HEALING_POTION              = 47132,
-    FEL_REGENERATION_POTION             = 37864,
-    MAJOR_DREAMLESS_SLEEP_POTION        = 37845,
-};
-
-enum MainSpec
-{
-    MAGE_SPEC_FIRE              = 41,
-    MAGE_SPEC_FROST             = 61,
-    MAGE_SPEC_ARCANE            = 81,
-    WARRIOR_SPEC_ARMS           = 161,
-    WARRIOR_SPEC_PROTECTION     = 163,
-    WARRIOR_SPEC_FURY           = 164,
-    ROGUE_SPEC_COMBAT           = 181,
-    ROGUE_SPEC_ASSASSINATION    = 182,
-    ROGUE_SPEC_SUBTELTY         = 183,
-    PRIEST_SPEC_DISCIPLINE      = 201,
-    PRIEST_SPEC_HOLY            = 202,
-    PRIEST_SPEC_SHADOW          = 203,
-    SHAMAN_SPEC_ELEMENTAL       = 261,
-    SHAMAN_SPEC_RESTORATION     = 262,
-    SHAMAN_SPEC_ENHANCEMENT     = 263,
-    DRUID_SPEC_FERAL            = 281,
-    DRUID_SPEC_RESTORATION      = 282,
-    DRUID_SPEC_BALANCE          = 283,
-    WARLOCK_SPEC_DESTRUCTION    = 301,
-    WARLOCK_SPEC_AFFLICTION     = 302,
-    WARLOCK_SPEC_DEMONOLOGY     = 303,
-    HUNTER_SPEC_BEASTMASTERY    = 361,
-    HUNTER_SPEC_SURVIVAL        = 362,
-    HUNTER_SPEC_MARKSMANSHIP    = 363,
-    PALADIN_SPEC_RETRIBUTION    = 381,
-    PALADIN_SPEC_HOLY           = 382,
-    PALADIN_SPEC_PROTECTION     = 383
-};
-
-enum AutoEquipEnum
-{
-    AUTOEQUIP_OFF  = 0,
-    AUTOEQUIP_ON   = 1,
-    AUTOEQUIP_ONCE = 2
-};
-
-enum m_FollowAutoGo
-{
-    FOLLOWAUTOGO_OFF        = 0,
-    FOLLOWAUTOGO_INIT       = 1,
-    FOLLOWAUTOGO_SET        = 2,
-    FOLLOWAUTOGO_RESET      = 3,
-    FOLLOWAUTOGO_RUN        = 4
-};
-
-enum CombatManeuverReturns
-{
-    // TODO: RETURN_NO_ACTION_UNKNOWN is not part of ANY_OK or ANY_ERROR. It's also bad form and should be eliminated ASAP.
-    RETURN_NO_ACTION_OK                 = 0x01, // No action taken during this combat maneuver, as intended (just wait, etc...)
-    RETURN_NO_ACTION_UNKNOWN            = 0x02, // No action taken during this combat maneuver, unknown reason
-    RETURN_NO_ACTION_ERROR              = 0x04, // No action taken due to error
-    RETURN_NO_ACTION_INVALIDTARGET      = 0x08, // No action taken - invalid target
-    RETURN_FINISHED_FIRST_MOVES         = 0x10, // Last action of first-combat-maneuver finished, continue onto next-combat-maneuver
-    RETURN_CONTINUE                     = 0x20, // Continue first moves; normal return value for next-combat-maneuver
-    RETURN_NO_ACTION_INSUFFICIENT_POWER = 0x40, // No action taken due to insufficient power (rage, focus, mana, runes)
-    RETURN_ANY_OK                       = 0x31, // All the OK values bitwise OR'ed
-    RETURN_ANY_ACTION                   = 0x30, // All returns that result in action (which should also be 'OK')
-    RETURN_ANY_ERROR                    = 0x4C  // All the ERROR values bitwise OR'ed
-};
-
-class PlayerbotAI
-{
-    public:
-        enum ScenarioType
-        {
-            SCENARIO_PVE,
-            SCENARIO_PVE_ELITE, // group (5 members max) when an elite is near - most likely instance (can happen in open world)
-            SCENARIO_PVE_RAID,
-            SCENARIO_PVP_DUEL,
-            SCENARIO_PVP_BG,    // You'll probably want to expand this to suit goal? (capture the flag, assault, domination, ...)
-            SCENARIO_PVP_ARENA,
-            SCENARIO_PVP_OPENWORLD
-        };
-
-        enum CombatStyle
-        {
-            COMBAT_MELEE                = 0x01,             // class melee attacker
-            COMBAT_RANGED               = 0x02              // class is ranged attacker
-        };
-
-        // masters orders that should be obeyed by the AI during the updateAI routine
-        // the master will auto set the target of the bot
-        enum CombatOrderType
-        {
-            ORDERS_NONE                 = 0x0000,   // no special orders given
-            ORDERS_TANK                 = 0x0001,   // bind attackers by gaining threat
-            ORDERS_ASSIST               = 0x0002,   // assist someone (dps type)
-            ORDERS_HEAL                 = 0x0004,   // concentrate on healing (no attacks, only self defense)
-            ORDERS_NODISPEL             = 0x0008,   // Dont dispel anything
-            ORDERS_PROTECT              = 0x0010,   // combinable state: check if protectee is attacked
-            ORDERS_PASSIVE              = 0x0020,   // bots do nothing
-            ORDERS_TEMP_WAIT_TANKAGGRO  = 0x0040,   // Wait on tank to build aggro - expect healing to continue, disable setting when tank loses focus
-            ORDERS_TEMP_WAIT_OOC        = 0x0080,   // Wait but only while OOC - wait only - combat will resume healing, dps, tanking, ...
-            ORDERS_RESIST_FIRE          = 0x0100,   // resist fire
-            ORDERS_RESIST_NATURE        = 0x0200,   // resist nature
-            ORDERS_RESIST_FROST         = 0x0400,   // resist frost
-            ORDERS_RESIST_SHADOW        = 0x0800,   // resist shadow
-
-            // Cumulative orders
-            ORDERS_PRIMARY              = 0x0007,
-            ORDERS_SECONDARY            = 0x0F78,
-            ORDERS_RESIST               = 0x0F00,
-            ORDERS_TEMP                 = 0x00C0,   // All orders NOT to be saved, turned off by bots (or logoff, reset, ...)
-            ORDERS_RESET                = 0xFFFF
-        };
-
-        enum ResistType
-        {
-            SCHOOL_NONE     = 0,
-            SCHOOL_FIRE     = 1,
-            SCHOOL_NATURE   = 2,
-            SCHOOL_FROST    = 3,
-            SCHOOL_SHADOW   = 4
-        };
-
-        enum CombatTargetType
-        {
-            TARGET_NORMAL               = 0x00,
-            TARGET_THREATEN             = 0x01
-        };
-
-        enum BotState
-        {
-            BOTSTATE_NORMAL,            // normal AI routines are processed
-            BOTSTATE_COMBAT,            // bot is in combat
-            BOTSTATE_DEAD,              // we are dead and wait for becoming ghost
-            BOTSTATE_DEADRELEASED,      // we released as ghost and wait to revive
-            BOTSTATE_LOOTING,           // looting mode, used just after combat
-            BOTSTATE_FLYING,            // bot is flying
-            BOTSTATE_TAME,              // bot hunter taming
-            BOTSTATE_DELAYED            // bot delay action
-        };
-
-        enum CollectionFlags
-        {
-            COLLECT_FLAG_NOTHING    = 0x00,     // skip looting of anything
-            COLLECT_FLAG_COMBAT     = 0x01,     // loot after combat
-            COLLECT_FLAG_QUEST      = 0x02,     // quest and needed items
-            COLLECT_FLAG_PROFESSION = 0x04,     // items related to skills
-            COLLECT_FLAG_LOOT       = 0x08,     // all loot on corpses
-            COLLECT_FLAG_SKIN       = 0x10,     // skin creatures if available
-            COLLECT_FLAG_NEAROBJECT = 0x20      // collect specified nearby object
-        };
-
-        enum MovementOrderType
-        {
-            MOVEMENT_NONE               = 0x00,
-            MOVEMENT_FOLLOW             = 0x01,
-            MOVEMENT_STAY               = 0x02
-        };
-
-        enum TaskFlags
-        {
-            NONE                        = 0x00,  // do nothing
-            SELL_ITEMS                  = 0x01,  // sell items
-            BUY_ITEMS                   = 0x02,  // buy items
-            REPAIR_ITEMS                = 0x03,  // repair items
-            ADD_AUCTION                 = 0x04,  // add auction
-            REMOVE_AUCTION              = 0x05,  // remove auction
-            LIST_AUCTION                = 0x06,  // list bot auctions
-            RESET_TALENTS               = 0x07,  // reset all talents
-            BANK_WITHDRAW               = 0x08,  // withdraw item from bank
-            BANK_DEPOSIT                = 0x09,  // deposit item in bank
-            BANK_BALANCE                = 0x0A,  // list bot bank balance
-            LIST_QUEST                  = 0x0B,  // list quests
-            END_QUEST                   = 0x0C,  // turn in quests
-            TAKE_QUEST                  = 0x0D   // take quest
-        };
-
-        enum AnnounceFlags
-        {
-            NOTHING                     = 0x00,
-            INVENTORY_FULL              = 0x01,
-            CANT_AFFORD                 = 0x02,
-            CANT_USE_TOO_FAR            = 0x03
-        };
-
-        typedef std::pair<enum TaskFlags, uint32> taskPair;
-        typedef std::pair<uint32, uint32> lootPair;
-        typedef std::list<lootPair> BotLootList;
-        typedef std::list<taskPair> BotTaskList;
-        typedef std::list<enum NPCFlags> BotNPCList;
-        typedef std::map<uint32, uint32> BotNeedItem;
-        typedef std::pair<uint32, uint32> talentPair;
-        typedef std::list<ObjectGuid> BotObjectList;
-        typedef std::list<uint32> BotEntryList;
-        typedef std::vector<uint32> BotTaxiNode;
-        typedef std::set<ObjectGuid> BotObjectSet;
-
-        // attacker query used in PlayerbotAI::FindAttacker()
-        enum ATTACKERINFOTYPE
-        {
-            AIT_NONE                    = 0x00,
-            AIT_LOWESTTHREAT            = 0x01,
-            AIT_HIGHESTTHREAT           = 0x02,
-            AIT_VICTIMSELF              = 0x04,
-            AIT_VICTIMNOTSELF           = 0x08      // could/should use victim param in FindAttackers
-        };
-        struct AttackerInfo
-        {
-            Unit*    attacker;            // reference to the attacker
-            Unit*    victim;              // combatant's current victim
-            float threat;                 // own threat on this combatant
-            float threat2;                // highest threat not caused by bot
-            uint32 count;                 // number of units attacking
-            uint32 source;                // 1=bot, 2=master, 3=group
-        };
-        typedef std::map<ObjectGuid, AttackerInfo> AttackerInfoList;
-        typedef std::map<uint32, float> SpellRanges;
-
-        enum HELPERLINKABLES
-        {
-            HL_NONE,
-            HL_PROFESSION,
-            HL_ITEM,
-            HL_TALENT,
-            HL_SKILL,
-            HL_OPTION,
-            HL_PETAGGRO,
-            HL_QUEST,
-            HL_GAMEOBJECT,
-            HL_SPELL,
-            HL_TARGET,
-            HL_NAME,
-            HL_AUCTION,
-            HL_MAIL,
-            HL_RECIPE
-        };
-
-    public:
-        PlayerbotAI(PlayerbotMgr* const mgr, Player* const bot);
-        virtual ~PlayerbotAI();
-
-        // This is called from Unit.cpp and is called every second (I think)
-        void UpdateAI(const uint32 p_time);
-
-        // This is called from ChatHandler.cpp when there is an incoming message to the bot
-        // from a whisper or from the party channel
-        void HandleCommand(const std::string& text, Player& fromPlayer);
-
-        // This is called by WorldSession.cpp
-        // It provides a view of packets normally sent to the client.
-        // Since there is no client at the other end, the packets are dropped of course.
-        // For a list of opcodes that can be caught see Opcodes.cpp (SMSG_* opcodes only)
-        void HandleBotOutgoingPacket(const WorldPacket& packet);
-
-        // This is called by WorldSession.cpp
-        // when it detects that a bot is being teleported. It acknowledges to the server to complete the
-        // teleportation
-        void HandleTeleportAck();
-
-        // Returns what kind of situation we are in so the ai can react accordingly
-        ScenarioType GetScenarioType() { return m_ScenarioType; }
-        CombatStyle GetCombatStyle() { return m_combatStyle; }
-        void SetCombatStyle(CombatStyle cs) { m_combatStyle = cs; }
-
-        PlayerbotClassAI* GetClassAI() { return m_classAI; }
-        PlayerbotMgr* GetManager() { return m_mgr; }
-        void ReloadAI();
-
-        // finds spell ID for matching substring args
-        // in priority of full text match, spells not taking reagents, and highest rank
-        uint32 getSpellId(const char* args, bool master = false) const;
-        uint32 getPetSpellId(const char* args) const;
-        // Initialize spell using rank 1 spell id
-        uint32 initSpell(uint32 spellId);
-        uint32 initPetSpell(uint32 spellIconId);
-
-        // extract mail ids from links
-        void extractMailIds(const std::string& text, std::list<uint32>& mailIds) const;
-
-        // extract quest ids from links
-        void extractQuestIds(const std::string& text, std::list<uint32>& questIds) const;
-
-        // extract auction ids from links
-        void extractAuctionIds(const std::string& text, std::list<uint32>& auctionIds) const;
-
-        // extracts talent ids to list
-        void extractTalentIds(const std::string& text, std::list<talentPair>& talentIds) const;
-
-        // extracts item ids from links
-        void extractItemIds(const std::string& text, std::list<uint32>& itemIds) const;
-
-        // extract spellid from links
-        void extractSpellId(const std::string& text, uint32& spellId) const;
-
-        // extract spellids from links to list
-        void extractSpellIdList(const std::string& text, BotEntryList& m_spellsToLearn) const;
-
-        // extracts currency from a string as #g#s#c and returns the total in copper
-        uint32 extractMoney(const std::string& text) const;
-
-        // extracts gameobject info from link
-        void extractGOinfo(const std::string& text, BotObjectList& m_lootTargets) const;
-
-        // finds items in bots equipment and adds them to foundItemList, removes found items from itemIdSearchList
-        void findItemsInEquip(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const;
-        // finds items in bots inventory and adds them to foundItemList, removes found items from itemIdSearchList
-        void findItemsInInv(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const;
-        // finds nearby game objects that are specified in m_collectObjects then adds them to the m_lootTargets list
-        void findNearbyGO();
-        // finds nearby creatures, whose UNIT_NPC_FLAGS match the flags specified in item list m_itemIds
-        void findNearbyCreature();
-        bool IsElite(Unit* pTarget, bool isWorldBoss = false) const;
-        // Used by bots to check if their target is neutralized (polymorph, shackle or the like). Useful to avoid breaking crowd control
-        bool IsNeutralized(Unit* pTarget);
-        // Make the bots face their target
-        void FaceTarget(Unit* pTarget);
-        // Used by bot to check if target is immune to a specific damage school before using an ability
-        bool IsImmuneToSchool(Unit* pTarget, SpellSchoolMask SchoolMask);
-
-        void MakeSpellLink(const SpellEntry* sInfo, std::ostringstream& out);
-        void MakeWeaponSkillLink(const SpellEntry* sInfo, std::ostringstream& out, uint32 skillid);
-
-        // currently bots only obey commands from the master
-        bool canObeyCommandFrom(const Player& player) const;
-
-        // get current casting spell (will return NULL if no spell!)
-        Spell* GetCurrentSpell() const;
-        uint32 GetCurrentSpellId() { return m_CurrentlyCastingSpellId; }
-
-        bool HasAura(uint32 spellId, const Unit& player) const;
-        bool HasAura(const char* spellName, const Unit& player) const;
-        bool HasAura(const char* spellName) const;
-
-        bool CanReceiveSpecificSpell(uint8 spec, Unit* target) const;
-
-        bool HasTool(uint32 TC);
-        bool PickPocket(Unit* pTarget);
-        bool HasSpellReagents(uint32 spellId);
-        void ItemCountInInv(uint32 itemid, uint32& count);
-        uint32 GetSpellCharges(uint32 spellId);
-
-        uint8 GetHealthPercent(const Unit& target) const;
-        uint8 GetHealthPercent() const;
-        uint8 GetBaseManaPercent(const Unit& target) const;
-        uint8 GetBaseManaPercent() const;
-        uint8 GetManaPercent(const Unit& target) const;
-        uint8 GetManaPercent() const;
-        uint8 GetRageAmount(const Unit& target) const;
-        uint8 GetRageAmount() const;
-        uint8 GetEnergyAmount(const Unit& target) const;
-        uint8 GetEnergyAmount() const;
-
-        Item* FindFood() const;
-        Item* FindDrink() const;
-        Item* FindBandage() const;
-        Item* FindMount(uint32 matchingRidingSkill) const;
-        Item* FindItem(uint32 ItemId, bool Equipped_too = false);
-        Item* FindItemInBank(uint32 ItemId);
-        Item* FindKeyForLockValue(uint32 reqSkillValue);
-        Item* FindBombForLockValue(uint32 reqSkillValue);
-        Item* FindConsumable(uint32 displayId) const;
-        Item* FindStoneFor(Item* weapon) const;
-        Item* FindManaRegenItem() const;
-        bool  FindAmmo() const;
-        uint8 _findItemSlot(Item* target);
-        bool CanStore();
-
-        // ******* Actions ****************************************
-        // Your handlers can call these actions to make the bot do things.
-        void TellMaster(const std::string& text) const;
-        void TellMaster(const char* fmt, ...) const;
-        void SendWhisper(const std::string& text, Player& player) const;
-        bool CastSpell(const char* args);
-        bool CastSpell(uint32 spellId);
-        bool CastSpell(uint32 spellId, Unit& target);
-        bool CheckBotCast(const SpellEntry* sInfo);
-        bool CastPetSpell(uint32 spellId, Unit* target = nullptr);
-        bool Buff(uint32 spellId, Unit* target, void (*beforeCast)(Player*) = nullptr);
-        bool SelfBuff(uint32 spellId);
-        bool In_Range(Unit* Target, uint32 spellId);
-        bool In_Reach(Unit* Target, uint32 spellId);
-        bool CanReachWithSpellAttack(Unit* target);
-
-        void UseItem(Item* item, uint32 targetFlag, ObjectGuid targetGUID);
-        void UseItem(Item* item, uint8 targetInventorySlot);
-        void UseItem(Item* item, Unit* target);
-        void UseItem(Item* item);
-
-        void TryEmergency(Unit* pAttacker);
-
-        void PlaySound(uint32 soundid);
-        void Announce(AnnounceFlags msg);
-
-        void EquipItem(Item* src_Item);
-        //void Stay();
-        //bool Follow(Player& player);
-        void SendNotEquipList(Player& player);
-
-        uint8  m_DelayAttack;
-        time_t m_DelayAttackInit;
-        Unit* gPrimtarget;
-        Unit* gSectarget;
-        uint32 gQuestFetch;
-
-        bool m_AutoEquipToggle;             //switch for autoequip
-        uint32 SellWhite;                   //switch for white item auto sell
-        uint8 DistOverRide;
-        float gDist[2]; //gDist, gTemp vars are used for variable follow distance
-        float gTempDist;
-        float gTempDist2;
-        uint8 m_FollowAutoGo;
-        uint8 IsUpOrDown; //tracks variable follow distance
-        void BotDataRestore();
-        void AutoUpgradeEquipment();
-        void FollowAutoReset();
-        void AutoEquipComparison(Item* pItem, Item* pItem2);
-        uint32 ItemStatsCount(ItemPrototype const* proto);
-        float getItemDPS(ItemPrototype const* proto) const;
-        bool ItemStatComparison(const ItemPrototype* pProto, const ItemPrototype* pProto2);
-
-        void CombatOrderRestore();
-        void InterruptCurrentCastingSpell();
-        void Attack(Unit* forcedTarget = nullptr);
-        void GetCombatTarget(Unit* forcedTarget = 0);
-        void GetDuelTarget(Unit* forcedTarget);
-        Unit* GetCurrentTarget() { return m_targetCombat; };
-        void DoNextCombatManeuver();
-        void DoCombatMovement();
-        void SetIgnoreUpdateTime(uint8 t = 0) { m_ignoreAIUpdatesUntilTime = time(nullptr) + t; };
-        time_t CurrentTime() { return time(nullptr); };
-
-        Player* GetPlayerBot() const { return m_bot; }
-        Player* GetPlayer() const { return m_bot; }
-        Player* GetMaster() const;
-
-        BotState GetState() { return m_botState; };
-        void SetState(BotState state);
-        void SetQuestNeedItems();
-        void SetQuestNeedCreatures();
-        void SendQuestNeedList();
-        bool IsInQuestItemList(uint32 itemid) { return m_needItemList.find(itemid) != m_needItemList.end(); };
-        bool IsInQuestCreatureList(uint32 id) { return m_needCreatureOrGOList.find(id) != m_needCreatureOrGOList.end(); };
-        bool IsItemUseful(uint32 itemid);
-        void SendOrders(Player& player);
-        bool DoTeleport(WorldObject& obj);
-        void DoLoot();
-        void DoFlight();
-        void GetTaxi(ObjectGuid guid, BotTaxiNode& nodes);
-
-        bool HasCollectFlag(uint8 flag) { return m_collectionFlags & flag; }
-        void SetCollectFlag(uint8 flag)
-        {
-            if (HasCollectFlag(flag)) m_collectionFlags &= ~flag;
-            else m_collectionFlags |= flag;
-        }
-
-        uint32 EstRepairAll();
-        uint32 EstRepair(uint16 pos);
-
-        void AcceptQuest(Quest const* qInfo, Player* pGiver);
-        void TurnInQuests(WorldObject* questgiver);
-        void ListQuests(WorldObject* questgiver);
-        bool AddQuest(const uint32 entry, WorldObject* questgiver);
-
-        bool IsInCombat();
-        bool IsRegenerating();
-        bool IsGroupReady();
-        Player* GetGroupTank(); // TODO: didn't want to pollute non-playerbot code but this should really go in group.cpp
-        void SetGroupCombatOrder(CombatOrderType co);
-        void ClearGroupCombatOrder(CombatOrderType co);
-        void SetGroupIgnoreUpdateTime(uint8 t);
-        bool GroupHoTOnTank();
-        bool CanPull(Player& fromPlayer);
-        bool CastPull();
-        bool GroupTankHoldsAggro();
-        bool CastNeutralize();
-        void UpdateAttackerInfo();
-        Unit* FindAttacker(ATTACKERINFOTYPE ait = AIT_NONE, Unit* victim = 0);
-        uint32 GetAttackerCount() { return m_attackerInfo.size(); };
-        void SetCombatOrderByStr(std::string str, Unit* target = 0);
-        void SetCombatOrder(CombatOrderType co, Unit* target = 0);
-        void ClearCombatOrder(CombatOrderType co);
-        CombatOrderType GetCombatOrder() { return this->m_combatOrder; }
-        bool IsTank() { return (m_combatOrder & ORDERS_TANK) ? true : false; }
-        bool IsHealer() { return (m_combatOrder & ORDERS_HEAL) ? true : false; }
-        bool IsDPS() { return (m_combatOrder & ORDERS_ASSIST) ? true : false; }
-        bool Impulse() { srand(time(nullptr)); return (((rand() % 100) > 50) ? true : false); }
-        ResistType GetResistType() { return this->m_resistType; }
-        void SetMovementOrder(MovementOrderType mo, Unit* followTarget = 0);
-        MovementOrderType GetMovementOrder() { return this->m_movementOrder; }
-        void MovementReset();
-        void MovementClear();
-        bool IsMoving();
-
-        void ItemLocalization(std::string& itemName, const uint32 itemID) const;
-        void QuestLocalization(std::string& questTitle, const uint32 questID) const;
-        void CreatureLocalization(std::string& creatureName, const uint32 entry) const;
-        void GameObjectLocalization(std::string& gameobjectName, const uint32 entry) const;
-
-        uint32 GetFreeBagSpace() const;
-        void SellGarbage(Player& player, bool listNonTrash = true, bool bDetailTrashSold = false, bool verbose = true);
-        void Sell(const uint32 itemid);
-        void Buy(Creature* vendor, const uint32 itemid);
-        std::string DropItem(const uint32 itemid);
-        void AddAuction(const uint32 itemid, Creature* aCreature);
-        void ListAuctions();
-        bool RemoveAuction(const uint32 auctionid);
-        void Repair(const uint32 itemid, Creature* rCreature);
-        bool Talent(Creature* tCreature);
-        void InspectUpdate();
-        bool Withdraw(const uint32 itemid);
-        bool Deposit(const uint32 itemid);
-        void BankBalance();
-        std::string Cash(uint32 copper);
-        std::string AuctionResult(std::string subject, std::string body);
-
-    private:
-        bool ExtractCommand(const std::string sLookingFor, std::string& text, bool bUseShort = false);
-        // outsource commands for code clarity
-        void _HandleCommandReset(std::string& text, Player& fromPlayer);
-        void _HandleCommandOrders(std::string& text, Player& fromPlayer);
-        void _HandleCommandFollow(std::string& text, Player& fromPlayer);
-        void _HandleCommandStay(std::string& text, Player& fromPlayer);
-        void _HandleCommandAttack(std::string& text, Player& fromPlayer);
-        void _HandleCommandPull(std::string& text, Player& fromPlayer);
-        void _HandleCommandNeutralize(std::string& text, Player& fromPlayer);
-        void _HandleCommandCast(std::string& text, Player& fromPlayer);
-        void _HandleCommandSell(std::string& text, Player& fromPlayer);
-        void _HandleCommandBuy(std::string& text, Player& fromPlayer);
-        void _HandleCommandDrop(std::string& text, Player& fromPlayer);
-        void _HandleCommandRepair(std::string& text, Player& fromPlayer);
-        void _HandleCommandAuction(std::string& text, Player& fromPlayer);
-        void _HandleCommandMail(std::string& text, Player& fromPlayer);
-        void _HandleCommandBank(std::string& text, Player& fromPlayer);
-        void _HandleCommandTalent(std::string& text, Player& fromPlayer);
-        void _HandleCommandUse(std::string& text, Player& fromPlayer);
-        void _HandleCommandEquip(std::string& text, Player& fromPlayer);
-        void _HandleCommandFind(std::string& text, Player& fromPlayer);
-        void _HandleCommandGet(std::string& text, Player& fromPlayer);
-        void _HandleCommandCollect(std::string& text, Player& fromPlayer);
-        void _HandleCommandQuest(std::string& text, Player& fromPlayer);
-        void _HandleCommandCraft(std::string& text, Player& fromPlayer);
-        void _HandleCommandEnchant(std::string& text, Player& fromPlayer);
-        void _HandleCommandProcess(std::string& text, Player& fromPlayer);
-        void _HandleCommandPet(std::string& text, Player& fromPlayer);
-        void _HandleCommandSpells(std::string& text, Player& fromPlayer);
-        void _HandleCommandSurvey(std::string& text, Player& fromPlayer);
-        void _HandleCommandSkill(std::string& text, Player& fromPlayer);
-        bool _HandleCommandSkillLearnHelper(TrainerSpell const* tSpell, uint32 spellId, uint32 cost);
-        void _HandleCommandStats(std::string& text, Player& fromPlayer);
-        void _HandleCommandHelp(std::string& text, Player& fromPlayer);
-        void _HandleCommandHelp(const char* szText, Player& fromPlayer) { std::string text = szText; _HandleCommandHelp(text, fromPlayer); }
-        void _HandleCommandGM(std::string& text, Player& fromPlayer);
-        std::string _HandleCommandHelpHelper(std::string sCommand, std::string sExplain, HELPERLINKABLES reqLink = HL_NONE, bool bReqLinkMultiples = false, bool bCommandShort = false);
-
-        // ****** Closed Actions ********************************
-        // These actions may only be called at special times.
-        // Trade methods are only applicable when the trade window is open
-        // and are only called from within HandleCommand.
-        bool TradeItem(const Item& item, int8 slot = -1);
-        bool TradeCopper(uint32 copper);
-
-        // Helper routines not needed by class AIs.
-        void UpdateAttackersForTarget(Unit* victim);
-
-        void _doSellItem(Item* const item, std::ostringstream& report, std::ostringstream& canSell, uint32& TotalCost, uint32& TotalSold);
-        void MakeItemLink(const Item* item, std::ostringstream& out, bool IncludeQuantity = true);
-        void MakeItemText(const Item* item, std::ostringstream& out, bool IncludeQuantity = true);
-        void MakeItemLink(const ItemPrototype* item, std::ostringstream& out);
-
-        // it is safe to keep these back reference pointers because m_bot
-        // owns the "this" object and m_master owns m_bot. The owner always cleans up.
-        PlayerbotMgr* const m_mgr;
-        Player* const m_bot;
-        PlayerbotClassAI* m_classAI;
-
-        // ignores AI updates until time specified
-        // no need to waste CPU cycles during casting etc
-        time_t m_ignoreAIUpdatesUntilTime;
-
-        CombatStyle m_combatStyle;
-        CombatOrderType m_combatOrder;
-        ResistType m_resistType;
-        MovementOrderType m_movementOrder;
-
-        ScenarioType m_ScenarioType;
-
-        // defines the state of behaviour of the bot
-        BotState m_botState;
-
-        // list of items, creatures or gameobjects needed to fullfill quests
-        BotLootList m_botQuestLoot; // keep track of quest items in loot;
-        BotNeedItem m_needItemList;
-        BotNeedItem m_needCreatureOrGOList;
-
-        // list of creatures we recently attacked and want to loot
-        BotNPCList m_findNPC;               // list of NPCs
-        BotTaskList m_tasks;                // list of tasks
-        BotObjectList m_lootTargets;        // list of targets
-        BotEntryList m_spellsToLearn;       // list of spells
-        ObjectGuid m_lootCurrent;           // current remains of interest
-        ObjectGuid m_lootPrev;              // previous loot
-        BotEntryList m_collectObjects;      // object entries searched for in findNearbyGO
-        BotTaxiNode m_taxiNodes;            // flight node chain;
-        BotEntryList m_noToolList;          // list of required tools
-
-        uint8 m_collectionFlags;            // what the bot should look for to loot
-        uint32 m_collectDist;               // distance to collect objects
-        bool m_inventory_full;
-        uint32 m_itemTarget;
-
-        time_t m_TimeDoneEating;
-        time_t m_TimeDoneDrinking;
-        uint32 m_CurrentlyCastingSpellId;
-        uint32 m_CraftSpellId;
-        //bool m_IsFollowingMaster;
-
-        // if master commands bot to do something, store here until updateAI
-        // can do it
-        uint32 m_spellIdCommand;
-        ObjectGuid m_targetGuidCommand;
-        ObjectGuid m_taxiMaster;
-
-        BotObjectSet m_ignorePlayersChat;  // list of players that the bot will not respond to
-
-        AttackerInfoList m_attackerInfo;
-
-        bool m_targetChanged;
-        CombatTargetType m_targetType;
-
-        Unit* m_targetCombat;       // current combat target
-        Unit* m_targetAssist;       // get new target by checking attacker list of assisted player
-        Unit* m_targetProtect;      // check
-
-        Unit* m_followTarget;       // whom to follow in non combat situation?
-
-        uint8 gPrimOrder;
-        uint8 gSecOrder;
-
-        uint32 FISHING,
-               HERB_GATHERING,
-               MINING,
-               SKINNING,
-               ASPECT_OF_THE_MONKEY;
-
-        SpellRanges m_spellRangeMap;
-
-        float m_destX, m_destY, m_destZ; // latest coordinates for chase and point movement types
-
-        bool m_bDebugCommandChat;
-};
-
-#endif
diff --git a/src/game/PlayerBot/Base/PlayerbotClassAI.cpp b/src/game/PlayerBot/Base/PlayerbotClassAI.cpp
deleted file mode 100644
index 8cc6a6e9f..000000000
--- a/src/game/PlayerBot/Base/PlayerbotClassAI.cpp
+++ /dev/null
@@ -1,704 +0,0 @@
-/*
- * This file is part of the CMaNGOS Project. See AUTHORS file for Copyright information
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "PlayerbotClassAI.h"
-#include "Common.h"
-
-#include "Grids/Cell.h"
-#include "Grids/CellImpl.h"
-#include "Grids/GridNotifiers.h"
-#include "Grids/GridNotifiersImpl.h"
-
-PlayerbotClassAI::PlayerbotClassAI(Player* const master, Player* const bot, PlayerbotAI* const ai)
-{
-    m_master = master;
-    m_bot = bot;
-    m_ai = ai;
-
-    m_MinHealthPercentTank   = 80;
-    m_MinHealthPercentHealer = 60;
-    m_MinHealthPercentDPS    = 30;
-    m_MinHealthPercentMaster = m_MinHealthPercentDPS;
-
-    ClearWait();
-}
-PlayerbotClassAI::~PlayerbotClassAI() {}
-
-CombatManeuverReturns PlayerbotClassAI::DoFirstCombatManeuver(Unit*) { return RETURN_NO_ACTION_OK; }
-CombatManeuverReturns PlayerbotClassAI::DoNextCombatManeuver(Unit*) { return RETURN_NO_ACTION_OK; }
-
-CombatManeuverReturns PlayerbotClassAI::DoFirstCombatManeuverPVE(Unit*) { return RETURN_NO_ACTION_OK; }
-CombatManeuverReturns PlayerbotClassAI::DoNextCombatManeuverPVE(Unit*) { return RETURN_NO_ACTION_OK; }
-CombatManeuverReturns PlayerbotClassAI::DoFirstCombatManeuverPVP(Unit*) { return RETURN_NO_ACTION_OK; }
-CombatManeuverReturns PlayerbotClassAI::DoNextCombatManeuverPVP(Unit*) { return RETURN_NO_ACTION_OK; }
-
-void PlayerbotClassAI::DoNonCombatActions()
-{
-    DEBUG_LOG("[PlayerbotAI]: Warning: Using PlayerbotClassAI::DoNonCombatActions() rather than class specific function");
-}
-
-bool PlayerbotClassAI::EatDrinkBandage(bool bMana, unsigned char foodPercent, unsigned char drinkPercent, unsigned char bandagePercent)
-{
-    Item* drinkItem = nullptr;
-    Item* foodItem = nullptr;
-    if (bMana && m_ai->GetManaPercent() < drinkPercent)
-        drinkItem = m_ai->FindDrink();
-    if (m_ai->GetHealthPercent() < foodPercent)
-        foodItem = m_ai->FindFood();
-    if (drinkItem || foodItem)
-    {
-        if (drinkItem)
-        {
-            m_ai->TellMaster("I could use a drink.");
-            m_ai->UseItem(drinkItem);
-        }
-        if (foodItem)
-        {
-            m_ai->TellMaster("I could use some food.");
-            m_ai->UseItem(foodItem);
-        }
-        return true;
-    }
-
-    if (m_ai->GetHealthPercent() < bandagePercent && !m_bot->HasAura(RECENTLY_BANDAGED))
-    {
-        Item* bandageItem = m_ai->FindBandage();
-        if (bandageItem)
-        {
-            m_ai->TellMaster("I could use first aid.");
-            m_ai->UseItem(bandageItem);
-            return true;
-        }
-    }
-
-    return false;
-}
-
-bool PlayerbotClassAI::CanPull()
-{
-    DEBUG_LOG("[PlayerbotAI]: Warning: Using PlayerbotClassAI::CanPull() rather than class specific function");
-    return false;
-}
-
-bool PlayerbotClassAI::CastHoTOnTank()
-{
-    DEBUG_LOG("[PlayerbotAI]: Warning: Using PlayerbotClassAI::CastHoTOnTank() rather than class specific function");
-    return false;
-}
-
-CombatManeuverReturns PlayerbotClassAI::HealPlayer(Player* target)
-{
-    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
-    if (!m_bot) return RETURN_NO_ACTION_ERROR;
-
-    if (!target) return RETURN_NO_ACTION_INVALIDTARGET;
-    if (target->IsInDuel()) return RETURN_NO_ACTION_INVALIDTARGET;
-
-    return RETURN_NO_ACTION_OK;
-}
-
-// Please note that job_type JOB_MANAONLY is a cumulative restriction. JOB_TANK | JOB_HEAL means both; JOB_TANK | JOB_MANAONLY means tanks with powertype MANA (paladins, druids)
-CombatManeuverReturns PlayerbotClassAI::Buff(bool (*BuffHelper)(PlayerbotAI*, uint32, Unit*), uint32 spellId, uint32 type, bool bMustBeOOC)
-{
-    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
-    if (!m_bot) return RETURN_NO_ACTION_ERROR;
-    if (!m_bot->isAlive() || m_bot->IsInDuel()) return RETURN_NO_ACTION_ERROR;
-    if (bMustBeOOC && m_bot->isInCombat()) return RETURN_NO_ACTION_ERROR;
-
-    if (spellId == 0) return RETURN_NO_ACTION_OK;
-
-    // First, fill the list of targets
-    if (m_bot->GetGroup())
-    {
-        Group::MemberSlotList const& groupSlot = m_bot->GetGroup()->GetMemberSlots();
-        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
-        {
-            Player* groupMember = sObjectMgr.GetPlayer(itr->guid);
-            if (!groupMember || !groupMember->isAlive() || groupMember->IsInDuel())
-                continue;
-            JOB_TYPE job = GetTargetJob(groupMember);
-            if (job & type && (!(job & JOB_MANAONLY) || groupMember->getClass() == CLASS_DRUID || groupMember->GetPowerType() == POWER_MANA))
-            {
-                if (BuffHelper(m_ai, spellId, groupMember))
-                    return RETURN_CONTINUE;
-            }
-        }
-    }
-    else
-    {
-        if (m_master && !m_master->IsInDuel()
-                && (!(GetTargetJob(m_master) & JOB_MANAONLY) || m_master->getClass() == CLASS_DRUID || m_master->GetPowerType() == POWER_MANA))
-            if (BuffHelper(m_ai, spellId, m_master))
-                return RETURN_CONTINUE;
-        // Do not check job or power type - any buff you have is always useful to self
-        if (BuffHelper(m_ai, spellId, m_bot))
-            return RETURN_CONTINUE;
-    }
-
-    return RETURN_NO_ACTION_OK;
-}
-
-/**
- * NeedGroupBuff()
- * return boolean Returns true if more than two targets in the bot's group need the group buff.
- *
- * params:groupBuffSpellId uint32 the spell ID of the group buff like Arcane Brillance
- * params:singleBuffSpellId uint32 the spell ID of the single target buff equivalent of the group buff like Arcane Intellect for group buff Arcane Brillance
- * return false if false is returned, the bot is expected to perform a buff check for the single target buff of the group buff.
- *
- */
-bool PlayerbotClassAI::NeedGroupBuff(uint32 groupBuffSpellId, uint32 singleBuffSpellId)
-{
-    if (!m_bot) return false;
-
-    uint8 numberOfGroupTargets = 0;
-    // Check group players to avoid using regeant and mana with an expensive group buff
-    // when only two players or less need it
-    if (m_bot->GetGroup())
-    {
-        Group::MemberSlotList const& groupSlot = m_bot->GetGroup()->GetMemberSlots();
-        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
-        {
-            Player* groupMember = sObjectMgr.GetPlayer(itr->guid);
-            if (!groupMember || !groupMember->isAlive())
-                continue;
-            // Check if group member needs buff
-            if (!groupMember->HasAura(groupBuffSpellId, EFFECT_INDEX_0) && !groupMember->HasAura(singleBuffSpellId, EFFECT_INDEX_0))
-                numberOfGroupTargets++;
-            // Don't forget about pet
-            Pet* pet = groupMember->GetPet();
-            if (pet && !pet->HasAuraType(SPELL_AURA_MOD_UNATTACKABLE) && (pet->HasAura(groupBuffSpellId, EFFECT_INDEX_0) || pet->HasAura(singleBuffSpellId, EFFECT_INDEX_0)))
-                numberOfGroupTargets++;
-        }
-        // treshold set to 2 targets because beyond that value, the group buff cost is cheaper in mana
-        if (numberOfGroupTargets < 3)
-            return false;
-
-        // In doubt, buff everyone
-        return true;
-    }
-    else
-        return false;   // no group, no group buff
-}
-
-/**
- * GetHealTarget()
- * return Unit* Returns unit to be healed. First checks 'critical' Healer(s), next Tank(s), next Master (if different from:), next DPS.
- * If none of the healths are low enough (or multiple valid targets) against these checks, the lowest health is healed. Having a target
- * returned does not guarantee it's worth healing, merely that the target does not have 100% health.
- *
- * return NULL If NULL is returned, no healing is required. At all.
- *
- * Will need extensive re-write for co-operation amongst multiple healers. As it stands, multiple healers would all pick the same 'ideal'
- * healing target.
- */
-Player* PlayerbotClassAI::GetHealTarget(JOB_TYPE type)
-{
-    if (!m_ai)  return nullptr;
-    if (!m_bot) return nullptr;
-    if (!m_bot->isAlive() || m_bot->IsInDuel()) return nullptr;
-
-    // define seperately for sorting purposes - DO NOT CHANGE ORDER!
-    std::vector<heal_priority> targets;
-    uint8 uiHealthPercentage;
-
-    // First, fill the list of targets
-    if (m_bot->GetGroup())
-    {
-        Group::MemberSlotList const& groupSlot = m_bot->GetGroup()->GetMemberSlots();
-        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
-        {
-            Player* groupMember = sObjectMgr.GetPlayer(itr->guid);
-            if (!groupMember || !groupMember->isAlive() || groupMember->IsInDuel())
-                continue;
-            JOB_TYPE job = GetTargetJob(groupMember);
-            if (job & type)
-            {
-                uiHealthPercentage = int(groupMember->GetMaxHealth() != 0 ? groupMember->GetHealth() * 100 / groupMember->GetMaxHealth() : 0);
-                targets.push_back(heal_priority(groupMember, uiHealthPercentage, job));
-            }
-        }
-    }
-    else
-    {
-        targets.push_back(heal_priority(m_bot, m_bot->GetHealthPercent(), GetTargetJob(m_bot)));
-        if (m_master && !m_master->IsInDuel())
-        {
-            uiHealthPercentage = int(m_master->GetMaxHealth() != 0 ? m_master->GetHealth() * 100 / m_master->GetMaxHealth() : 0);
-            targets.push_back(heal_priority(m_master, uiHealthPercentage, GetTargetJob(m_master)));
-        }
-    }
-
-    // Sorts according to type: Healers first, tanks next, then master followed by DPS, thanks to the order of the TYPE enum
-    std::sort(targets.begin(), targets.end());
-
-    uint8 uCount = 0, i = 0;
-    // x is used as 'target found' variable; i is used as the targets iterator throughout all 4 types.
-    int16 x = -1;
-
-    // Try to find a healer in need of healing (if multiple, the lowest health one)
-    while (true)
-    {
-        // This works because we sorted it above
-        if ((uCount + i) >= uint32(targets.size()) || !(targets.at(uCount).type & JOB_HEAL)) break;
-        uCount++;
-    }
-
-    // We have uCount healers in the targets, check if any qualify for priority healing
-    for (; uCount > 0; uCount--, i++)
-    {
-        if (targets.at(i).hp <= m_MinHealthPercentHealer)
-            if (x == -1 || targets.at(x).hp > targets.at(i).hp)
-                x = i;
-    }
-    if (x > -1) return targets.at(x).p;
-
-    // Try to find a tank in need of healing (if multiple, the lowest health one)
-    while (true)
-    {
-        if ((uCount + i) >= uint32(targets.size()) || !(targets.at(uCount).type & JOB_TANK)) break;
-        uCount++;
-    }
-
-    for (; uCount > 0; uCount--, i++)
-    {
-        if (targets.at(i).hp <= m_MinHealthPercentTank)
-            if (x == -1 || targets.at(x).hp > targets.at(i).hp)
-                x = i;
-    }
-    if (x > -1) return targets.at(x).p;
-
-    // Try to find master in need of healing (lowest health one first)
-    if (m_MinHealthPercentMaster != m_MinHealthPercentDPS)
-    {
-        while (true)
-        {
-            if ((uCount + i) >= uint32(targets.size()) || !(targets.at(uCount).type & JOB_MASTER)) break;
-            uCount++;
-        }
-
-        for (; uCount > 0; uCount--, i++)
-        {
-            if (targets.at(i).hp <= m_MinHealthPercentMaster)
-                if (x == -1 || targets.at(x).hp > targets.at(i).hp)
-                    x = i;
-        }
-        if (x > -1) return targets.at(x).p;
-    }
-
-    // Try to find anyone else in need of healing (lowest health one first)
-    while (true)
-    {
-        if ((uCount + i) >= uint32(targets.size())) break;
-        uCount++;
-    }
-
-    for (; uCount > 0; uCount--, i++)
-    {
-        if (targets.at(i).hp <= m_MinHealthPercentDPS)
-            if (x == -1 || targets.at(x).hp > targets.at(i).hp)
-                x = i;
-    }
-    if (x > -1) return targets.at(x).p;
-
-    // Nobody is critical, find anyone hurt at all, return lowest (let the healer sort out if it's worth healing or not)
-    for (i = 0, uCount = targets.size(); uCount > 0; uCount--, i++)
-    {
-        if (targets.at(i).hp < 100)
-            if (x == -1 || targets.at(x).hp > targets.at(i).hp)
-                x = i;
-    }
-    if (x > -1) return targets.at(x).p;
-
-    return nullptr;
-}
-
-/**
- * FleeFromAoEIfCan()
- * return boolean Check if the bot can move out of the hostile AoE spell then try to find a proper destination and move towards it
- *                The AoE is assumed to be centered on the current bot location (this is the case most of the time)
- *
- * params: spellId uint32 the spell ID of the hostile AoE the bot is supposed to move from. It is used to find the radius of the AoE spell
- * params: pTarget Unit* the creature or gameobject the bot will use to define one of the prefered direction in which to flee
- *
- * return true if bot has found a proper destination, false if none was found
- */
-bool PlayerbotClassAI::FleeFromAoEIfCan(uint32 spellId, Unit* pTarget)
-{
-    if (!m_bot) return false;
-    if (!spellId) return false;
-
-    // Step 1: Get radius from hostile AoE spell
-    float radius = 0;
-    SpellEntry const* spellproto = sSpellTemplate.LookupEntry<SpellEntry>(spellId);
-    if (spellproto)
-        radius = GetSpellRadius(sSpellRadiusStore.LookupEntry(spellproto->EffectRadiusIndex[EFFECT_INDEX_0]));
-
-    // Step 2: Get current bot position to move from it
-    float curr_x, curr_y, curr_z;
-    m_bot->GetPosition(curr_x, curr_y, curr_z);
-    return FleeFromPointIfCan(radius, pTarget, curr_x, curr_y, curr_z);
-}
-
-/**
- * FleeFromTrapGOIfCan()
- * return boolean Check if the bot can move from a hostile nearby trap, then try to find a proper destination and move towards it
- *
- * params: goEntry uint32 the ID of the hostile trap the bot is supposed to move from. It is used to find the radius of the trap
- * params: pTarget Unit* the creature or gameobject the bot will use to define one of the prefered direction in which to flee
- *
- * return true if bot has found a proper destination, false if none was found
- */
-bool PlayerbotClassAI::FleeFromTrapGOIfCan(uint32 goEntry, Unit* pTarget)
-{
-    if (!m_bot) return false;
-    if (!goEntry) return false;
-
-    // Step 1: check if the GO exists and find its trap radius
-    GameObjectInfo const* trapInfo = sGOStorage.LookupEntry<GameObjectInfo>(goEntry);
-    if (!trapInfo || trapInfo->type != GAMEOBJECT_TYPE_TRAP)
-        return false;
-
-    float trapRadius = float(trapInfo->trap.diameter) / 2.f;
-
-    // Step 2: find a GO in the range around player
-    GameObject* pGo = nullptr;
-
-    MaNGOS::NearestGameObjectEntryInObjectRangeCheck go_check(*m_bot, goEntry, trapRadius);
-    MaNGOS::GameObjectLastSearcher<MaNGOS::NearestGameObjectEntryInObjectRangeCheck> searcher(pGo, go_check);
-
-    Cell::VisitGridObjects(m_bot, searcher, trapRadius);
-
-    if (!pGo)
-        return false;
-
-    return FleeFromPointIfCan(trapRadius, pTarget, pGo->GetPositionX(), pGo->GetPositionY(), pGo->GetPositionZ());
-}
-
-/**
- * FleeFromNpcWithAuraIfCan()
- * return boolean Check if the bot can move from a creature having a specific aura, then try to find a proper destination and move towards it
- *
- * params: goEntry uint32 the ID of the hostile trap the bot is supposed to move from. It is used to find the radius of the trap
- * params: spellId uint32 the spell ID of the aura the creature is supposed to have (directly or from triggered spell). It is used to find the radius of the aura
- * params: pTarget Unit* the creature or gameobject the bot will use to define one of the prefered direction in which to flee
- *
- * return true if bot has found a proper destination, false if none was found
- */
-bool PlayerbotClassAI::FleeFromNpcWithAuraIfCan(uint32 NpcEntry, uint32 spellId, Unit* pTarget)
-{
-    if (!m_bot) return false;
-    if (!NpcEntry) return false;
-    if (!spellId) return false;
-
-    // Step 1: Get radius from hostile aura spell
-    float radius = 0;
-    SpellEntry const* spellproto = sSpellTemplate.LookupEntry<SpellEntry>(spellId);
-    if (spellproto)
-        radius = GetSpellRadius(sSpellRadiusStore.LookupEntry(spellproto->EffectRadiusIndex[EFFECT_INDEX_0]));
-
-    if (radius == 0)
-        return false;
-
-    // Step 2: find a close creature with the right entry:
-    Creature* pCreature = nullptr;
-
-    MaNGOS::NearestCreatureEntryWithLiveStateInObjectRangeCheck creature_check(*m_bot, NpcEntry, false, false, radius, true);
-    MaNGOS::CreatureLastSearcher<MaNGOS::NearestCreatureEntryWithLiveStateInObjectRangeCheck> searcher(pCreature, creature_check);
-
-    Cell::VisitGridObjects(m_bot, searcher, radius);
-
-    if (!pCreature)
-        return false;
-
-    // Force to flee on a direction opposite to the position of the creature (fleeing from it, not only avoiding it)
-    return FleeFromPointIfCan(radius, pTarget, pCreature->GetPositionX(), pCreature->GetPositionY(), pCreature->GetPositionZ(), M_PI_F);
-}
-
-/**
- * FleeFromPointIfCan()
- * return boolean Check if the bot can move from a provided point (x, y, z) to given distance radius
- *
- * params: radius uint32 the minimal radius (distance) used by the bot to look for a destination from the provided position
- * params: pTarget Unit* the creature or gameobject the bot will use to define one of the prefered direction in which to flee
- * params: x0, y0, z0 float the coordinates of the origin point used to calculate the destination point
- * params: forcedAngle float (optional) when iterating to find a proper point in world to move the bot to, this angle will be prioritly used over other angles if it is provided
- *
- * return true if bot has found a proper destination, false if none was found
- */
-bool PlayerbotClassAI::FleeFromPointIfCan(uint32 radius, Unit* pTarget, float x0, float y0, float z0, float forcedAngle /* = 0.0f */)
-{
-    if (!m_bot) return false;
-    if (!m_ai) return false;
-
-    // Get relative position to current target
-    // the bot will try to move on a tangential axis from it
-    float dist_from_target, angle_to_target;
-    if (pTarget)
-    {
-        dist_from_target = pTarget->GetDistance(m_bot);
-        if (dist_from_target > 0.2f)
-            angle_to_target = pTarget->GetAngle(m_bot);
-        else
-            angle_to_target = frand(0, 2 * M_PI_F);
-    }
-    else
-    {
-        dist_from_target = 0.0f;
-        angle_to_target = frand(0, 2 * M_PI_F);
-    }
-
-    // Find coords to move to
-    // The bot will move for a distance equal to the spell radius + 1 yard for more safety
-    float dist = radius + 1.0f;
-
-    float moveAngles[3] = {- M_PI_F / 2, M_PI_F / 2, 0.0f};
-    float angle, x, y, z;
-    bool foundCoords;
-    for (uint8 i = 0; i < 3; i++)
-    {
-        // define an angle tangential to target's direction
-        angle = angle_to_target + moveAngles[i];
-        // if an angle was provided, use it instead but only for the first iteration in case this does not lead to a valid point
-        if (forcedAngle != 0.0f)
-        {
-            angle = forcedAngle;
-            forcedAngle = 0.0f;
-        }
-        foundCoords = true;
-
-        x = x0 + dist * cos(angle);
-        y = y0 + dist * sin(angle);
-        z = z0 + 0.5f;
-
-        // try to fix z
-        if (!m_bot->GetMap()->GetHeightInRange(x, y, z))
-            foundCoords = false;
-
-        // check any collision
-        float testZ = z + 0.5f; // needed to avoid some false positive hit detection of terrain or passable little object
-        if (m_bot->GetMap()->GetHitPosition(x0, y0, z0 + 0.5f, x, y, testZ, -0.1f))
-        {
-            z = testZ;
-            if (!m_bot->GetMap()->GetHeightInRange(x, y, z))
-                foundCoords = false;
-        }
-
-        if (foundCoords)
-        {
-            m_ai->InterruptCurrentCastingSpell();
-            m_bot->GetMotionMaster()->MovePoint(0, x, y, z);
-            m_ai->SetIgnoreUpdateTime(2);
-            return true;
-        }
-    }
-
-    return false;
-}
-
-/**
- * GetDispelTarget()
- * return Unit* Returns unit to be dispelled. First checks 'critical' Healer(s), next Tank(s), next Master (if different from:), next DPS.
- *
- * return NULL If NULL is returned, no healing is required. At all.
- *
- * Will need extensive re-write for co-operation amongst multiple healers. As it stands, multiple healers would all pick the same 'ideal'
- * healing target.
- */
-Player* PlayerbotClassAI::GetDispelTarget(DispelType dispelType, JOB_TYPE type, bool bMustBeOOC)
-{
-    if (!m_ai)  return nullptr;
-    if (!m_bot) return nullptr;
-    if (!m_bot->isAlive() || m_bot->IsInDuel()) return nullptr;
-    if (bMustBeOOC && m_bot->isInCombat()) return nullptr;
-
-    // First, fill the list of targets
-    if (m_bot->GetGroup())
-    {
-        // define seperately for sorting purposes - DO NOT CHANGE ORDER!
-        std::vector<heal_priority> targets;
-
-        Group::MemberSlotList const& groupSlot = m_bot->GetGroup()->GetMemberSlots();
-        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
-        {
-            Player* groupMember = sObjectMgr.GetPlayer(itr->guid);
-            if (!groupMember || !groupMember->isAlive())
-                continue;
-            JOB_TYPE job = GetTargetJob(groupMember);
-            if (job & type)
-            {
-                uint32 dispelMask  = GetDispellMask(dispelType);
-                Unit::SpellAuraHolderMap const& auras = groupMember->GetSpellAuraHolderMap();
-                for (Unit::SpellAuraHolderMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
-                {
-                    SpellAuraHolder* holder = itr->second;
-                    // Only return group members with negative magic effect
-                    if (dispelType == DISPEL_MAGIC && holder->IsPositive())
-                        continue;
-                    // poison, disease and curse are always negative: return everyone
-                    if ((1 << holder->GetSpellProto()->Dispel) & dispelMask)
-                        targets.push_back(heal_priority(groupMember, 0, job));
-                }
-            }
-        }
-
-        // Sorts according to type: Healers first, tanks next, then master followed by DPS, thanks to the order of the TYPE enum
-        std::sort(targets.begin(), targets.end());
-
-        if (targets.size())
-            return targets.at(0).p;
-    }
-
-    return nullptr;
-}
-
-Player* PlayerbotClassAI::GetResurrectionTarget(JOB_TYPE type, bool bMustBeOOC)
-{
-    if (!m_ai)  return nullptr;
-    if (!m_bot) return nullptr;
-    if (!m_bot->isAlive() || m_bot->IsInDuel()) return nullptr;
-    if (bMustBeOOC && m_bot->isInCombat()) return nullptr;
-
-    // First, fill the list of targets
-    if (m_bot->GetGroup())
-    {
-        // define seperately for sorting purposes - DO NOT CHANGE ORDER!
-        std::vector<heal_priority> targets;
-
-        Group::MemberSlotList const& groupSlot = m_bot->GetGroup()->GetMemberSlots();
-        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
-        {
-            Player* groupMember = sObjectMgr.GetPlayer(itr->guid);
-            if (!groupMember || groupMember->isAlive())
-                continue;
-            JOB_TYPE job = GetTargetJob(groupMember);
-            if (job & type)
-                targets.push_back(heal_priority(groupMember, 0, job));
-        }
-
-        // Sorts according to type: Healers first, tanks next, then master followed by DPS, thanks to the order of the TYPE enum
-        std::sort(targets.begin(), targets.end());
-
-        if (targets.size())
-            return targets.at(0).p;
-    }
-    else if (!m_master->isAlive())
-        return m_master;
-
-    return nullptr;
-}
-
-JOB_TYPE PlayerbotClassAI::GetTargetJob(Player* target)
-{
-    // is a bot
-    if (target->GetPlayerbotAI())
-    {
-        if (target->GetPlayerbotAI()->IsHealer())
-            return JOB_HEAL;
-        if (target->GetPlayerbotAI()->IsTank())
-            return JOB_TANK;
-        return JOB_DPS;
-    }
-
-    // figure out what to do with human players - i.e. figure out if they're tank, DPS or healer
-    uint32 uSpec = target->GetSpec();
-    switch (target->getClass())
-    {
-        case CLASS_PALADIN:
-            if (uSpec == PALADIN_SPEC_HOLY)
-                return JOB_HEAL;
-            if (uSpec == PALADIN_SPEC_PROTECTION)
-                return JOB_TANK;
-            return (m_master == target) ? JOB_MASTER : JOB_DPS;
-        case CLASS_DRUID:
-            if (uSpec == DRUID_SPEC_RESTORATION)
-                return JOB_HEAL;
-            // Feral can be used for both Tank or DPS... play it safe and assume tank. If not... he best be good at threat management or he'll ravage the healer's mana
-            else if (uSpec == DRUID_SPEC_FERAL)
-                return JOB_TANK;
-            return (m_master == target) ? JOB_MASTER : JOB_DPS;
-        case CLASS_PRIEST:
-            // Since Discipline can be used for both healer or DPS assume DPS
-            if (uSpec == PRIEST_SPEC_HOLY)
-                return JOB_HEAL;
-            return (m_master == target) ? JOB_MASTER : JOB_DPS;
-        case CLASS_SHAMAN:
-            if (uSpec == SHAMAN_SPEC_RESTORATION)
-                return JOB_HEAL;
-            return (m_master == target) ? JOB_MASTER : JOB_DPS;
-        case CLASS_WARRIOR:
-            if (uSpec == WARRIOR_SPEC_PROTECTION)
-                return JOB_TANK;
-            return (m_master == target) ? JOB_MASTER : JOB_DPS;
-        case CLASS_MAGE:
-        case CLASS_WARLOCK:
-        case CLASS_ROGUE:
-        case CLASS_HUNTER:
-        default:
-            return (m_master == target) ? JOB_MASTER : JOB_DPS;
-    }
-}
-
-CombatManeuverReturns PlayerbotClassAI::CastSpellNoRanged(uint32 nextAction, Unit* pTarget)
-{
-    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
-    if (!m_bot) return RETURN_NO_ACTION_ERROR;
-
-    if (nextAction == 0)
-        return RETURN_NO_ACTION_OK; // Asked to do nothing so... yeh... Dooone.
-
-    if (pTarget != nullptr)
-        return (m_ai->CastSpell(nextAction, *pTarget) ? RETURN_CONTINUE : RETURN_NO_ACTION_ERROR);
-    else
-        return (m_ai->CastSpell(nextAction) ? RETURN_CONTINUE : RETURN_NO_ACTION_ERROR);
-}
-
-CombatManeuverReturns PlayerbotClassAI::CastSpellWand(uint32 nextAction, Unit* pTarget, uint32 SHOOT)
-{
-    if (!m_ai)  return RETURN_NO_ACTION_ERROR;
-    if (!m_bot) return RETURN_NO_ACTION_ERROR;
-
-    if (SHOOT > 0 && m_bot->FindCurrentSpellBySpellId(SHOOT) && m_bot->GetWeaponForAttack(RANGED_ATTACK, true, true))
-    {
-        if (nextAction == SHOOT)
-            // At this point we're already shooting and are asked to shoot. Don't cause a global cooldown by stopping to shoot! Leave it be.
-            return RETURN_CONTINUE; // ... We're asked to shoot and are already shooting so... Task accomplished?
-
-        // We are shooting but wish to cast a spell. Stop 'casting' shoot.
-        m_bot->InterruptNonMeleeSpells(true, SHOOT);
-        // ai->TellMaster("Interrupting auto shot.");
-    }
-
-    // We've stopped ranged (if applicable), if no nextAction just return
-    if (nextAction == 0)
-        return RETURN_CONTINUE; // Asked to do nothing so... yeh... Dooone.
-
-    if (nextAction == SHOOT)
-    {
-        if (SHOOT > 0 && m_ai->GetCombatStyle() == PlayerbotAI::COMBAT_RANGED && !m_bot->FindCurrentSpellBySpellId(SHOOT) && m_bot->GetWeaponForAttack(RANGED_ATTACK, true, true))
-            return (m_ai->CastSpell(SHOOT, *pTarget) ? RETURN_CONTINUE : RETURN_NO_ACTION_ERROR);
-        else
-            // Do Melee attack
-            return RETURN_NO_ACTION_UNKNOWN; // We're asked to shoot and aren't.
-    }
-
-    if (pTarget != nullptr)
-        return (m_ai->CastSpell(nextAction, *pTarget) ? RETURN_CONTINUE : RETURN_NO_ACTION_ERROR);
-    else
-        return (m_ai->CastSpell(nextAction) ? RETURN_CONTINUE : RETURN_NO_ACTION_ERROR);
-}
diff --git a/src/game/PlayerBot/Base/PlayerbotClassAI.h b/src/game/PlayerBot/Base/PlayerbotClassAI.h
deleted file mode 100644
index 8a101a058..000000000
--- a/src/game/PlayerBot/Base/PlayerbotClassAI.h
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * This file is part of the CMaNGOS Project. See AUTHORS file for Copyright information
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _PLAYERBOTCLASSAI_H
-#define _PLAYERBOTCLASSAI_H
-
-#include "Common.h"
-#include "WorldPacket.h"
-#include "PlayerbotAI.h"
-#include "../../Entities/Player.h"
-#include "../../Entities/Unit.h"
-#include "../../Globals/ObjectMgr.h"
-#include "../../Globals/ObjectAccessor.h"
-#include "../../Globals/SharedDefines.h"
-#include "../../Spells/SpellMgr.h"
-#include "../../Spells/SpellAuras.h"
-#include "../../World/World.h"
-
-class Player;
-class PlayerbotAI;
-
-enum JOB_TYPE
-{
-    JOB_HEAL     = 0x01,
-    JOB_TANK     = 0x02,
-    JOB_MASTER   = 0x04, // Not a fan of this distinction but user (or rather, admin) choice
-    JOB_DPS      = 0x08,
-    JOB_ALL      = 0x0F, // all of the above
-    JOB_MANAONLY = 0x10  // for buff checking (NOTE: this means any with powertype mana AND druids (who may be shifted but still have mana)
-};
-
-struct heal_priority
-{
-    Player* p;
-    uint8 hp;
-    JOB_TYPE type;
-    heal_priority(Player* pin, uint8 hpin, JOB_TYPE t) : p(pin), hp(hpin), type(t) {}
-    // overriding the operator like this is not recommended for general use - however we won't use this struct for anything else
-    bool operator<(const heal_priority& a) const { return type < a.type; }
-};
-
-class PlayerbotClassAI
-{
-    public:
-        PlayerbotClassAI(Player* const master, Player* const bot, PlayerbotAI* const ai);
-        virtual ~PlayerbotClassAI();
-
-        // all combat actions go here
-        virtual CombatManeuverReturns DoFirstCombatManeuver(Unit*);
-        virtual CombatManeuverReturns DoNextCombatManeuver(Unit*);
-        bool Pull() { DEBUG_LOG("[PlayerbotAI]: Warning: Using PlayerbotClassAI::Pull() rather than class specific function"); return false; }
-        bool Neutralize() { DEBUG_LOG("[PlayerbotAI]: Warning: Using PlayerbotClassAI::Neutralize() rather than class specific function"); return false; }
-
-        // all non combat actions go here, ex buffs, heals, rezzes
-        virtual void DoNonCombatActions();
-        bool EatDrinkBandage(bool bMana = true, unsigned char foodPercent = 50, unsigned char drinkPercent = 50, unsigned char bandagePercent = 70);
-
-        // Utilities
-        Player* GetMaster() { return m_master; }
-        Player* GetPlayerBot() { return m_bot; }
-        PlayerbotAI* GetAI() { return m_ai; }
-        bool CanPull();
-        bool CastHoTOnTank();
-        time_t GetWaitUntil() { return m_WaitUntil; }
-        void SetWait(uint8 t) { m_WaitUntil = m_ai->CurrentTime() + t; }
-        void ClearWait() { m_WaitUntil = 0; }
-        //void SetWaitUntil(time_t t) { m_WaitUntil = t; }
-
-    protected:
-        virtual CombatManeuverReturns DoFirstCombatManeuverPVE(Unit*);
-        virtual CombatManeuverReturns DoNextCombatManeuverPVE(Unit*);
-        virtual CombatManeuverReturns DoFirstCombatManeuverPVP(Unit*);
-        virtual CombatManeuverReturns DoNextCombatManeuverPVP(Unit*);
-
-        CombatManeuverReturns CastSpellNoRanged(uint32 nextAction, Unit* pTarget);
-        CombatManeuverReturns CastSpellWand(uint32 nextAction, Unit* pTarget, uint32 SHOOT);
-        virtual CombatManeuverReturns HealPlayer(Player* target);
-        CombatManeuverReturns Buff(bool (*BuffHelper)(PlayerbotAI*, uint32, Unit*), uint32 spellId, uint32 type = JOB_ALL, bool bMustBeOOC = true);
-        bool NeedGroupBuff(uint32 groupBuffSpellId, uint32 singleBuffSpellId);
-        Player* GetHealTarget(JOB_TYPE type = JOB_ALL);
-        Player* GetDispelTarget(DispelType dispelType, JOB_TYPE type = JOB_ALL, bool bMustBeOOC = false);
-        Player* GetResurrectionTarget(JOB_TYPE type = JOB_ALL, bool bMustBeOOC = true);
-        JOB_TYPE GetTargetJob(Player* target);
-
-        bool FleeFromAoEIfCan(uint32 spellId, Unit* pTarget);
-        bool FleeFromTrapGOIfCan(uint32 goEntry, Unit* pTarget);
-        bool FleeFromNpcWithAuraIfCan(uint32 NpcEntry, uint32 spellId, Unit* pTarget);
-        bool FleeFromPointIfCan(uint32 radius, Unit* pTarget, float x0, float y0, float z0, float forcedAngle = 0.0f);
-
-        // These values are used in GetHealTarget and can be overridden per class (to accomodate healing spell health checks)
-        uint8 m_MinHealthPercentTank;
-        uint8 m_MinHealthPercentHealer;
-        uint8 m_MinHealthPercentDPS;
-        uint8 m_MinHealthPercentMaster;
-
-        time_t m_WaitUntil;
-
-        Player* m_master;
-        Player* m_bot;
-        PlayerbotAI* m_ai;
-
-        // first aid
-        uint32 RECENTLY_BANDAGED;
-};
-
-#endif
diff --git a/src/game/PlayerBot/Base/PlayerbotMgr.cpp b/src/game/PlayerBot/Base/PlayerbotMgr.cpp
deleted file mode 100644
index a22045ec0..000000000
--- a/src/game/PlayerBot/Base/PlayerbotMgr.cpp
+++ /dev/null
@@ -1,1149 +0,0 @@
-/*
- * This file is part of the CMaNGOS Project. See AUTHORS file for Copyright information
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "Config/Config.h"
-#include "WorldPacket.h"
-#include "PlayerbotAI.h"
-#include "PlayerbotMgr.h"
-#include "../config.h"
-#include "../../Chat/Chat.h"
-#include "../../Entities/GossipDef.h"
-#include "../../Entities/Player.h"
-#include "../../Globals/ObjectMgr.h"
-#include "../../Globals/ObjectAccessor.h"
-#include "../../Guilds/Guild.h"
-#include "../../Loot/LootMgr.h"
-#include "../../MotionGenerators/WaypointMovementGenerator.h"
-#include "../../Tools/Language.h"
-
-class LoginQueryHolder;
-class CharacterHandler;
-
-Config botConfig;
-
-void PlayerbotMgr::SetInitialWorldSettings()
-{
-    //Get playerbot configuration file
-    if (!botConfig.SetSource(_PLAYERBOT_CONFIG))
-        sLog.outError("Playerbot: Unable to open configuration file. Database will be unaccessible. Configuration values will use default.");
-    else
-        sLog.outString("Playerbot: Using configuration file %s", _PLAYERBOT_CONFIG);
-
-    //Check playerbot config file version
-    if (botConfig.GetIntDefault("ConfVersion", 0) != PLAYERBOT_CONF_VERSION)
-        sLog.outError("Playerbot: Configuration file version doesn't match expected version. Some config variables may be wrong or missing.");
-}
-
-PlayerbotMgr::PlayerbotMgr(Player* const master) : m_master(master)
-{
-    // load config variables
-    m_confMaxNumBots = botConfig.GetIntDefault("PlayerbotAI.MaxNumBots", 9);
-    m_confDebugWhisper = botConfig.GetBoolDefault("PlayerbotAI.DebugWhisper", false);
-    m_confFollowDistance[0] = botConfig.GetFloatDefault("PlayerbotAI.FollowDistanceMin", 0.5f);
-    m_confFollowDistance[1] = botConfig.GetFloatDefault("PlayerbotAI.FollowDistanceMax", 1.0f);
-    m_confCollectCombat = botConfig.GetBoolDefault("PlayerbotAI.Collect.Combat", true);
-    m_confCollectQuest = botConfig.GetBoolDefault("PlayerbotAI.Collect.Quest", true);
-    m_confCollectProfession = botConfig.GetBoolDefault("PlayerbotAI.Collect.Profession", true);
-    m_confCollectLoot = botConfig.GetBoolDefault("PlayerbotAI.Collect.Loot", true);
-    m_confCollectSkin = botConfig.GetBoolDefault("PlayerbotAI.Collect.Skin", true);
-    m_confCollectObjects = botConfig.GetBoolDefault("PlayerbotAI.Collect.Objects", true);
-    m_confCollectDistanceMax = botConfig.GetIntDefault("PlayerbotAI.Collect.DistanceMax", 50);
-    gConfigSellLevelDiff = botConfig.GetIntDefault("PlayerbotAI.SellAll.LevelDiff", 10);
-    if (m_confCollectDistanceMax > 100)
-    {
-        sLog.outError("Playerbot: PlayerbotAI.Collect.DistanceMax higher than allowed. Using 100");
-        m_confCollectDistanceMax = 100;
-    }
-    m_confCollectDistance = botConfig.GetIntDefault("PlayerbotAI.Collect.Distance", 25);
-    if (m_confCollectDistance > m_confCollectDistanceMax)
-    {
-        sLog.outError("Playerbot: PlayerbotAI.Collect.Distance higher than PlayerbotAI.Collect.DistanceMax. Using DistanceMax value");
-        m_confCollectDistance = m_confCollectDistanceMax;
-    }
-}
-
-PlayerbotMgr::~PlayerbotMgr()
-{
-    LogoutAllBots();
-}
-
-void PlayerbotMgr::UpdateAI(const uint32 p_time) {}
-
-void PlayerbotMgr::HandleMasterIncomingPacket(const WorldPacket& packet)
-{
-    switch (packet.GetOpcode())
-    {
-        case CMSG_OFFER_PETITION:
-        {
-            WorldPacket p(packet);
-            p.rpos(0);    // reset reader
-            ObjectGuid petitionGuid;
-            ObjectGuid playerGuid;
-            uint32 junk;
-
-            p >> junk;                                      // this is not petition type!
-            p >> petitionGuid;                              // petition guid
-            p >> playerGuid;                                // player guid
-
-            Player* player = ObjectAccessor::FindPlayer(playerGuid);
-            if (!player)
-                return;
-
-            uint32 petitionLowGuid = petitionGuid.GetCounter();
-
-            QueryResult* result = CharacterDatabase.PQuery("SELECT * FROM petition_sign WHERE playerguid = '%u' AND petitionguid = '%u'", player->GetGUIDLow(), petitionLowGuid);
-
-            if (result)
-            {
-                ChatHandler(m_master).PSendSysMessage("%s has already signed the petition", player->GetName());
-                delete result;
-                return;
-            }
-
-            CharacterDatabase.PExecute("INSERT INTO petition_sign (ownerguid,petitionguid, playerguid, player_account) VALUES ('%u', '%u', '%u','%u')",
-                                       GetMaster()->GetGUIDLow(), petitionLowGuid, player->GetGUIDLow(), GetMaster()->GetSession()->GetAccountId());
-
-            p.Initialize(SMSG_PETITION_SIGN_RESULTS, (8 + 8 + 4));
-            p << ObjectGuid(petitionGuid);
-            p << ObjectGuid(playerGuid);
-            p << uint32(PETITION_SIGN_OK);
-
-            // close at signer side
-            GetMaster()->GetSession()->SendPacket(p);
-
-            return;
-        }
-
-        case CMSG_ACTIVATETAXI:
-        {
-            WorldPacket p(packet);
-            p.rpos(0); // reset reader
-
-            ObjectGuid guid;
-            std::vector<uint32> nodes;
-            nodes.resize(2);
-            uint8 delay = 9;
-            p >> guid >> nodes[0] >> nodes[1];
-
-            // DEBUG_LOG ("[PlayerbotMgr]: HandleMasterIncomingPacket - Received CMSG_ACTIVATETAXI from %d to %d", nodes[0], nodes[1]);
-
-            for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
-            {
-
-                delay = delay + 3;
-                Player* const bot = it->second;
-                if (!bot)
-                    return;
-
-                Group* group = bot->GetGroup();
-                if (!group)
-                    continue;
-
-                Unit* target = ObjectAccessor::GetUnit(*bot, guid);
-
-                bot->GetPlayerbotAI()->SetIgnoreUpdateTime(delay);
-
-                bot->GetMotionMaster()->Clear(true);
-                bot->GetMotionMaster()->MoveFollow(target, INTERACTION_DISTANCE, bot->GetOrientation());
-                bot->GetPlayerbotAI()->GetTaxi(guid, nodes);
-            }
-            return;
-        }
-
-        case CMSG_ACTIVATETAXIEXPRESS:
-        {
-            WorldPacket p(packet);
-            p.rpos(0); // reset reader
-
-            ObjectGuid guid;
-            uint32 node_count;
-            uint8 delay = 9;
-
-            p >> guid;
-            p.read_skip<uint32>();
-            p >> node_count;
-
-            std::vector<uint32> nodes;
-            for (uint32 i = 0; i < node_count; ++i)
-            {
-                uint32 node;
-                p >> node;
-                nodes.push_back(node);
-            }
-
-            if (nodes.empty())
-                return;
-
-            // DEBUG_LOG ("[PlayerbotMgr]: HandleMasterIncomingPacket - Received CMSG_ACTIVATETAXIEXPRESS from %d to %d", nodes.front(), nodes.back());
-
-            for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
-            {
-
-                delay = delay + 3;
-                Player* const bot = it->second;
-                if (!bot)
-                    return;
-                Group* group = bot->GetGroup();
-                if (!group)
-                    continue;
-                Unit* target = ObjectAccessor::GetUnit(*bot, guid);
-
-                bot->GetPlayerbotAI()->SetIgnoreUpdateTime(delay);
-
-                bot->GetMotionMaster()->Clear(true);
-                bot->GetMotionMaster()->MoveFollow(target, INTERACTION_DISTANCE, bot->GetOrientation());
-                bot->GetPlayerbotAI()->GetTaxi(guid, nodes);
-            }
-            return;
-        }
-
-        // if master is logging out, log out all bots
-        case CMSG_LOGOUT_REQUEST:
-        {
-            LogoutAllBots();
-            return;
-        }
-
-        // If master inspects one of his bots, give the master useful info in chat window
-        // such as inventory that can be equipped
-        case CMSG_INSPECT:
-        {
-            WorldPacket p(packet);
-            p.rpos(0); // reset reader
-            ObjectGuid guid;
-            p >> guid;
-            Player* const bot = GetPlayerBot(guid);
-            if (bot) bot->GetPlayerbotAI()->SendNotEquipList(*bot);
-            return;
-        }
-
-        // handle emotes from the master
-        //case CMSG_EMOTE:
-        case CMSG_TEXT_EMOTE:
-        {
-            WorldPacket p(packet);
-            p.rpos(0); // reset reader
-            uint32 emoteNum;
-            p >> emoteNum;
-
-            /* std::ostringstream out;
-            out << "emote is: " << emoteNum;
-            ChatHandler ch(m_master);
-            ch.SendSysMessage(out.str().c_str()); */
-
-            switch (emoteNum)
-            {
-                case TEXTEMOTE_BOW:
-                {
-                    // Buff anyone who bows before me. Useful for players not in bot's group
-                    // How do I get correct target???
-                    //Player* const pPlayer = GetPlayerBot(m_master->GetSelection());
-                    //if (pPlayer->GetPlayerbotAI()->GetClassAI())
-                    //    pPlayer->GetPlayerbotAI()->GetClassAI()->BuffPlayer(pPlayer);
-                    return;
-                }
-                /*
-                case TEXTEMOTE_BONK:
-                {
-                Player* const pPlayer = GetPlayerBot(m_master->GetSelection());
-                if (!pPlayer || !pPlayer->GetPlayerbotAI())
-                return;
-                PlayerbotAI* const pBot = pPlayer->GetPlayerbotAI();
-
-                ChatHandler ch(m_master);
-                {
-                std::ostringstream out;
-                out << "CurrentTime: " << CurrentTime()
-                << " m_ignoreAIUpdatesUntilTime: " << pBot->m_ignoreAIUpdatesUntilTime;
-                ch.SendSysMessage(out.str().c_str());
-                }
-                {
-                std::ostringstream out;
-                out << "m_TimeDoneEating: " << pBot->m_TimeDoneEating
-                << " m_TimeDoneDrinking: " << pBot->m_TimeDoneDrinking;
-                ch.SendSysMessage(out.str().c_str());
-                }
-                {
-                std::ostringstream out;
-                out << "m_CurrentlyCastingSpellId: " << pBot->m_CurrentlyCastingSpellId;
-                ch.SendSysMessage(out.str().c_str());
-                }
-                {
-                std::ostringstream out;
-                out << "IsBeingTeleported() " << pBot->GetPlayer()->IsBeingTeleported();
-                ch.SendSysMessage(out.str().c_str());
-                }
-                {
-                std::ostringstream out;
-                bool tradeActive = (pBot->GetPlayer()->GetTrader()) ? true : false;
-                out << "tradeActive: " << tradeActive;
-                ch.SendSysMessage(out.str().c_str());
-                }
-                {
-                std::ostringstream out;
-                out << "IsCharmed() " << pBot->getPlayer()->isCharmed();
-                ch.SendSysMessage(out.str().c_str());
-                }
-                return;
-                }
-                */
-
-                case TEXTEMOTE_EAT:
-                case TEXTEMOTE_DRINK:
-                    return;
-
-                // emote to attack selected target
-                case TEXTEMOTE_POINT:
-                {
-                    ObjectGuid attackOnGuid = m_master->GetSelectionGuid();
-                    if (!attackOnGuid)
-                        return;
-
-                    Unit* thingToAttack = ObjectAccessor::GetUnit(*m_master, attackOnGuid);
-                    if (!thingToAttack) return;
-
-                    Player* bot = 0;
-                    for (PlayerBotMap::iterator itr = m_playerBots.begin(); itr != m_playerBots.end(); ++itr)
-                    {
-                        bot = itr->second;
-                        if (bot->CanAttack(thingToAttack))
-                        {
-                            if (!bot->IsWithinLOSInMap(thingToAttack))
-                                bot->GetPlayerbotAI()->DoTeleport(*m_master);
-                            if (bot->IsWithinLOSInMap(thingToAttack))
-                                bot->GetPlayerbotAI()->Attack(thingToAttack);
-                        }
-                    }
-                    return;
-                }
-
-                // emote to stay
-                case TEXTEMOTE_STAND:
-                {
-                    Player* const bot = GetPlayerBot(m_master->GetSelectionGuid());
-                    if (bot)
-                        bot->GetPlayerbotAI()->SetMovementOrder(PlayerbotAI::MOVEMENT_STAY);
-                    else
-                        for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
-                        {
-                            Player* const bot = it->second;
-                            bot->GetPlayerbotAI()->SetMovementOrder(PlayerbotAI::MOVEMENT_STAY);
-                        }
-                    return;
-                }
-
-                // 324 is the followme emote (not defined in enum)
-                // if master has bot selected then only bot follows, else all bots follow
-                case 324:
-                case TEXTEMOTE_WAVE:
-                {
-                    Player* const bot = GetPlayerBot(m_master->GetSelectionGuid());
-                    if (bot)
-                        bot->GetPlayerbotAI()->SetMovementOrder(PlayerbotAI::MOVEMENT_FOLLOW, m_master);
-                    else
-                        for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
-                        {
-                            Player* const bot = it->second;
-                            bot->GetPlayerbotAI()->SetMovementOrder(PlayerbotAI::MOVEMENT_FOLLOW, m_master);
-                        }
-                    return;
-                }
-            }
-            return;
-            } /* EMOTE ends here */
-
-        case CMSG_GAMEOBJ_USE: // Used by bots to turn in quest to GameObjects when also used by master
-        {
-            WorldPacket p(packet);
-            p.rpos(0);     // reset reader
-            ObjectGuid objGUID;
-            p >> objGUID;
-
-            for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
-            {
-                Player* const bot = it->second;
-
-                // If player and bot are on different maps: then player was teleported by GameObject
-                // let's return and let playerbot summon do its job by teleporting bots
-                if (bot->GetMap() != m_master->GetMap())
-                    return;
-
-                GameObject* obj = m_master->GetMap()->GetGameObject(objGUID);
-                if (!obj)
-                    return;
-
-                bot->GetPlayerbotAI()->FollowAutoReset();
-
-                if (obj->GetGoType() == GAMEOBJECT_TYPE_QUESTGIVER)
-                    bot->GetPlayerbotAI()->TurnInQuests(obj);
-                // add other go types here, i.e.:
-                // GAMEOBJECT_TYPE_CHEST - loot quest items of chest
-            }
-        }
-        break;
-
-        case CMSG_QUESTGIVER_HELLO:
-        {
-            WorldPacket p(packet);
-            p.rpos(0);    // reset reader
-            ObjectGuid npcGUID;
-            p >> npcGUID;
-            WorldObject* pNpc = m_master->GetMap()->GetWorldObject(npcGUID);
-            if (!pNpc)
-                return;
-
-            // for all master's bots
-            for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
-            {
-                Player* const bot = it->second;
-                bot->GetPlayerbotAI()->FollowAutoReset();
-                bot->GetPlayerbotAI()->TurnInQuests(pNpc);
-            }
-
-            return;
-        }
-
-        // if master accepts a quest, bots should also try to accept quest
-        case CMSG_QUESTGIVER_ACCEPT_QUEST:
-        {
-            WorldPacket p(packet);
-            p.rpos(0);    // reset reader
-            ObjectGuid guid;
-            uint32 quest;
-            // uint32 unk1;
-            p >> guid >> quest; // >> unk1;
-
-            // DEBUG_LOG ("[PlayerbotMgr]: HandleMasterIncomingPacket - Received CMSG_QUESTGIVER_ACCEPT_QUEST npc = %s, quest = %u, unk1 = %u", guid.GetString().c_str(), quest, unk1);
-
-            Quest const* qInfo = sObjectMgr.GetQuestTemplate(quest);
-            if (qInfo)
-                for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
-                {
-                    Player* const bot = it->second;
-                    bot->GetPlayerbotAI()->FollowAutoReset();
-                    if (bot->GetQuestStatus(quest) == QUEST_STATUS_COMPLETE)
-                        bot->GetPlayerbotAI()->TellMaster("I already completed that quest.");
-                    else if (!bot->CanTakeQuest(qInfo, false))
-                    {
-                        if (!bot->SatisfyQuestStatus(qInfo, false))
-                            bot->GetPlayerbotAI()->TellMaster("I already have that quest.");
-                        else
-                            bot->GetPlayerbotAI()->TellMaster("I can't take that quest.");
-                    }
-                    else if (!bot->SatisfyQuestLog(false))
-                        bot->GetPlayerbotAI()->TellMaster("My quest log is full.");
-                    else if (!bot->CanAddQuest(qInfo, false))
-                        bot->GetPlayerbotAI()->TellMaster("I can't take that quest because it requires that I take items, but my bags are full!");
-
-                    else
-                    {
-                        p.rpos(0);         // reset reader
-                        bot->GetSession()->HandleQuestgiverAcceptQuestOpcode(p);
-                        bot->GetPlayerbotAI()->TellMaster("Got the quest.");
-
-                        // build needed items if quest contains any
-                        for (int i = 0; i < QUEST_ITEM_OBJECTIVES_COUNT; i++)
-                            if (qInfo->ReqItemCount[i] > 0)
-                            {
-                                bot->GetPlayerbotAI()->SetQuestNeedItems();
-                                break;
-                            }
-
-                        // build needed creatures if quest contains any
-                        for (int i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
-                            if (qInfo->ReqCreatureOrGOCount[i] > 0)
-                            {
-                                bot->GetPlayerbotAI()->SetQuestNeedCreatures();
-                                break;
-                            }
-                    }
-                }
-            return;
-        }
-
-        case CMSG_AREATRIGGER:
-        {
-            WorldPacket p(packet);
-
-            for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
-            {
-                Player* const bot = it->second;
-                if (!bot)
-                    continue;
-
-                if (bot->IsWithinDistInMap(GetMaster(), 50))
-                {
-                    p.rpos(0);         // reset reader
-                    bot->GetSession()->HandleAreaTriggerOpcode(p);
-                }
-            }
-            return;
-        }
-
-        case CMSG_QUESTGIVER_COMPLETE_QUEST:
-        {
-            WorldPacket p(packet);
-            p.rpos(0);    // reset reader
-            uint32 quest;
-            ObjectGuid npcGUID;
-            p >> npcGUID >> quest;
-
-            // DEBUG_LOG ("[PlayerbotMgr]: HandleMasterIncomingPacket - Received CMSG_QUESTGIVER_COMPLETE_QUEST npc = %s, quest = %u", npcGUID.GetString().c_str(), quest);
-
-            WorldObject* pNpc = m_master->GetMap()->GetWorldObject(npcGUID);
-            if (!pNpc)
-                return;
-
-            // for all master's bots
-            for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
-            {
-                Player* const bot = it->second;
-                bot->GetPlayerbotAI()->FollowAutoReset();
-                bot->GetPlayerbotAI()->TurnInQuests(pNpc);
-            }
-            return;
-        }
-
-        case CMSG_LOOT_ROLL:
-        {
-            WorldPacket p(packet);  //WorldPacket packet for CMSG_LOOT_ROLL, (8+4+1)
-            ObjectGuid Guid;
-            uint32 itemSlot;
-            uint8 rollType;
-
-            p.rpos(0);              //reset packet pointer
-            p >> Guid;              //guid of the lootable target
-            p >> itemSlot;          //loot index
-            p >> rollType;          //need,greed or pass on roll
-
-            for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
-            {
-                uint32 choice = 0;
-
-                Player* const bot = it->second;
-                if (!bot)
-                    return;
-
-                Group* group = bot->GetGroup();
-                if (!group)
-                    return;
-
-                // check that the bot did not already vote
-                if (rollType >= ROLL_NOT_EMITED_YET)
-                    return;
-
-                Loot* loot = sLootMgr.GetLoot(bot, Guid);
-
-                if (!loot)
-                {
-                    sLog.outError("LootMgr::PlayerVote> Error cannot get loot object info!");
-                    return;
-                }
-
-                LootItem* lootItem = loot->GetLootItemInSlot(itemSlot);
-
-                ItemPrototype const* pProto = lootItem->itemProto;
-                if (!pProto)
-                    return;
-
-                if (bot->GetPlayerbotAI()->CanStore())
-                {
-                    if (bot->CanUseItem(pProto) == EQUIP_ERR_OK && bot->GetPlayerbotAI()->IsItemUseful(lootItem->itemId))
-                        choice = 1; // Need
-                    else if (bot->HasSkill(SKILL_ENCHANTING))
-                        choice = 3; // Disenchant
-                    else
-                        choice = 2; // Greed
-                }
-                else
-                    choice = 0;     // Pass
-
-                sLootMgr.PlayerVote(bot, Guid, itemSlot, RollVote(choice));
-            }
-            return;
-        }
-        // Handle GOSSIP activate actions, prior to GOSSIP select menu actions
-        case CMSG_GOSSIP_HELLO:
-        {
-            // DEBUG_LOG ("[PlayerbotMgr]: HandleMasterIncomingPacket - Received CMSG_GOSSIP_HELLO");
-
-            WorldPacket p(packet);    //WorldPacket packet for CMSG_GOSSIP_HELLO, (8)
-            ObjectGuid guid;
-            p.rpos(0);                //reset packet pointer
-            p >> guid;
-            for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
-            {
-                Player* const bot = it->second;
-                if (!bot)
-                    continue;
-                bot->GetPlayerbotAI()->FollowAutoReset();
-                Creature* pCreature = bot->GetNPCIfCanInteractWith(guid, UNIT_NPC_FLAG_NONE);
-                if (!pCreature)
-                {
-                    DEBUG_LOG("[PlayerbotMgr]: HandleMasterIncomingPacket - Received  CMSG_GOSSIP_HELLO %s not found or you can't interact with him.", guid.GetString().c_str());
-                    continue;
-                }
-
-                GossipMenuItemsMapBounds pMenuItemBounds = sObjectMgr.GetGossipMenuItemsMapBounds(pCreature->GetCreatureInfo()->GossipMenuId);
-                for (GossipMenuItemsMap::const_iterator itr = pMenuItemBounds.first; itr != pMenuItemBounds.second; ++itr)
-                {
-                    uint32 npcflags = pCreature->GetUInt32Value(UNIT_NPC_FLAGS);
-
-                    if (!(itr->second.npc_option_npcflag & npcflags))
-                        continue;
-
-                    switch (itr->second.option_id)
-                    {
-                        case GOSSIP_OPTION_TAXIVENDOR:
-                        {
-                            // bot->GetPlayerbotAI()->TellMaster("PlayerbotMgr:GOSSIP_OPTION_TAXIVENDOR");
-                            bot->GetSession()->SendLearnNewTaxiNode(pCreature);
-                            break;
-                        }
-                        case GOSSIP_OPTION_QUESTGIVER:
-                        {
-                            // bot->GetPlayerbotAI()->TellMaster("PlayerbotMgr:GOSSIP_OPTION_QUESTGIVER");
-                            bot->GetPlayerbotAI()->TurnInQuests(pCreature);
-                            break;
-                        }
-                        case GOSSIP_OPTION_VENDOR:
-                        {
-                            // bot->GetPlayerbotAI()->TellMaster("PlayerbotMgr:GOSSIP_OPTION_VENDOR");
-                            if (!botConfig.GetBoolDefault("PlayerbotAI.SellGarbage", true))
-                                continue;
-
-                            // changed the SellGarbage() function to support ch.SendSysMessaage()
-                            bot->GetPlayerbotAI()->SellGarbage(*bot);
-                            break;
-                        }
-                        case GOSSIP_OPTION_STABLEPET:
-                        {
-                            // bot->GetPlayerbotAI()->TellMaster("PlayerbotMgr:GOSSIP_OPTION_STABLEPET");
-                            break;
-                        }
-                        case GOSSIP_OPTION_AUCTIONEER:
-                        {
-                            // bot->GetPlayerbotAI()->TellMaster("PlayerbotMgr:GOSSIP_OPTION_AUCTIONEER");
-                            break;
-                        }
-                        case GOSSIP_OPTION_BANKER:
-                        {
-                            // bot->GetPlayerbotAI()->TellMaster("PlayerbotMgr:GOSSIP_OPTION_BANKER");
-                            break;
-                        }
-                        case GOSSIP_OPTION_INNKEEPER:
-                        {
-                            // bot->GetPlayerbotAI()->TellMaster("PlayerbotMgr:GOSSIP_OPTION_INNKEEPER");
-                            break;
-                        }
-                    }
-                }
-            }
-            return;
-        }
-
-        case CMSG_SPIRIT_HEALER_ACTIVATE:
-        {
-            // DEBUG_LOG ("[PlayerbotMgr]: HandleMasterIncomingPacket - Received CMSG_SPIRIT_HEALER_ACTIVATE SpiritHealer is resurrecting the Player %s",m_master->GetName());
-            for (PlayerBotMap::iterator itr = m_playerBots.begin(); itr != m_playerBots.end(); ++itr)
-            {
-                Player* const bot = itr->second;
-                Group* grp = bot->GetGroup();
-                if (grp)
-                    grp->RemoveMember(bot->GetObjectGuid(), 1);
-            }
-            return;
-        }
-
-        case CMSG_LIST_INVENTORY:
-        {
-            if (!botConfig.GetBoolDefault("PlayerbotAI.SellGarbage", true))
-                return;
-
-            WorldPacket p(packet);
-            p.rpos(0);  // reset reader
-            ObjectGuid npcGUID;
-            p >> npcGUID;
-
-            Object* const pNpc = (WorldObject*) m_master->GetObjectByTypeMask(npcGUID, TYPEMASK_CREATURE_OR_GAMEOBJECT);
-            if (!pNpc)
-                return;
-
-            // for all master's bots
-            for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
-            {
-                Player* const bot = it->second;
-                if (!bot->IsInMap(static_cast<WorldObject*>(pNpc)))
-                {
-                    bot->GetPlayerbotAI()->TellMaster("I'm too far away to sell items!");
-                    continue;
-                }
-                else
-                {
-                    // changed the SellGarbage() function to support ch.SendSysMessaage()
-                    bot->GetPlayerbotAI()->FollowAutoReset();
-                    bot->GetPlayerbotAI()->SellGarbage(*bot);
-                }
-            }
-            return;
-        }
-
-        /*
-        case CMSG_NAME_QUERY:
-        case MSG_MOVE_START_FORWARD:
-        case MSG_MOVE_STOP:
-        case MSG_MOVE_SET_FACING:
-        case MSG_MOVE_START_STRAFE_LEFT:
-        case MSG_MOVE_START_STRAFE_RIGHT:
-        case MSG_MOVE_STOP_STRAFE:
-        case MSG_MOVE_START_BACKWARD:
-        case MSG_MOVE_HEARTBEAT:
-        case CMSG_STANDSTATECHANGE:
-        case CMSG_QUERY_TIME:
-        case CMSG_CREATURE_QUERY:
-        case CMSG_GAMEOBJECT_QUERY:
-        case MSG_MOVE_JUMP:
-        case MSG_MOVE_FALL_LAND:
-        return;*/
-
-        default:
-        {
-            /*const char* oc = LookupOpcodeName(packet.GetOpcode());
-            // ChatHandler ch(m_master);
-            // ch.SendSysMessage(oc);
-
-            std::ostringstream out;
-            out << "masterin: " << oc;
-            sLog.outError(out.str().c_str()); */
-        }
-    }
-}
-
-void PlayerbotMgr::HandleMasterOutgoingPacket(const WorldPacket& packet)
-{
-    /*
-    switch (packet.GetOpcode())
-    {
-    // maybe our bots should only start looting after the master loots?
-    //case SMSG_LOOT_RELEASE_RESPONSE: {}
-    case SMSG_NAME_QUERY_RESPONSE:
-    case SMSG_MONSTER_MOVE:
-    case SMSG_COMPRESSED_UPDATE_OBJECT:
-    case SMSG_DESTROY_OBJECT:
-    case SMSG_UPDATE_OBJECT:
-    case SMSG_STANDSTATE_UPDATE:
-    case MSG_MOVE_HEARTBEAT:
-    case SMSG_QUERY_TIME_RESPONSE:
-    case SMSG_AURA_UPDATE_ALL:
-    case SMSG_CREATURE_QUERY_RESPONSE:
-    case SMSG_GAMEOBJECT_QUERY_RESPONSE:
-    return;
-    default:
-    {
-    const char* oc = LookupOpcodeName(packet.GetOpcode());
-
-    std::ostringstream out;
-    out << "masterout: " << oc;
-    sLog.outError(out.str().c_str());
-    }
-    }
-    */
-}
-
-void PlayerbotMgr::LogoutAllBots()
-{
-    while (true)
-    {
-        PlayerBotMap::const_iterator itr = GetPlayerBotsBegin();
-        if (itr == GetPlayerBotsEnd()) break;
-        Player* bot = itr->second;
-        LogoutPlayerBot(bot->GetObjectGuid());
-    }
-    RemoveAllBotsFromGroup();
-}
-
-
-
-void PlayerbotMgr::Stay()
-{
-    for (PlayerBotMap::const_iterator itr = GetPlayerBotsBegin(); itr != GetPlayerBotsEnd(); ++itr)
-    {
-        Player* bot = itr->second;
-        bot->GetMotionMaster()->Clear();
-    }
-}
-
-
-// Playerbot mod: logs out a Playerbot.
-void PlayerbotMgr::LogoutPlayerBot(ObjectGuid guid)
-{
-    Player* bot = GetPlayerBot(guid);
-    if (bot)
-    {
-        WorldSession* botWorldSessionPtr = bot->GetSession();
-        m_playerBots.erase(guid);    // deletes bot player ptr inside this WorldSession PlayerBotMap
-        botWorldSessionPtr->LogoutPlayer(true); // this will delete the bot Player object and PlayerbotAI object
-        delete botWorldSessionPtr;  // finally delete the bot's WorldSession
-    }
-}
-
-// Playerbot mod: Gets a player bot Player object for this WorldSession master
-Player* PlayerbotMgr::GetPlayerBot(ObjectGuid playerGuid) const
-{
-    PlayerBotMap::const_iterator it = m_playerBots.find(playerGuid);
-    return (it == m_playerBots.end()) ? 0 : it->second;
-}
-
-void PlayerbotMgr::OnBotLogin(Player* const bot)
-{
-    // give the bot some AI, object is owned by the player class
-    PlayerbotAI* ai = new PlayerbotAI(this, bot);
-    bot->SetPlayerbotAI(ai);
-
-    // tell the world session that they now manage this new bot
-    m_playerBots[bot->GetObjectGuid()] = bot;
-
-    // if bot is in a group and master is not in group then
-    // have bot leave their group
-    if (bot->GetGroup() &&
-            (m_master->GetGroup() == nullptr ||
-             m_master->GetGroup()->IsMember(bot->GetObjectGuid()) == false))
-        bot->RemoveFromGroup();
-
-    // sometimes master can lose leadership, pass leadership to master check
-    const ObjectGuid masterGuid = m_master->GetObjectGuid();
-    if (m_master->GetGroup() &&
-            !m_master->GetGroup()->IsLeader(masterGuid))
-    {
-        // But only do so if one of the master's bots is leader
-        for (PlayerBotMap::const_iterator itr = GetPlayerBotsBegin(); itr != GetPlayerBotsEnd(); itr++)
-        {
-            Player* bot = itr->second;
-            if (m_master->GetGroup()->IsLeader(bot->GetObjectGuid()))
-            {
-                m_master->GetGroup()->ChangeLeader(masterGuid);
-                break;
-            }
-        }
-    }
-}
-
-void PlayerbotMgr::RemoveAllBotsFromGroup()
-{
-    for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); m_master->GetGroup() && it != GetPlayerBotsEnd(); ++it)
-    {
-        Player* const bot = it->second;
-        if (bot->IsInGroup(m_master))
-            m_master->GetGroup()->RemoveMember(bot->GetObjectGuid(), 0);
-    }
-}
-
-void Creature::LoadBotMenu(Player* pPlayer)
-{
-
-    if (pPlayer->GetPlayerbotAI()) return;
-    ObjectGuid guid = pPlayer->GetObjectGuid();
-    uint32 accountId = sObjectMgr.GetPlayerAccountIdByGUID(guid);
-    QueryResult* result = CharacterDatabase.PQuery("SELECT guid, name FROM characters WHERE account='%d'", accountId);
-    do
-    {
-        Field* fields = result->Fetch();
-        ObjectGuid guidlo = ObjectGuid(fields[0].GetUInt64());
-        std::string name = fields[1].GetString();
-        std::string word = "";
-
-        if ((guid == ObjectGuid()) || (guid == guidlo))
-        {
-            //not found or himself
-        }
-        else
-        {
-            // if(sConfig.GetBoolDefault("PlayerbotAI.DisableBots", false)) return;
-            // create the manager if it doesn't already exist
-            if (!pPlayer->GetPlayerbotMgr())
-                pPlayer->SetPlayerbotMgr(new PlayerbotMgr(pPlayer));
-            if (pPlayer->GetPlayerbotMgr()->GetPlayerBot(guidlo) == nullptr) // add (if not already in game)
-            {
-                word += "Recruit ";
-                word += name;
-                word += " as a Bot.";
-                pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem((uint8) 9, word, guidlo, GOSSIP_OPTION_BOT, word, false);
-            }
-            else if (pPlayer->GetPlayerbotMgr()->GetPlayerBot(guidlo) != nullptr) // remove (if in game)
-            {
-                word += "Dismiss ";
-                word += name;
-                word += " from duty.";
-                pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem((uint8) 0, word, guidlo, GOSSIP_OPTION_BOT, word, false);
-            }
-        }
-    }
-    while (result->NextRow());
-    delete result;
-}
-
-void Player::skill(std::list<uint32>& m_spellsToLearn)
-{
-    for (SkillStatusMap::const_iterator itr = mSkillStatus.begin(); itr != mSkillStatus.end(); ++itr)
-    {
-        if (itr->second.uState == SKILL_DELETED)
-            continue;
-
-        uint32 pskill = itr->first;
-
-        m_spellsToLearn.push_back(pskill);
-    }
-}
-
-void Player::chompAndTrim(std::string& str)
-{
-    while (str.length() > 0)
-    {
-        char lc = str[str.length() - 1];
-        if (lc == '\r' || lc == '\n' || lc == ' ' || lc == '"' || lc == '\'')
-            str = str.substr(0, str.length() - 1);
-        else
-            break;
-        while (str.length() > 0)
-        {
-            char lc = str[0];
-            if (lc == ' ' || lc == '"' || lc == '\'')
-                str = str.substr(1, str.length() - 1);
-            else
-                break;
-        }
-    }
-}
-
-bool Player::getNextQuestId(const std::string& pString, unsigned int& pStartPos, unsigned int& pId)
-{
-    bool result = false;
-    unsigned int i;
-    for (i = pStartPos; i < pString.size(); ++i)
-    {
-        if (pString[i] == ',')
-            break;
-    }
-    if (i > pStartPos)
-    {
-        std::string idString = pString.substr(pStartPos, i - pStartPos);
-        pStartPos = i + 1;
-        chompAndTrim(idString);
-        pId = atoi(idString.c_str());
-        result = true;
-    }
-    return (result);
-}
-
-bool Player::requiredQuests(const char* pQuestIdString)
-{
-    if (pQuestIdString != nullptr)
-    {
-        unsigned int pos = 0;
-        unsigned int id;
-        std::string confString(pQuestIdString);
-        chompAndTrim(confString);
-        while (getNextQuestId(confString, pos, id))
-        {
-            QuestStatus status = GetQuestStatus(id);
-            if (status == QUEST_STATUS_COMPLETE)
-                return true;
-        }
-    }
-    return false;
-}
-
-void Player::UpdateMail()
-{
-    // save money,items and mail to prevent cheating
-    CharacterDatabase.BeginTransaction();
-    this->SaveGoldToDB();
-    this->SaveInventoryAndGoldToDB();
-    this->_SaveMail();
-    CharacterDatabase.CommitTransaction();
-}
-
-//See MainSpec enum in PlayerbotAI.h for details on class return values
-uint32 Player::GetSpec()
-{
-    uint32 row = 0, spec = 0;
-    Player* player = m_session->GetPlayer();
-    uint32 classMask = player->getClassMask();
-
-    for (unsigned int i = 0; i < sTalentStore.GetNumRows(); ++i)
-    {
-        TalentEntry const* talentInfo = sTalentStore.LookupEntry(i);
-
-        if (!talentInfo)
-            continue;
-
-        TalentTabEntry const* talentTabInfo = sTalentTabStore.LookupEntry(talentInfo->TalentTab);
-
-        if (!talentTabInfo)
-            continue;
-
-        if ((classMask & talentTabInfo->ClassMask) == 0)
-            continue;
-
-        uint32 curtalent_maxrank = 0;
-        for (int32 k = MAX_TALENT_RANK - 1; k > -1; --k)
-        {
-            if (talentInfo->RankID[k] && HasSpell(talentInfo->RankID[k]))
-            {
-                if (row == 0 && spec == 0)
-                    spec = talentInfo->TalentTab;
-
-                if (talentInfo->Row > row)
-                {
-                    row = talentInfo->Row;
-                    spec = talentInfo->TalentTab;
-                }
-            }
-        }
-    }
-
-    //Return the tree with the deepest talent
-    return spec;
-}
-
-bool ChatHandler::HandlePlayerbotCommand(char* args)
-{
-    if (!(m_session->GetSecurity() > SEC_PLAYER))
-    {
-        if (botConfig.GetBoolDefault("PlayerbotAI.DisableBots", false))
-        {
-            PSendSysMessage("|cffff0000Playerbot system is currently disabled!");
-            SetSentErrorMessage(true);
-            return false;
-        }
-    }
-
-    if (!m_session)
-    {
-        PSendSysMessage("|cffff0000You may only add bots from an active session");
-        SetSentErrorMessage(true);
-        return false;
-    }
-
-    if (!*args)
-    {
-        PSendSysMessage("|cffff0000usage: add PLAYERNAME  or  remove PLAYERNAME");
-        SetSentErrorMessage(true);
-        return false;
-    }
-
-    char* cmd = strtok((char*) args, " ");
-    char* charname = strtok(nullptr, " ");
-    if (!cmd || !charname)
-    {
-        PSendSysMessage("|cffff0000usage: add PLAYERNAME  or  remove PLAYERNAME");
-        SetSentErrorMessage(true);
-        return false;
-    }
-
-    std::string cmdStr = cmd;
-    std::string charnameStr = charname;
-
-    if (!normalizePlayerName(charnameStr))
-        return false;
-
-    ObjectGuid guid = sObjectMgr.GetPlayerGuidByName(charnameStr.c_str());
-    if (guid == ObjectGuid() || (guid == m_session->GetPlayer()->GetObjectGuid()))
-    {
-        SendSysMessage(LANG_PLAYER_NOT_FOUND);
-        SetSentErrorMessage(true);
-        return false;
-    }
-
-    uint32 accountId = sObjectMgr.GetPlayerAccountIdByGUID(guid);
-    if (accountId != m_session->GetAccountId())
-    {
-        PSendSysMessage("|cffff0000You may only add bots from the same account.");
-        SetSentErrorMessage(true);
-        return false;
-    }
-
-    // create the playerbot manager if it doesn't already exist
-    PlayerbotMgr* mgr = m_session->GetPlayer()->GetPlayerbotMgr();
-    if (!mgr)
-    {
-        mgr = new PlayerbotMgr(m_session->GetPlayer());
-        m_session->GetPlayer()->SetPlayerbotMgr(mgr);
-    }
-
-    QueryResult* resultchar = CharacterDatabase.PQuery("SELECT COUNT(*) FROM characters WHERE online = '1' AND account = '%u'", m_session->GetAccountId());
-    if (resultchar)
-    {
-        Field* fields = resultchar->Fetch();
-        int acctcharcount = fields[0].GetUInt32();
-        int maxnum = botConfig.GetIntDefault("PlayerbotAI.MaxNumBots", 9);
-        if (!(m_session->GetSecurity() > SEC_PLAYER))
-            if (acctcharcount > maxnum && (cmdStr == "add" || cmdStr == "login"))
-            {
-                PSendSysMessage("|cffff0000You cannot summon anymore bots.(Current Max: |cffffffff%u)", maxnum);
-                SetSentErrorMessage(true);
-                delete resultchar;
-                return false;
-            }
-        delete resultchar;
-    }
-
-    QueryResult* resultlvl = CharacterDatabase.PQuery("SELECT level,name FROM characters WHERE guid = '%u'", guid.GetCounter());
-    if (resultlvl)
-    {
-        Field* fields = resultlvl->Fetch();
-        int charlvl = fields[0].GetUInt32();
-        int maxlvl = botConfig.GetIntDefault("PlayerbotAI.RestrictBotLevel", 80);
-        if (!(m_session->GetSecurity() > SEC_PLAYER))
-            if (charlvl > maxlvl)
-            {
-                PSendSysMessage("|cffff0000You cannot summon |cffffffff[%s]|cffff0000, it's level is too high.(Current Max:lvl |cffffffff%u)", fields[1].GetString(), maxlvl);
-                SetSentErrorMessage(true);
-                delete resultlvl;
-                return false;
-            }
-        delete resultlvl;
-    }
-    // end of gmconfig patch
-    if (cmdStr == "add" || cmdStr == "login")
-    {
-        if (mgr->GetPlayerBot(guid))
-        {
-            PSendSysMessage("Bot already exists in world.");
-            SetSentErrorMessage(true);
-            return false;
-        }
-        CharacterDatabase.DirectPExecute("UPDATE characters SET online = 1 WHERE guid = '%u'", guid.GetCounter());
-        mgr->LoginPlayerBot(guid);
-        PSendSysMessage("Bot added successfully.");
-    }
-    else if (cmdStr == "remove" || cmdStr == "logout")
-    {
-        if (!mgr->GetPlayerBot(guid))
-        {
-            PSendSysMessage("|cffff0000Bot can not be removed because bot does not exist in world.");
-            SetSentErrorMessage(true);
-            return false;
-        }
-        CharacterDatabase.DirectPExecute("UPDATE characters SET online = 0 WHERE guid = '%u'", guid.GetCounter());
-        mgr->LogoutPlayerBot(guid);
-        PSendSysMessage("Bot removed successfully.");
-    }
-
-    return true;
-}
diff --git a/src/game/PlayerBot/Base/PlayerbotMgr.h b/src/game/PlayerBot/Base/PlayerbotMgr.h
deleted file mode 100644
index a70786af0..000000000
--- a/src/game/PlayerBot/Base/PlayerbotMgr.h
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- * This file is part of the CMaNGOS Project. See AUTHORS file for Copyright information
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _PLAYERBOTMGR_H
-#define _PLAYERBOTMGR_H
-
-#include "Common.h"
-
-class WorldPacket;
-class Player;
-class Unit;
-class Object;
-class Item;
-class PlayerbotClassAI;
-
-typedef std::unordered_map<ObjectGuid, Player*> PlayerBotMap;
-
-class PlayerbotMgr
-{
-        // static functions, available without a PlayerbotMgr instance
-    public:
-        static void SetInitialWorldSettings();
-
-    public:
-        PlayerbotMgr(Player* const master);
-        virtual ~PlayerbotMgr();
-
-        // This is called from Unit.cpp and is called every second (I think)
-        void UpdateAI(const uint32 p_time);
-
-        // This is called whenever the master sends a packet to the server.
-        // These packets can be viewed, but not edited.
-        // It allows bot creators to craft AI in response to a master's actions.
-        // For a list of opcodes that can be caught see Opcodes.cpp (CMSG_* opcodes only)
-        // Notice: that this is static which means it is called once for all bots of the master.
-        void HandleMasterIncomingPacket(const WorldPacket& packet);
-        void HandleMasterOutgoingPacket(const WorldPacket& packet);
-
-        void LoginPlayerBot(ObjectGuid guid);
-        void LogoutPlayerBot(ObjectGuid guid);
-        Player* GetPlayerBot(ObjectGuid guid) const;
-        Player* GetMaster() const { return m_master; };
-
-        PlayerBotMap::const_iterator GetPlayerBotsBegin() const { return m_playerBots.begin(); }
-        PlayerBotMap::const_iterator GetPlayerBotsEnd()   const { return m_playerBots.end();   }
-
-        void LogoutAllBots();
-        void RemoveAllBotsFromGroup();
-        void OnBotLogin(Player* const bot);
-        void Stay();
-
-    public:
-        // config variables
-        uint32 m_confRestrictBotLevel;
-        uint32 m_confDisableBotsInRealm;
-        uint32 m_confMaxNumBots;
-        bool m_confDisableBots;
-        bool m_confDebugWhisper;
-        float m_confFollowDistance[2];
-        uint32 gConfigSellLevelDiff;
-        bool m_confCollectCombat;
-        bool m_confCollectQuest;
-        bool m_confCollectProfession;
-        bool m_confCollectLoot;
-        bool m_confCollectSkin;
-        bool m_confCollectObjects;
-        uint32 m_confCollectDistance;
-        uint32 m_confCollectDistanceMax;
-
-    private:
-        Player* const m_master;
-        PlayerBotMap m_playerBots;
-};
-
-#endif
diff --git a/src/game/PlayerBot/config.h b/src/game/PlayerBot/config.h
deleted file mode 100644
index 4b16c4ddf..000000000
--- a/src/game/PlayerBot/config.h
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * This file is part of the CMaNGOS Project. See AUTHORS file for Copyright information
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef PB_CONFIG_H
-#define PB_CONFIG_H
-
-#include "Platform/CompilerDefs.h"
-
-// Format is YYYYMMDDRR where RR is the change in the conf file
-// for that day.
-#define PLAYERBOT_CONF_VERSION    2018101401
-
-#if PLATFORM == PLATFORM_WINDOWS
-#define _PLAYERBOT_CONFIG  "playerbot.conf"
-#else
-#define _PLAYERBOT_CONFIG  SYSCONFDIR "playerbot.conf"
-#endif
-
-#endif
diff --git a/src/game/PlayerBot/config.h.in b/src/game/PlayerBot/config.h.in
deleted file mode 100644
index 4ff6094ff..000000000
--- a/src/game/PlayerBot/config.h.in
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * This file is part of the CMaNGOS Project. See AUTHORS file for Copyright information
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef PB_CONFIG_H
-#define PB_CONFIG_H
-
-#include "Platform/CompilerDefs.h"
-
-// Format is YYYYMMDDRR where RR is the change in the conf file
-// for that day.
-#define PLAYERBOT_CONF_VERSION    2018101401
-
-#if PLATFORM == PLATFORM_WINDOWS
-  #define _PLAYERBOT_CONFIG  "playerbot.conf"
-#else
-  #define _PLAYERBOT_CONFIG  SYSCONFDIR"playerbot.conf"
-#endif
-
-#endif
diff --git a/src/game/PlayerBot/playerbot.conf.dist.in b/src/game/PlayerBot/playerbot.conf.dist.in
deleted file mode 100644
index 6e1ad586f..000000000
--- a/src/game/PlayerBot/playerbot.conf.dist.in
+++ /dev/null
@@ -1,96 +0,0 @@
-#####################################
-# Playerbot Configuration file      #
-#####################################
-
-[PlayerbotConf]
-ConfVersion=2018101401
-
-###################################################################################################################
-# PLAYERBOTAI CONFIGURATION
-#
-#    PlayerbotAI.DisableBots
-#        Disable the bot system
-#        Default: 0 - off
-#                 1 - on
-#
-#    PlayerbotAI.DebugWhisper
-#        Enable debug output by whispering master
-#        Default: 0 - off
-#                 1 - on
-#
-#    PlayerbotAI.FollowDistanceMin
-#    PlayerbotAI.FollowDistanceMax
-#        Min. and Max. follow distance for bots
-#        Default: 0.5 / 1.0
-#
-#    PlayerbotAI.MaxNumBots
-#        Limits the number of bots per account (Max 9)
-#        Default: 9
-#
-#    PlayerbotAI.RestrictBotLevel
-#        Restrict the allowed bot level (Current Max 80)
-#        Default: 80
-#
-#    PlayerbotAI.BotguyQuests
-#        List of Quest ids, any of which, once completed will enable botguy menu on NPCs
-#        List must be enclosed in double quotes ("") and multiple Quest Ids separated by a delimiter(,)
-#        Example: "805,383,2160,54,8350,9313,1656,2159"
-#        Default: "" no quest restriction, memu always displayed by NPCs
-#
-#    PlayerbotAI.BotguyCost
-#        Cost (Copper coins) levied on summoning a bot
-#        If player has the cost, botguy menu will be displayed by NPCs
-#        Negative value will disable botguy menu
-#                -1 - Botguy menu off
-#        Default: 0 - no cost, menu always displayed by NPCs
-#                 1...2147483648 cost (in copper) for summoning one bot
-#
-#    PlayerbotAI.Collect.Combat
-#    PlayerbotAI.Collect.Quest
-#    PlayerbotAI.Collect.Profession
-#    PlayerbotAI.Collect.Loot
-#    PlayerbotAI.Collect.Skin
-#    PlayerbotAI.Collect.Objects
-#        Enable collection options for after combat, quest items, profession, all loot, skin, or nearby objects
-#                 0 - off
-#        Default: 1 - on
-#
-#    PlayerbotAI.Collect.DistanceMax
-#        Maximum distance that can be configured for bots to collect objects. Allowing a higher
-#        distance could increase processor usage for object searching.
-#                 1-100
-#        Default: 50
-#
-#    PlayerbotAI.Collect.Distance
-#        Default distance that bots will search within for collection.
-#        Default: 25 (cannot be more than DistanceMax)
-#
-#    PlayerbotAI.SellGarbage
-#        Allow bots to automatically sell all [GRAY|POOR] quality items as the player activates vendor
-#        Default: 0 - off
-#                 1 - on
-#    PlayerbotAI.SellAll.LevelDiff
-#         If 'sell all' command is given prior to selling, bots will sell all low level white items.. this number is the number
-#         of levels LOWER than the bots level the Item must be before bot will sell it.
-#         Default: 10 (10 levels lower than the bot) Don't set to 0 or they'll sell everything! *SellGarbage must be set to 1 to use this*
-#
-###################################################################################################################
-
-PlayerbotAI.DisableBots = 0
-PlayerbotAI.DebugWhisper = 0
-PlayerbotAI.FollowDistanceMin = 0.5
-PlayerbotAI.FollowDistanceMax = 1.0
-PlayerbotAI.MaxNumBots = 9
-PlayerbotAI.RestrictBotLevel = 80
-PlayerbotAI.BotguyQuests = ""
-PlayerbotAI.BotguyCost = 0
-PlayerbotAI.Collect.Combat = 1
-PlayerbotAI.Collect.Quest = 1
-PlayerbotAI.Collect.Profession = 1
-PlayerbotAI.Collect.Loot = 1
-PlayerbotAI.Collect.Skin = 1
-PlayerbotAI.Collect.Objects = 1
-PlayerbotAI.Collect.DistanceMax = 50
-PlayerbotAI.Collect.Distance = 25
-PlayerbotAI.SellGarbage = 0
-PlayerbotAI.SellAll.LevelDiff = 10
diff --git a/src/game/PlayerBot/revision_sql.h b/src/game/PlayerBot/revision_sql.h
deleted file mode 100644
index 1b33d9d45..000000000
--- a/src/game/PlayerBot/revision_sql.h
+++ /dev/null
@@ -1 +0,0 @@
-#define REVISION_DB_PLAYERBOTAI "characters_playerbot_saved_data_001"
diff --git a/src/game/Quests/QuestHandler.cpp b/src/game/Quests/QuestHandler.cpp
index 0cdda8e43..b88fa3aae 100644
--- a/src/game/Quests/QuestHandler.cpp
+++ b/src/game/Quests/QuestHandler.cpp
@@ -30,10 +30,6 @@
 #include "AI/ScriptDevAI/ScriptDevAIMgr.h"
 #include "Groups/Group.h"
 
-#ifdef BUILD_PLAYERBOT
-#include "PlayerBot/Base/PlayerbotAI.h"
-#endif
-
 void WorldSession::HandleQuestgiverStatusQueryOpcode(WorldPacket& recv_data)
 {
     ObjectGuid guid;
@@ -471,20 +467,8 @@ void WorldSession::HandlePushQuestToParty(WorldPacket& recvPacket)
                     continue;
                 }
 
-#ifndef BUILD_PLAYERBOT
-                pPlayer->PlayerTalkClass->SendQuestGiverQuestDetails(pQuest, _player->GetObjectGuid(), true);
-#endif
                 pPlayer->SetDividerGuid(_player->GetObjectGuid());
 
-#ifdef BUILD_PLAYERBOT
-                if (pPlayer->GetPlayerbotAI())
-                    pPlayer->GetPlayerbotAI()->AcceptQuest(pQuest, _player);
-                else
-                {
-                    pPlayer->PlayerTalkClass->SendQuestGiverQuestDetails(pQuest, _player->GetObjectGuid(), true);
-                    pPlayer->SetDividerGuid(_player->GetObjectGuid());
-                }
-#endif
             }
         }
     }
diff --git a/src/game/Reputation/ReputationMgr.cpp b/src/game/Reputation/ReputationMgr.cpp
index 39e5d5922..ecc5d4123 100644
--- a/src/game/Reputation/ReputationMgr.cpp
+++ b/src/game/Reputation/ReputationMgr.cpp
@@ -21,6 +21,9 @@
 #include "Entities/Player.h"
 #include "WorldPacket.h"
 #include "Globals/ObjectMgr.h"
+#ifdef ENABLE_IMMERSIVE
+#include "immersive.h"
+#endif
 
 const int32 ReputationMgr::PointsInRank[MAX_REPUTATION_RANK] = {36000, 3000, 3000, 3000, 6000, 12000, 21000, 1000};
 
@@ -270,6 +273,10 @@ void ReputationMgr::SetReputation(FactionEntry const* factionEntry, int32 standi
     if (!factionEntry)
         return;
 
+#ifdef ENABLE_IMMERSIVE
+    sImmersive.OnReputationChange(m_player, factionEntry, standing, incremental);
+#endif
+
     bool anyRankIncreased = false;
     // if spillover definition exists in DB, override DBC
     if (const RepSpilloverTemplate* repTemplate = sObjectMgr.GetRepSpilloverTemplate(factionEntry->ID))
diff --git a/src/game/Server/DBCStores.cpp b/src/game/Server/DBCStores.cpp
index 40d3b5cc9..a63a5816a 100644
--- a/src/game/Server/DBCStores.cpp
+++ b/src/game/Server/DBCStores.cpp
@@ -77,6 +77,13 @@ DBCStorage <DurabilityCostsEntry> sDurabilityCostsStore(DurabilityCostsfmt);
 
 DBCStorage <EmotesEntry> sEmotesStore(EmotesEntryfmt);
 DBCStorage <EmotesTextEntry> sEmotesTextStore(EmotesTextEntryfmt);
+#ifdef ENABLE_PLAYERBOTS
+typedef std::tuple<uint32, uint32, uint32> EmotesTextSoundKey;
+static std::map<EmotesTextSoundKey, EmotesTextSoundEntry const*> sEmotesTextSoundMap;
+DBCStorage <EmotesTextSoundEntry> sEmotesTextSoundStore(EmotesTextSoundEntryfmt);
+DBCStorage <CharSectionsEntry> sCharSectionsStore(CharSectionsEntryfmt);
+CharSectionsMap sCharSectionMap;
+#endif
 
 //DBCStorage <FactionEntry> sFactionStore(FactionEntryfmt);
 DBCStorage <FactionTemplateEntry> sFactionTemplateStore(FactionTemplateEntryfmt);
@@ -276,6 +283,17 @@ void LoadDBCStores(const std::string& dataPath)
     LoadDBC(availableDbcLocales, bar, bad_dbc_files, sDurabilityQualityStore,   dbcPath, "DurabilityQuality.dbc");
     LoadDBC(availableDbcLocales, bar, bad_dbc_files, sEmotesStore,              dbcPath, "Emotes.dbc");
     LoadDBC(availableDbcLocales, bar, bad_dbc_files, sEmotesTextStore,          dbcPath, "EmotesText.dbc");
+#ifdef ENABLE_PLAYERBOTS
+    LoadDBC(availableDbcLocales, bar, bad_dbc_files, sEmotesTextSoundStore,     dbcPath, "EmotesTextSound.dbc");
+    for (uint32 i = 0; i < sEmotesTextSoundStore.GetNumRows(); ++i)
+        if (EmotesTextSoundEntry const* entry = sEmotesTextSoundStore.LookupEntry(i))
+            sEmotesTextSoundMap[EmotesTextSoundKey(entry->EmotesTextId, entry->RaceId, entry->SexId)] = entry;
+    LoadDBC(availableDbcLocales, bar, bad_dbc_files, sCharSectionsStore,        dbcPath, "CharSections.dbc");
+    for (uint32 i = 0; i < sCharSectionsStore.GetNumRows(); ++i)
+        if (CharSectionsEntry const* entry = sCharSectionsStore.LookupEntry(i))
+            if (entry->Race && ((1 << (entry->Race - 1)) & RACEMASK_ALL_PLAYABLE) != 0) //ignore Nonplayable races
+                sCharSectionMap.insert({ entry->GenType | (entry->Gender << 8) | (entry->Race << 16), entry });
+#endif
     // LoadDBC(availableDbcLocales, bar, bad_dbc_files, sFactionStore,             dbcPath, "Faction.dbc");
 
     LoadDBC(availableDbcLocales, bar, bad_dbc_files, sFactionTemplateStore,     dbcPath, "FactionTemplate.dbc");
@@ -808,6 +826,26 @@ uint32 GetCreatureModelRace(uint32 model_id)
     return extraEntry ? extraEntry->Race : 0;
 }
 
+
+#ifdef ENABLE_PLAYERBOTS
+EmotesTextSoundEntry const* FindTextSoundEmoteFor(uint32 emote, uint32 race, uint32 gender)
+{
+    auto itr = sEmotesTextSoundMap.find(EmotesTextSoundKey(emote, race, gender));
+    return itr != sEmotesTextSoundMap.end() ? itr->second : nullptr;
+}
+CharSectionsEntry const* GetCharSectionEntry(uint8 race, CharSectionType genType, uint8 gender, uint8 type, uint8 color)
+{
+    std::pair<CharSectionsMap::const_iterator, CharSectionsMap::const_iterator> eqr = sCharSectionMap.equal_range(uint32(genType) | uint32(gender << 8) | uint32(race << 16));
+    for (CharSectionsMap::const_iterator itr = eqr.first; itr != eqr.second; ++itr)
+    {
+        if (itr->second->Type == type && itr->second->Color == color)
+            return itr->second;
+    }
+
+    return NULL;
+}
+#endif
+
 // script support functions
 DBCStorage <SoundEntriesEntry>  const* GetSoundEntriesStore()   { return &sSoundEntriesStore;   }
 DBCStorage <SpellRangeEntry>    const* GetSpellRangeStore()     { return &sSpellRangeStore;     }
diff --git a/src/game/Server/DBCStores.h b/src/game/Server/DBCStores.h
index 1961717e0..eb14b217f 100644
--- a/src/game/Server/DBCStores.h
+++ b/src/game/Server/DBCStores.h
@@ -65,13 +65,23 @@ uint32 const* /*[3]*/ GetTalentTabPages(uint32 cls);
 bool IsPointInAreaTriggerZone(AreaTriggerEntry const* atEntry, uint32 mapid, float x, float y, float z, float delta = 0.0f);
 
 uint32 GetCreatureModelRace(uint32 model_id);
+#ifdef ENABLE_PLAYERBOTS
+ EmotesTextSoundEntry const* FindTextSoundEmoteFor(uint32 emote, uint32 race, uint32 gender);
+ CharSectionsEntry const* GetCharSectionEntry(uint8 race, CharSectionType genType, uint8 gender, uint8 type, uint8 color);
+ typedef std::multimap<uint32, CharSectionsEntry const*> CharSectionsMap;
+ extern CharSectionsMap sCharSectionMap;
+#endif
 
 extern DBCStorage <AreaTableEntry>               sAreaStore;// recommend access using functions
 extern DBCStorage <AreaTriggerEntry>             sAreaTriggerStore;
 extern DBCStorage <AuctionHouseEntry>            sAuctionHouseStore;
 extern DBCStorage <BankBagSlotPricesEntry>       sBankBagSlotPricesStore;
 extern DBCStorage <BattlemasterListEntry>        sBattlemasterListStore;
+#ifdef ENABLE_PLAYERBOTS
+extern DBCStorage <ChatChannelsEntry>            sChatChannelsStore; //has function for access aswell
+#else
 // extern DBCStorage <ChatChannelsEntry>           sChatChannelsStore; -- accessed using function, no usable index
+#endif
 extern DBCStorage <CharStartOutfitEntry>         sCharStartOutfitStore;
 extern DBCStorage <CharTitlesEntry>              sCharTitlesStore;
 extern DBCStorage <ChrClassesEntry>              sChrClassesStore;
diff --git a/src/game/Server/DBCStructure.h b/src/game/Server/DBCStructure.h
index 735207a95..daf76d7f7 100644
--- a/src/game/Server/DBCStructure.h
+++ b/src/game/Server/DBCStructure.h
@@ -322,6 +322,46 @@ struct EmotesTextEntry
     //          m_emoteText
 };
 
+#ifdef ENABLE_PLAYERBOTS
+/**
+* \struct EmotesTextSoundEntry
+* \brief Entry repsenting the text sound for given emote.
+*/
+struct EmotesTextSoundEntry
+{
+    uint32 Id;                                              // 0
+    uint32 EmotesTextId;                                    // 1
+    uint32 RaceId;                                          // 2
+    uint32 SexId;                                           // 3, 0 male / 1 female
+    uint32 SoundId;                                         // 4
+};
+enum CharSectionFlags
+{
+    SECTION_FLAG_PLAYER       = 0x01
+};
+
+enum CharSectionType
+{
+    SECTION_TYPE_SKIN         = 0,
+    SECTION_TYPE_FACE         = 1,
+    SECTION_TYPE_FACIAL_HAIR  = 2,
+    SECTION_TYPE_HAIR         = 3,
+    SECTION_TYPE_UNDERWEAR    = 4
+};
+
+struct CharSectionsEntry
+{
+    //uint32 Id;
+    uint32 Race;
+    uint32 Gender;
+    uint32 GenType;
+    //char* TexturePath[3];
+    uint32 Type;
+    uint32 Color;
+    uint32 Flags;
+};
+#endif
+
 struct FactionEntry
 {
     uint32      ID;                                         // 0        m_ID
diff --git a/src/game/Server/DBCfmt.h b/src/game/Server/DBCfmt.h
index 3002d6355..6892554f5 100644
--- a/src/game/Server/DBCfmt.h
+++ b/src/game/Server/DBCfmt.h
@@ -43,6 +43,10 @@ const char DurabilityCostsfmt[] = "niiiiiiiiiiiiiiiiiiiiiiiiiiiii";
 const char DurabilityQualityfmt[] = "nf";
 const char EmotesEntryfmt[] = "nxxiiix";
 const char EmotesTextEntryfmt[] = "nxixxxxxxxxxxxxxxxx";
+#ifdef ENABLE_PLAYERBOTS
+char const EmotesTextSoundEntryfmt[] = "niiii";
+char const CharSectionsEntryfmt[] = "diiiiixxxi";
+#endif
 // const char FactionEntryfmt[] = "niiiiiiiiiiiiiiiiiissssssssssssssssxxxxxxxxxxxxxxxxxx";
 const char FactionTemplateEntryfmt[] = "niiiiiiiiiiiii";
 const char GameObjectDisplayInfofmt[] = "nsxxxxxxxxxxffffff";
diff --git a/src/game/Server/WorldSession.cpp b/src/game/Server/WorldSession.cpp
index a269455b8..5013a7dc2 100644
--- a/src/game/Server/WorldSession.cpp
+++ b/src/game/Server/WorldSession.cpp
@@ -36,16 +36,15 @@
 #include "BattleGround/BattleGroundMgr.h"
 #include "Social/SocialMgr.h"
 #include "Loot/LootMgr.h"
+#ifdef ENABLE_PLAYERBOTS
+#include "playerbot.h"
+#endif
 
 #include <mutex>
 #include <deque>
 #include <algorithm>
 #include <cstdarg>
 
-#ifdef BUILD_PLAYERBOT
-#include "PlayerBot/Base/PlayerbotMgr.h"
-#include "PlayerBot/Base/PlayerbotAI.h"
-#endif
 
 // select opcodes appropriate for processing in Map::Update context for current session state
 static bool MapSessionFilterHelper(WorldSession* session, OpcodeHandler const& opHandle)
@@ -170,10 +169,8 @@ char const* WorldSession::GetPlayerName() const
 /// Send a packet to the client
 void WorldSession::SendPacket(WorldPacket const& packet, bool forcedSend /*= false*/) const
 {
-#ifdef BUILD_PLAYERBOT
-    // Send packet to bot AI
-    if (GetPlayer())
-    {
+#ifdef ENABLE_PLAYERBOTS
+    if (GetPlayer()) {
         if (GetPlayer()->GetPlayerbotAI())
             GetPlayer()->GetPlayerbotAI()->HandleBotOutgoingPacket(packet);
         else if (GetPlayer()->GetPlayerbotMgr())
@@ -284,8 +281,7 @@ bool WorldSession::Update(PacketFilter& updater)
                         ExecuteOpcode(opHandle, *packet);
 
                     // lag can cause STATUS_LOGGEDIN opcodes to arrive after the player started a transfer
-
-#ifdef BUILD_PLAYERBOT
+#ifdef ENABLE_PLAYERBOTS
                     if (_player && _player->GetPlayerbotMgr())
                         _player->GetPlayerbotMgr()->HandleMasterIncomingPacket(*packet);
 #endif
@@ -359,34 +355,9 @@ bool WorldSession::Update(PacketFilter& updater)
         }
     }
 
-#ifdef BUILD_PLAYERBOT
-    // Process player bot packets
-    // The PlayerbotAI class adds to the packet queue to simulate a real player
-    // since Playerbots are known to the World obj only by its master's WorldSession object
-    // we need to process all master's bot's packets.
+#ifdef ENABLE_PLAYERBOTS
     if (GetPlayer() && GetPlayer()->GetPlayerbotMgr())
-    {
-        for (PlayerBotMap::const_iterator itr = GetPlayer()->GetPlayerbotMgr()->GetPlayerBotsBegin();
-                itr != GetPlayer()->GetPlayerbotMgr()->GetPlayerBotsEnd(); ++itr)
-        {
-            Player* const botPlayer = itr->second;
-            WorldSession* const pBotWorldSession = botPlayer->GetSession();
-            if (botPlayer->IsBeingTeleported())
-                botPlayer->GetPlayerbotAI()->HandleTeleportAck();
-            else if (botPlayer->IsInWorld())
-            {
-                while (!pBotWorldSession->m_recvQueue.empty())
-                {
-                    auto const botpacket = std::move(pBotWorldSession->m_recvQueue.front());
-                    pBotWorldSession->m_recvQueue.pop_front();
-
-                    OpcodeHandler const& opHandle = opcodeTable[botpacket->GetOpcode()];
-                    pBotWorldSession->ExecuteOpcode(opHandle, *botpacket);
-                };
-                pBotWorldSession->m_recvQueue.clear();
-            }
-        }
-    }
+        GetPlayer()->GetPlayerbotMgr()->UpdateSessions(0);
 #endif
 
     // check if we are safe to proceed with logout
@@ -468,6 +439,19 @@ bool WorldSession::Update(PacketFilter& updater)
     return true;
 }
 
+#ifdef ENABLE_PLAYERBOTS
+void WorldSession::HandleBotPackets()
+{
+    while (!m_recvQueue.empty())
+    {
+        auto const packet = std::move(m_recvQueue.front());
+        m_recvQueue.pop_front();
+        OpcodeHandler const& opHandle = opcodeTable[packet->GetOpcode()];
+        (this->*opHandle.handler)(*packet);
+    }
+}
+#endif
+
 /// %Log the player out
 void WorldSession::LogoutPlayer(bool Save)
 {
@@ -480,17 +464,21 @@ void WorldSession::LogoutPlayer(bool Save)
 
     if (_player)
     {
-#ifdef BUILD_PLAYERBOT
-        // Log out all player bots owned by this toon
-        if (_player->GetPlayerbotMgr())
-            _player->GetPlayerbotMgr()->LogoutAllBots();
-#endif
-
+#ifdef ENABLE_PLAYERBOTS
+        sLog.outChar("Account: %d (IP: %s) Logout Character:[%s] (guid: %u)", GetAccountId(), m_Socket ? GetRemoteAddress().c_str() : "bot", _player->GetName(), _player->GetGUIDLow());
+#else
         sLog.outChar("Account: %d (IP: %s) Logout Character:[%s] (guid: %u)", GetAccountId(), GetRemoteAddress().c_str(), _player->GetName(), _player->GetGUIDLow());
+#endif
 
         if (Loot* loot = sLootMgr.GetLoot(_player))
             loot->Release(_player);
 
+#ifdef ENABLE_PLAYERBOTS
+        if (_player->GetPlayerbotMgr())
+            _player->GetPlayerbotMgr()->LogoutAllBots();
+        sRandomPlayerbotMgr.OnPlayerLogout(_player);
+#endif
+
         if (_player->GetDeathTimer())
         {
             _player->getHostileRefManager().deleteReferences();
@@ -540,17 +528,8 @@ void WorldSession::LogoutPlayer(bool Save)
         // No SQL injection as AccountID is uint32
         static SqlStatementID id;
 
-#ifdef BUILD_PLAYERBOT
-        if (!_player->GetPlayerbotAI())
-        {
-            // Unmodded core code below
-            SqlStatement stmt = LoginDatabase.CreateStatement(id, "UPDATE account SET active_realm_id = ? WHERE id = ?");
-            stmt.PExecute(uint32(0), GetAccountId());
-        }
-#else
         SqlStatement stmt = LoginDatabase.CreateStatement(id, "UPDATE account SET active_realm_id = ? WHERE id = ?");
         stmt.PExecute(uint32(0), GetAccountId());
-#endif
 
         ///- If the player is in a guild, update the guild roster and broadcast a logout message to other guild members
         if (Guild* guild = sGuildMgr.GetGuildById(_player->GetGuildId()))
@@ -575,6 +554,7 @@ void WorldSession::LogoutPlayer(bool Save)
         ///- Leave all channels before player delete...
         _player->CleanupChannels();
 
+#ifndef ENABLE_PLAYERBOTS
         ///- If the player is in a group (or invited), remove him. If the group if then only 1 person, disband the group.
         _player->UninviteFromGroup();
 
@@ -582,6 +562,7 @@ void WorldSession::LogoutPlayer(bool Save)
         // a) in group; b) not in raid group; c) logging out normally (not being kicked or disconnected)
         if (_player->GetGroup() && !_player->GetGroup()->isRaidGroup() && m_Socket && !m_Socket->IsClosed())
             _player->RemoveFromGroup();
+#endif
 
         ///- Send update to group
         if (Group* group = _player->GetGroup())
@@ -591,11 +572,6 @@ void WorldSession::LogoutPlayer(bool Save)
         sSocialMgr.SendFriendStatus(_player, FRIEND_OFFLINE, _player->GetObjectGuid(), true);
         sSocialMgr.RemovePlayerSocial(_player->GetGUIDLow());
 
-#ifdef BUILD_PLAYERBOT
-        // Remember player GUID for update SQL below
-        uint32 guid = _player->GetGUIDLow();
-#endif
-
         ///- Remove the player from the world
         // the player may not be in the world when logging out
         // e.g if he got disconnected during a transfer to another map
@@ -619,17 +595,10 @@ void WorldSession::LogoutPlayer(bool Save)
 
         static SqlStatementID updChars;
 
-#ifdef BUILD_PLAYERBOT
-        // Set for only character instead of accountid
-        // Different characters can be alive as bots
-        SqlStatement stmt = CharacterDatabase.CreateStatement(updChars, "UPDATE characters SET online = 0 WHERE guid = ?");
-        stmt.PExecute(guid);
-#else
         ///- Since each account can only have one online character at any given time, ensure all characters for active account are marked as offline
         // No SQL injection as AccountId is uint32
         stmt = CharacterDatabase.CreateStatement(updChars, "UPDATE characters SET online = 0 WHERE account = ?");
         stmt.PExecute(GetAccountId());
-#endif
 
         DEBUG_LOG("SESSION: Sent SMSG_LOGOUT_COMPLETE Message");
     }
diff --git a/src/game/Server/WorldSession.h b/src/game/Server/WorldSession.h
index ed3e12e55..7f3d18628 100644
--- a/src/game/Server/WorldSession.h
+++ b/src/game/Server/WorldSession.h
@@ -195,12 +195,8 @@ class WorldSession
         Player* GetPlayer() const { return _player; }
         char const* GetPlayerName() const;
         void SetSecurity(AccountTypes security) { _security = security; }
-#ifdef BUILD_PLAYERBOT
-        // Players connected without socket are bot
         const std::string GetRemoteAddress() const { return m_Socket ? m_Socket->GetRemoteAddress() : "disconnected/bot"; }
-#else
-        const std::string GetRemoteAddress() const { return m_Socket ? m_Socket->GetRemoteAddress() : "disconnected"; }
-#endif
+
         void SetPlayer(Player* plr) { _player = plr; }
         uint8 Expansion() const { return m_expansion; }
 
@@ -751,6 +747,9 @@ class WorldSession
         void HandleSetActiveVoiceChannel(WorldPacket& recv_data);
         void HandleSetTaxiBenchmarkOpcode(WorldPacket& recv_data);
 
+#ifdef ENABLE_PLAYERBOTS
+        void HandleBotPackets();
+#endif
         // Guild Bank
         void HandleGuildPermissions(WorldPacket& recv_data);
         void HandleGuildBankMoneyWithdrawn(WorldPacket& recv_data);
diff --git a/src/game/Spells/SpellAuras.cpp b/src/game/Spells/SpellAuras.cpp
index 6b92c9908..ae819afbf 100755
--- a/src/game/Spells/SpellAuras.cpp
+++ b/src/game/Spells/SpellAuras.cpp
@@ -213,7 +213,7 @@ pAuraHandler AuraHandler[TOTAL_AURAS] =
     &Aura::HandleNoImmediateEffect,                         //152 SPELL_AURA_MOD_DETECTED_RANGE         implemented in Creature::GetAttackDistance
     &Aura::HandleNoImmediateEffect,                         //153 SPELL_AURA_SPLIT_DAMAGE_FLAT          implemented in Unit::CalculateAbsorbAndResist
     &Aura::HandleNoImmediateEffect,                         //154 SPELL_AURA_MOD_STEALTH_LEVEL          implemented in Unit::isVisibleForOrDetect
-    &Aura::HandleModWaterBreathing,                         //155 SPELL_AURA_MOD_WATER_BREATHING
+    &Aura::HandleNoImmediateEffect,                         //155 SPELL_AURA_MOD_WATER_BREATHING        implemented in Player::getMaxTimer
     &Aura::HandleNoImmediateEffect,                         //156 SPELL_AURA_MOD_REPUTATION_GAIN        implemented in Player::CalculateReputationGain
     &Aura::HandleUnused,                                    //157 SPELL_AURA_PET_DAMAGE_MULTI (single test like spell 20782, also single for 214 aura)
     &Aura::HandleShieldBlockValue,                          //158 SPELL_AURA_MOD_SHIELD_BLOCKVALUE
@@ -3146,20 +3146,11 @@ void Aura::HandleAuraHover(bool apply, bool Real)
     GetTarget()->SetHover(apply);
 }
 
-void Aura::HandleWaterBreathing(bool apply, bool /*Real*/)
+void Aura::HandleWaterBreathing(bool /*apply*/, bool /*Real*/)
 {
-    Unit* target = GetTarget();
-
-    if (target->GetTypeId() == TYPEID_PLAYER)
-        static_cast<Player*>(target)->SetWaterBreathingIntervalMultiplier(apply ? 0 : target->GetTotalAuraMultiplier(SPELL_AURA_MOD_WATER_BREATHING));
-}
-
-void Aura::HandleModWaterBreathing(bool /*apply*/, bool /*Real*/)
-{
-    Unit* target = GetTarget();
-
-    if (target->GetTypeId() == TYPEID_PLAYER)
-        static_cast<Player*>(target)->SetWaterBreathingIntervalMultiplier(target->GetTotalAuraMultiplier(SPELL_AURA_MOD_WATER_BREATHING));
+    // update timers in client
+    if (GetTarget()->GetTypeId() == TYPEID_PLAYER)
+        ((Player*)GetTarget())->UpdateMirrorTimers();
 }
 
 void Aura::HandleAuraModShapeshift(bool apply, bool Real)
@@ -6396,6 +6387,9 @@ void Aura::HandleSpiritOfRedemption(bool apply, bool Real)
     {
         if (target->GetTypeId() == TYPEID_PLAYER)
         {
+            // disable breath/etc timers
+            ((Player*)target)->StopMirrorTimers();
+
             // set stand state (expected in this form)
             if (!target->IsStandState())
                 target->SetStandState(UNIT_STAND_STATE_STAND);
@@ -6547,7 +6541,7 @@ void Aura::PeriodicTick()
             }
 
             uint32 absorb = 0;
-            int32 resist = 0;
+            uint32 resist = 0;
             CleanDamage cleanDamage =  CleanDamage(0, BASE_ATTACK, MELEE_HIT_NORMAL);
 
             // SpellDamageBonus for magic spells
@@ -6584,13 +6578,9 @@ void Aura::PeriodicTick()
             // Set trigger flag
             uint32 procAttacker = PROC_FLAG_ON_DO_PERIODIC; //  | PROC_FLAG_SUCCESSFUL_HARMFUL_SPELL_HIT;
             uint32 procVictim   = PROC_FLAG_ON_TAKE_PERIODIC;// | PROC_FLAG_TAKEN_HARMFUL_SPELL_HIT;
+            pdamage = (pdamage <= absorb + resist) ? 0 : (pdamage - absorb - resist);
 
-            const uint32 bonus = (resist < 0 ? uint32(std::abs(resist)) : 0);
-            pdamage += bonus;
-            const uint32 malus = (resist > 0 ? (absorb + uint32(resist)) : absorb);
-            pdamage = (pdamage <= malus ? 0 : (pdamage - malus));
-
-            SpellPeriodicAuraLogInfo pInfo(this, pdamage, absorb, resist, 0.0f);
+            SpellPeriodicAuraLogInfo pInfo(this, pdamage, absorb, int32(resist), 0.0f);
             target->SendPeriodicAuraLog(&pInfo);
 
             if (pdamage)
@@ -6627,10 +6617,10 @@ void Aura::PeriodicTick()
             }
 
             uint32 absorb = 0;
-            int32 resist = 0;
+            uint32 resist = 0;
             CleanDamage cleanDamage =  CleanDamage(0, BASE_ATTACK, MELEE_HIT_NORMAL);
 
-            uint32 pdamage = (m_modifier.m_amount > 0 ? uint32(m_modifier.m_amount) : 0);
+            uint32 pdamage = m_modifier.m_amount > 0 ? m_modifier.m_amount : 0;
 
             pdamage = target->SpellDamageBonusTaken(pCaster, spellProto, pdamage, DOT, GetStackAmount());
 
@@ -6638,6 +6628,9 @@ void Aura::PeriodicTick()
 
             target->CalculateDamageAbsorbAndResist(pCaster, GetSpellSchoolMask(spellProto), DOT, pdamage, &absorb, &resist, IsReflectableSpell(spellProto), IsResistableSpell(spellProto));
 
+            if (target->GetHealth() < pdamage)
+                pdamage = uint32(target->GetHealth());
+
             DETAIL_FILTER_LOG(LOG_FILTER_PERIODIC_AFFECTS, "PeriodicTick: %s health leech of %s for %u dmg inflicted by %u abs is %u",
                               GetCasterGuid().GetString().c_str(), target->GetGuidStr().c_str(), pdamage, GetId(), absorb);
 
@@ -6651,13 +6644,7 @@ void Aura::PeriodicTick()
             uint32 procAttacker = PROC_FLAG_ON_DO_PERIODIC; // | PROC_FLAG_SUCCESSFUL_HARMFUL_SPELL_HIT;
             uint32 procVictim   = PROC_FLAG_ON_TAKE_PERIODIC;// | PROC_FLAG_TAKEN_HARMFUL_SPELL_HIT;
 
-            const uint32 bonus = (resist < 0 ? uint32(std::abs(resist)) : 0);
-            pdamage += bonus;
-            const uint32 malus = (resist > 0 ? (absorb + uint32(resist)) : absorb);
-            pdamage = (pdamage <= malus ? 0 : (pdamage - malus));
-
-            pdamage = std::min(pdamage, target->GetHealth());
-
+            pdamage = (pdamage <= absorb + resist) ? 0 : (pdamage - absorb - resist);
             if (pdamage)
                 procVictim |= PROC_FLAG_TAKEN_ANY_DAMAGE;
 
diff --git a/src/game/Spells/SpellAuras.h b/src/game/Spells/SpellAuras.h
index 24419fadf..525643548 100644
--- a/src/game/Spells/SpellAuras.h
+++ b/src/game/Spells/SpellAuras.h
@@ -328,7 +328,6 @@ class Aura
         void HandleModCastingSpeed(bool apply, bool Real);
         void HandleAuraMounted(bool apply, bool Real);
         void HandleWaterBreathing(bool Apply, bool Real);
-        void HandleModWaterBreathing(bool apply, bool Real);
         void HandleModBaseResistance(bool apply, bool Real);
         void HandleModRegen(bool apply, bool Real);
         void HandleModPowerRegen(bool apply, bool Real);
diff --git a/src/game/Spells/SpellEffects.cpp b/src/game/Spells/SpellEffects.cpp
index 4a32887dd..8b7fb7f52 100644
--- a/src/game/Spells/SpellEffects.cpp
+++ b/src/game/Spells/SpellEffects.cpp
@@ -294,7 +294,7 @@ void Spell::EffectInstaKill(SpellEffectIndex /*eff_idx*/)
 void Spell::EffectEnvironmentalDMG(SpellEffectIndex eff_idx)
 {
     uint32 absorb = 0;
-    int32 resist = 0;
+    uint32 resist = 0;
 
     // Note: this hack with damage replace required until GO casting not implemented
     // environment damage spells already have around enemies targeting but this not help in case nonexistent GO casting support
diff --git a/src/game/Spells/SpellHandler.cpp b/src/game/Spells/SpellHandler.cpp
index 84ecdbdcb..6b9f7eb65 100644
--- a/src/game/Spells/SpellHandler.cpp
+++ b/src/game/Spells/SpellHandler.cpp
@@ -358,11 +358,7 @@ void WorldSession::HandleCastSpellOpcode(WorldPacket& recvPacket)
     // client provided targets
     SpellCastTargets targets;
 
-#ifdef BUILD_PLAYERBOT
-    recvPacket >> targets.ReadForCaster(mover);
-#else
     recvPacket >> targets.ReadForCaster(_player);
-#endif
 
     // auto-selection buff level base at target level (in spellInfo)
     if (Unit* target = targets.getUnitTarget())
diff --git a/src/game/World/World.cpp b/src/game/World/World.cpp
index 367db8066..2278d7a96 100644
--- a/src/game/World/World.cpp
+++ b/src/game/World/World.cpp
@@ -66,6 +66,11 @@
 #include "Weather/Weather.h"
 #include "World/WorldState.h"
 #include "Cinematics/CinematicMgr.h"
+#ifdef ENABLE_PLAYERBOTS
+#include "AhBot.h"
+#include "PlayerbotAIConfig.h"
+#include "RandomPlayerbotMgr.h"
+#endif
 
 #include <algorithm>
 #include <mutex>
@@ -391,7 +396,7 @@ void World::LoadConfigSettings(bool reload)
     setConfigPos(CONFIG_FLOAT_RATE_XP_QUEST,                             "Rate.XP.Quest",                             1.0f);
     setConfigPos(CONFIG_FLOAT_RATE_XP_EXPLORE,                           "Rate.XP.Explore",                           1.0f);
     setConfigPos(CONFIG_FLOAT_RATE_REPUTATION_GAIN,                      "Rate.Reputation.Gain",                      1.0f);
-    setConfigPos(CONFIG_FLOAT_RATE_REPUTATION_LOWLEVEL_KILL,             "Rate.Reputation.LowLevel.Kill",             0.2f);
+    setConfigPos(CONFIG_FLOAT_RATE_REPUTATION_LOWLEVEL_KILL,             "Rate.Reputation.LowLevel.Kill",             1.0f);
     setConfigPos(CONFIG_FLOAT_RATE_REPUTATION_LOWLEVEL_QUEST,            "Rate.Reputation.LowLevel.Quest",            1.0f);
     setConfigPos(CONFIG_FLOAT_RATE_CREATURE_NORMAL_DAMAGE,               "Rate.Creature.Normal.Damage",               1.0f);
     setConfigPos(CONFIG_FLOAT_RATE_CREATURE_ELITE_ELITE_DAMAGE,          "Rate.Creature.Elite.Elite.Damage",          1.0f);
@@ -703,12 +708,14 @@ void World::LoadConfigSettings(bool reload)
     setConfigMin(CONFIG_UINT32_GUILD_EVENT_LOG_COUNT, "Guild.EventLogRecordsCount", GUILD_EVENTLOG_MAX_RECORDS, GUILD_EVENTLOG_MAX_RECORDS);
     setConfigMin(CONFIG_UINT32_GUILD_BANK_EVENT_LOG_COUNT, "Guild.BankEventLogRecordsCount", GUILD_BANK_MAX_LOGS, GUILD_BANK_MAX_LOGS);
 
-    setConfig(CONFIG_UINT32_MIRRORTIMER_FATIGUE_MAX,       "MirrorTimer.Fatigue.Max", 60);
-    setConfig(CONFIG_UINT32_MIRRORTIMER_BREATH_MAX,        "MirrorTimer.Breath.Max", 60);
-    setConfig(CONFIG_UINT32_MIRRORTIMER_ENVIRONMENTAL_MAX, "MirrorTimer.Environmental.Max", 1);
+    setConfig(CONFIG_UINT32_TIMERBAR_FATIGUE_GMLEVEL, "TimerBar.Fatigue.GMLevel", SEC_CONSOLE);
+    setConfig(CONFIG_UINT32_TIMERBAR_FATIGUE_MAX,     "TimerBar.Fatigue.Max", 60);
+    setConfig(CONFIG_UINT32_TIMERBAR_BREATH_GMLEVEL,  "TimerBar.Breath.GMLevel", SEC_CONSOLE);
+    setConfig(CONFIG_UINT32_TIMERBAR_BREATH_MAX,      "TimerBar.Breath.Max", 60);
+    setConfig(CONFIG_UINT32_TIMERBAR_FIRE_GMLEVEL,    "TimerBar.Fire.GMLevel", SEC_CONSOLE);
+    setConfig(CONFIG_UINT32_TIMERBAR_FIRE_MAX,        "TimerBar.Fire.Max", 1);
 
     setConfig(CONFIG_BOOL_PET_UNSUMMON_AT_MOUNT,      "PetUnsummonAtMount", false);
-    setConfig(CONFIG_BOOL_PET_ATTACK_FROM_BEHIND,     "PetAttackFromBehind", true);
 
     m_relocation_ai_notify_delay = sConfig.GetIntDefault("Visibility.AIRelocationNotifyDelay", 1000u);
     m_relocation_lower_limit_sq  = pow(sConfig.GetFloatDefault("Visibility.RelocationLowerLimit", 10), 2);
@@ -1348,9 +1355,11 @@ void World::SetInitialWorldSettings()
     sAuctionBot.Initialize();
     sLog.outString();
 
-#ifdef BUILD_PLAYERBOT
-    PlayerbotMgr::SetInitialWorldSettings();
+#ifdef ENABLE_PLAYERBOTS
+    auctionbot.Init();
+    sPlayerbotAIConfig.Initialize();
 #endif
+
     sLog.outString("---------------------------------------");
     sLog.outString("      CMANGOS: World initialized       ");
     sLog.outString("---------------------------------------");
@@ -1462,9 +1471,17 @@ void World::Update(uint32 diff)
     if (m_timers[WUPDATE_AHBOT].Passed())
     {
         sAuctionBot.Update();
+#ifdef ENABLE_PLAYERBOTS
+        auctionbot.Update();
+#endif
         m_timers[WUPDATE_AHBOT].Reset();
     }
 
+#ifdef ENABLE_PLAYERBOTS
+    sRandomPlayerbotMgr.UpdateAI(diff);
+    sRandomPlayerbotMgr.UpdateSessions(diff);
+#endif
+
     /// <li> Handle session updates
     UpdateSessions(diff);
 
@@ -1852,6 +1869,10 @@ void World::ShutdownServ(uint32 time, uint32 options, uint8 exitcode)
         m_ShutdownTimer = time;
         ShutdownMsg(true);
     }
+
+#ifdef ENABLE_PLAYERBOTS
+    sRandomPlayerbotMgr.LogoutAllBots();
+#endif
 }
 
 /// Display a shutdown message to the user(s)
diff --git a/src/game/World/World.h b/src/game/World/World.h
index 09c945eea..5d48249c4 100644
--- a/src/game/World/World.h
+++ b/src/game/World/World.h
@@ -171,9 +171,12 @@ enum eConfigUInt32Values
     CONFIG_UINT32_GROUP_OFFLINE_LEADER_DELAY,
     CONFIG_UINT32_GUILD_EVENT_LOG_COUNT,
     CONFIG_UINT32_GUILD_BANK_EVENT_LOG_COUNT,
-    CONFIG_UINT32_MIRRORTIMER_FATIGUE_MAX,
-    CONFIG_UINT32_MIRRORTIMER_BREATH_MAX,
-    CONFIG_UINT32_MIRRORTIMER_ENVIRONMENTAL_MAX,
+    CONFIG_UINT32_TIMERBAR_FATIGUE_GMLEVEL,
+    CONFIG_UINT32_TIMERBAR_FATIGUE_MAX,
+    CONFIG_UINT32_TIMERBAR_BREATH_GMLEVEL,
+    CONFIG_UINT32_TIMERBAR_BREATH_MAX,
+    CONFIG_UINT32_TIMERBAR_FIRE_GMLEVEL,
+    CONFIG_UINT32_TIMERBAR_FIRE_MAX,
     CONFIG_UINT32_MIN_LEVEL_STAT_SAVE,
     CONFIG_UINT32_CHARDELETE_KEEP_DAYS,
     CONFIG_UINT32_CHARDELETE_METHOD,
@@ -338,7 +341,6 @@ enum eConfigBoolValues
     CONFIG_BOOL_CLEAN_CHARACTER_DB,
     CONFIG_BOOL_VMAP_INDOOR_CHECK,
     CONFIG_BOOL_PET_UNSUMMON_AT_MOUNT,
-    CONFIG_BOOL_PET_ATTACK_FROM_BEHIND,
     CONFIG_BOOL_MMAP_ENABLED,
     CONFIG_BOOL_PLAYER_COMMANDS,
     CONFIG_BOOL_PATH_FIND_OPTIMIZE,
diff --git a/src/mangosd/mangosd.conf.dist.in b/src/mangosd/mangosd.conf.dist.in
index 7b8bf0f2a..8105c9f35 100644
--- a/src/mangosd/mangosd.conf.dist.in
+++ b/src/mangosd/mangosd.conf.dist.in
@@ -3,7 +3,7 @@
 #####################################
 
 [MangosdConf]
-ConfVersion=2019020601
+ConfVersion=2018092101
 
 ###################################################################################################################
 # CONNECTIONS AND DIRECTORIES
@@ -674,20 +674,32 @@ LogColors = ""
 #        Useful when you don't want old log events to be overwritten by new, but increasing can slow down performance
 #        Default: 25
 #
-#    MirrorTimer.Fatigue.Max
+#    TimerBar.Fatigue.GMLevel
+#        Disable/enable fatigue for security level (0..4) or high
+#        Default: 4 (None)
+#
+#    TimerBar.Fatigue.Max
 #        Fatigue max timer value (in secs)
 #        Default: 60 (1 minute)
-#                  0 (instant exhaustion damage start)
+#                  0 (instant death)
+#
+#    TimerBar.Breath.GMLevel
+#        Disable/enable waterbreathing for security level (0..4) or high
+#        Default: 4 (None)
 #
-#    MirrorTimer.Breath.Max
+#    TimerBar.Breath.Max
 #        Waterbreathing max timer value (in secs)
-#        Default: 60
-#                  0 (instant underwater breathing damage start)
+#        Default: 180
+#                   0 (instant underwater breathing damage start)
+#
+#    TimerBar.Fire.GMLevel
+#        Disable/enable lava fire damage for security level (0..4) or high
+#        Default: 4 (None)
 #
-#    MirrorTimer.Environmental.Max
-#        Generic environmental (lava/slime/etc) damage delay max timer value (in secs)
+#    TimerBar.Fire.Max
+#        Lava damage delay max timer value (in secs)
 #        Default:  1
-#                  0 (instant in liquid damage start)
+#                  0 (instant in lava damage start)
 #
 #    MaxPrimaryTradeSkill
 #        Max count that player can learn the primary trade skill.
@@ -734,15 +746,10 @@ LogColors = ""
 #                 1 - recheck offhand slot weapon at talent reset also
 #
 #    PetUnsummonAtMount
-#        Permanent pet will unsummoned at player mount
+#        Persmanent pet will unsummoned at player mount
 #        Default: 0 - unsummon only when appropriate (don't unsummon temp summons on ground mounting)
 #                 1 - always unsummon controlled pets on mounting
 #
-#    PetAttackFromBehind
-#        Player controlled pet will attack from behind
-#                 0 - Engage from any angle
-#        Default: 1 - Engage from behind
-#
 #    Event.Announce
 #        Default: 0 (false)
 #                 1 (true)
@@ -816,9 +823,12 @@ Quests.IgnoreRaid = 0
 Group.OfflineLeaderDelay = 300
 Guild.EventLogRecordsCount = 100
 Guild.BankEventLogRecordsCount = 25
-MirrorTimer.Fatigue.Max = 60
-MirrorTimer.Breath.Max = 60
-MirrorTimer.Environmental.Max = 1
+TimerBar.Fatigue.GMLevel = 4
+TimerBar.Fatigue.Max = 60
+TimerBar.Breath.GMLevel = 4
+TimerBar.Breath.Max = 60
+TimerBar.Fire.GMLevel = 4
+TimerBar.Fire.Max = 1
 MaxPrimaryTradeSkill = 2
 TradeSkill.GMIgnore.MaxPrimarySkillsCount = 4
 TradeSkill.GMIgnore.Level = 4
@@ -830,7 +840,6 @@ MassMailer.SendPerTick = 10
 SkillChance.Prospecting = 0
 OffhandCheckAtTalentsReset = 0
 PetUnsummonAtMount = 0
-PetAttackFromBehind = 1
 Event.Announce = 0
 BeepAtStart = 1
 ShowProgressBars = 0
@@ -1306,11 +1315,11 @@ Visibility.AIRelocationNotifyDelay = 1000
 #         Default: 1
 #
 #    Rate.Reputation.LowLevel.Kill
-#         Lowest Reputation Gain rate from low level kill
+#         Reputation Gain form low level kill (grey creture)
 #         Default: 0.2
 #
 #    Rate.Reputation.LowLevel.Quest
-#         Lowest Reputation Gain rate from low level quest
+#         Reputation Gain rate
 #         Default: 1
 #
 #    Rate.InstanceResetTime
diff --git a/src/shared/Database/Database.cpp b/src/shared/Database/Database.cpp
index 9c02f0443..f2e2af45e 100644
--- a/src/shared/Database/Database.cpp
+++ b/src/shared/Database/Database.cpp
@@ -495,22 +495,8 @@ bool Database::CheckRequiredField(char const* table_name, char const* required_n
             sLog.outErrorDb("  [B] You need: --> `%s.sql`", req_sql_update_name);
             sLog.outErrorDb();
             sLog.outErrorDb("You must apply all updates after [A] to [B] to use mangos with this database.");
-#ifdef BUILD_PLAYERBOT
-            if (reqName.find("playerbot") != std::string::npos)
-            {
-                sLog.outErrorDb("These updates are included in the [sql/PlayerBot] folder.");
-                sLog.outErrorDb("Please read the [doc/README.Playerbot] file for instructions on updating.");
-            }
-            else
-            {
-                // Unmodded core code below
-                sLog.outErrorDb("These updates are included in the sql/updates folder.");
-                sLog.outErrorDb("Please read the included [README] in sql/updates for instructions on updating.");
-            }
-#else
             sLog.outErrorDb("These updates are included in the sql/updates folder.");
             sLog.outErrorDb("Please read the included [README] in sql/updates for instructions on updating.");
-#endif
         }
         else
         {
diff --git a/src/shared/SystemConfig.h b/src/shared/SystemConfig.h
index 987560500..6d643db1b 100644
--- a/src/shared/SystemConfig.h
+++ b/src/shared/SystemConfig.h
@@ -37,7 +37,7 @@
 // Format is YYYYMMDDRR where RR is the change in the conf file
 // for that day.
 #ifndef _MANGOSDCONFVERSION
-# define _MANGOSDCONFVERSION 2019020601
+# define _MANGOSDCONFVERSION 2018060601
 #endif
 #ifndef _REALMDCONFVERSION
 # define _REALMDCONFVERSION 2010062001
